<!DOCTYPE html>
<html lang="cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>变量的作用域 · Julia程序设计基础</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Julia程序设计基础 logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Julia程序设计基础</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">安装与配置</a></li><li><a class="tocitem" href="../ch02dadatypes/">数据类型</a></li><li><a class="tocitem" href="../ch03controlflows/">控制流</a></li><li><a class="tocitem" href="../ch04function/">函数和方法</a></li><li class="is-active"><a class="tocitem" href>变量的作用域</a><ul class="internal"><li><a class="tocitem" href="#作用域构造"><span>作用域构造</span></a></li><li><a class="tocitem" href="#全局作用域"><span>全局作用域</span></a></li><li><a class="tocitem" href="#局部作用域"><span>局部作用域</span></a></li><li><a class="tocitem" href="#常量"><span>常量</span></a></li></ul></li><li><a class="tocitem" href="../ch06datacollection/">数据集</a></li><li><a class="tocitem" href="../ch07array/">数组</a></li><li><a class="tocitem" href="../ch08string/">字符串</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>变量的作用域</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>变量的作用域</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="变量的作用域"><a class="docs-heading-anchor" href="#变量的作用域">变量的作用域</a><a id="变量的作用域-1"></a><a class="docs-heading-anchor-permalink" href="#变量的作用域" title="Permalink"></a></h1><p>变量的<strong>作用域</strong>是变量在代码中可见的范围。变量作用域有助于避免变量命名冲突。这个概念很直观:两个函数都可以有称为<code>x</code>的参数，但这两个<code>x</code>所指的不是同一件事。类似地，在许多其他情况下，不同的代码块可以使用相同的名称而不引用相同的东西。当相同的变量名指向或不指向同一事物时，这种规则称为作用域规则。本章将对它们进行详细说明。</p><p>语言中的某些构造引入了<strong>范围块</strong>，在这些范围块内，规定了某些变量集的作用域。变量的作用域不能是源代码的任意一组集合，相反，它将总是与这些块中的一个相关。在Julia中有两种主要类型的作用域，全局作用域和局部作用域。后者可以嵌套。在Julia中，构造的“硬作用域”和“软作用域”之间也有区别，它们会影响是否允许使用同名变量隐藏一个全局变量。</p><h2 id="作用域构造"><a class="docs-heading-anchor" href="#作用域构造">作用域构造</a><a id="作用域构造-1"></a><a class="docs-heading-anchor-permalink" href="#作用域构造" title="Permalink"></a></h2><p>引入作用域块的构造有：</p><table><tr><th style="text-align: left">构造</th><th style="text-align: left">作用域类型</th><th style="text-align: left">允许的位置</th></tr><tr><td style="text-align: left"><code>module</code>，<code>baremodue</code></td><td style="text-align: left">全局</td><td style="text-align: left">全局</td></tr><tr><td style="text-align: left"><code>struct</code></td><td style="text-align: left">局部（软）</td><td style="text-align: left">全局</td></tr><tr><td style="text-align: left"><code>for</code>，<code>while</code>，<code>try</code></td><td style="text-align: left">局部（软）</td><td style="text-align: left">全局，局部</td></tr><tr><td style="text-align: left"><code>macro</code></td><td style="text-align: left">局部（硬）</td><td style="text-align: left">全局</td></tr><tr><td style="text-align: left">函数，<code>do</code>块，<code>let</code>块，推导，生成器</td><td style="text-align: left">局部（硬）</td><td style="text-align: left">全局，局部</td></tr></table><p>值得注意的是，这个表中没有<code>begin</code>块和<code>if</code>块，它们没有引入新的作用域。这三种类型的作用域遵循不同的规则，下面将对此进行解释。</p><p>Julia使用词法作用域，这意味着函数的作用域不是继承自调用者的作用域，而是继承自定义函数的作用域。例如，在以下代码中，<code>foo</code>中的<code>x</code>引用了其模块<code>Bar</code>的全局作用域中的<code>x</code>：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; module Bar
           x = 1
           foo() = x
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>而不是使用<code>foo</code>的作用域中的<code>x</code>：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import .Bar</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = -1;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Bar.foo()</code><code class="nohighlight hljs ansi" style="display:block;">1</code></pre><p>因此，词法作用域意味着特定代码段中的变量所引用的内容可以单独从其出现的代码中推断出来，而不依赖于程序的执行方式。嵌套在另一个作用域中的作用域可以“看到”包含它的所有外部作用域中的变量。但是，外部作用域不能看到内部作用域中的变量。</p><h2 id="全局作用域"><a class="docs-heading-anchor" href="#全局作用域">全局作用域</a><a id="全局作用域-1"></a><a class="docs-heading-anchor-permalink" href="#全局作用域" title="Permalink"></a></h2><p>每个模块都引入一个新的全局作用域，它与所有其他模块的全局作用域分开——不存在包含所有全局作用域的全局作用域。模块可以通过<code>using</code>或<code>import</code>语句，或通过使用点表示法的授权访问，将其他模块的变量引入其作用域，即每个模块都是一个所谓的命名空间，也是一个将名称与值关联起来的一级数据结构。注意，虽然可以在外部读取变量绑定的值，但只能在它们所属的模块内更改它们。作为一个安全门，你总是可以在模块内执行代码来修改一个变量。这避免了模块绑定在外部不通过调用<code>eval</code>而直接对代码进行修改。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; module A
           a = 1 # a global in A&#39;s scope
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; module B
           module C
               c = 2
           end
           b = C.c    # can access the namespace of a nested global scope
                      # through a qualified access
           import ..A # makes module A available
           d = A.a
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; module D
           b = a  # errors as D&#39;s global scope is separate from A&#39;s
       end;</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: a not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; module E
           import ..A  # make module A available
           A.a = 2     # throws an error
       end;</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: cannot assign variables in other modules</code></pre><p>注意，交互提示符(又名REPL)位于模块<code>Main</code>的全局作用域内。</p><h2 id="局部作用域"><a class="docs-heading-anchor" href="#局部作用域">局部作用域</a><a id="局部作用域-1"></a><a class="docs-heading-anchor-permalink" href="#局部作用域" title="Permalink"></a></h2><p>大多数代码块都会引入一个新的局部作用域(完整列表见上表)。一些编程语言要求在使用新变量之前会显式地声明它们。在Julia中也可以使用显式声明：在任何局部作用域中，不管外部作用域中是否已经存在名为<code>x</code>的变量，写入<code>local x</code>就在该作用域中声明了一个新的局部变量。然而，像这样声明每个新的局部变量有点冗长和乏味，因此，与许多其他语言一样，Julia通过在局部作用域中对新变量赋值，从而隐式地将该变量声明为一个新的局部变量。大多数情况下，这是相当直观的，但与许多凭直觉行事的事情一样，细节要比从表面看起来的要微妙得多。</p><p>当<code>x = &lt;value&gt;</code>发生在局部作用域中时，Julia应用以下规则，根据赋值表达式发生的位置和<code>x</code>在该位置已经引用的内容来决定表达式的含义：</p><ol><li><p><strong>现有的局部变量</strong>：如果<code>x</code>已经是一个局部变量，则对现有的局部变量<code>x</code>赋值。</p></li><li><p><strong>硬作用域</strong>：如果<code>x</code>还不是一个局部变量，并且赋值发生在硬作用域构造中(例如，在<code>let</code>块、函数或宏体、推导或生成器中)，则在赋值的作用域中创建一个名为<code>x</code>的新局部变量。</p></li><li><p><strong>软作用域</strong>：如果<code>x</code>还不是一个局部变量，并且所有包含赋值的作用域结构都是软作用域(循环、<code>try</code>/<code>catch</code>块或<code>struct</code>块)，则行为取决于是否定义了全局变量<code>x</code>：</p><ul><li><p>如果全局<code>x</code>未定义，则在赋值范围内创建一个名为<code>x</code>的新局部变量。</p></li><li><p>如果定义了全局<code>x</code>，赋值被认为是歧义的：</p><ul><li><p>在非交互式环境中(文件，<code>eval</code>)，会打印一个歧义警告，并创建一个新的局部变量。</p></li><li><p>在交互式环境中(REPL, notebook)，全局变量<code>x</code>被赋值。</p></li></ul></li></ul></li></ol><p>你可能会注意到，在非交互式环境中，硬作用域和软作用域的行为是相同的，只不过在软作用域中，当一个隐式局部变量(即没有使用<code>local x</code>声明)对全局变量造成屏蔽时，会打印一个警告。在交互式环境中，为了方便起见，规则遵循更复杂的启发式。下面的示例将深入讨论这一点。</p><p>既然已经知道了规则，让我们看一些例子。假设每个示例都是在一个全新的REPL会话中计算的，这样每个代码段中的惟一全局变量就是在该代码块中分配的全局变量。</p><p>我们将从一个优雅而明确的情况开始——在硬作用域内赋值，在本例中是一个函数体，此时不存在同名的局部变量：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function greet()
           x = &quot;hello&quot;  # new local
           println(x)
       end</code><code class="nohighlight hljs ansi" style="display:block;">greet (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; greet()</code><code class="nohighlight hljs ansi" style="display:block;">hello</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x  # global</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: x not defined</code></pre><p>在<code>greet</code>函数内部，赋值<code>x = &quot;hello&quot;</code>使<code>x</code>成为函数作用域中的一个新的局部变量。有两个相关的事实：赋值发生在局部作用域中，并且没有现有的局部<code>x</code>变量。因为<code>x</code>是局部的，所以是否存在一个全局变量<code>x</code>并不重要。例如，在定义和调用<code>greet</code>之前，我们先定义了<code>x = 123</code>：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = 123  # global</code><code class="nohighlight hljs ansi" style="display:block;">123</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function greet()
           x = &quot;hello&quot;  # new local
           println(x)
       end</code><code class="nohighlight hljs ansi" style="display:block;">greet (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; greet()</code><code class="nohighlight hljs ansi" style="display:block;">hello</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x  #global</code><code class="nohighlight hljs ansi" style="display:block;">123</code></pre><p>由于<code>greet</code>中的<code>x</code>是局部的，全局<code>x</code>的值(或不存在这样的值)不受调用<code>greet</code>的影响。硬作用域规则并不关心名为<code>x</code>的全局变量是否存在：在硬作用域中对<code>x</code>的赋值是局部的(除非<code>x</code>在其中被显示地声明为全局的)。</p><p>我们要考虑的下一个明确的情况是，已经有一个名为<code>x</code>的局部变量，在这种情况下，<code>x = &lt;value&gt;</code>总是赋值给这个已经存在的局部变量<code>x</code>。下面的函数<code>sum_to</code>计算从1到n的数字之和：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function sum_to(n)
           s = 0  # new local
           for i = 1:n
               s = s + i  # assign existing local
           end
           return s    # same local
       end</code><code class="nohighlight hljs ansi" style="display:block;">sum_to (generic function with 1 method)</code></pre><p>与前面的示例一样，在<code>sum_to</code>的顶部对<code>s</code>的第一次赋值将导致<code>s</code>成为函数体中的一个新的局部变量。<code>for</code>循环在函数作用域中有自己的内部局部作用域。当<code>s = s + i</code>出现时，<code>s</code>已经是一个局部变量，因此赋值更新了现有的<code>s</code>，而不是创建一个新的局部变量。我们可以通过调用REPL中的<code>sum_to</code>来测试：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum_to(10)</code><code class="nohighlight hljs ansi" style="display:block;">55</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: s not defined</code></pre><p>因为<code>s</code>是<code>sum_to</code>的本地函数,调用函数对全局变量<code>s</code>没有影响。我们也可以看到在<code>for</code>循环中更新<code>s = s + i</code>必定更新了由初始化<code>s = 0</code>创建的<code>s</code>，因为我们得到了从整数1到10的正确的和55。</p><p>让我们先深入了解一下<code>for</code>循环体有它自己的作用域这一事实，我们可以写一个稍微更复杂的变体<code>sum_to_def</code>，在更新<code>s</code>之前将和<code>s + i</code>保存在变量<code>t</code>中：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function sum_to_def(n)
           s = 0   # new local
           for i = 1:n
               t = s + i   # new local `t`
               s = t       # assign existing local `s`
           end
           return s, @isdefined(t)
       end</code><code class="nohighlight hljs ansi" style="display:block;">sum_to_def (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum_to_def(10)</code><code class="nohighlight hljs ansi" style="display:block;">(55, false)</code></pre><p>这个版本像以前一样返回<code>s</code>，但它也使用<code>@isdefined</code>宏返回一个布尔值，显示函数的最外层局部作用域中是否定义了一个名为<code>t</code>的局部变量。如你所见，在<code>for</code>循环体之外没有定义<code>t</code>。这还是因为硬作用域规则：由于对<code>t</code>的赋值发生在函数内部，这引入了硬作用域，赋值导致<code>t</code>在它出现的局部作用域内成为一个新的局部变量，即在循环体内部。即使有一个名为<code>t</code>的全局变量，也不会有什么区别——硬作用域规则不会受到全局作用域中情况的影响。</p><p>让我们来看看软作用域规则所涵盖的一些更模糊的情况。我们将通过将<code>greet</code>和<code>sum_to_def</code>函数的主体提取到软作用域环境中来研究这个问题。首先，让我们把<code>greet</code>的主体放到<code>for</code>循环中——它是软的，而不是硬的——然后在REPL中计算它：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; for i = 1:3
           x = &quot;hello&quot; # new local
           println(x)
       end</code><code class="nohighlight hljs ansi" style="display:block;">hello
hello
hello</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: x not defined</code></pre><p>由于在执行<code>for</code>循环时没有定义全局<code>x</code>，因此软作用域规则的第一种情况将被应用，<code>x</code>将被创建为<code>for</code>循环的局部变量，因此在循环执行后全局<code>x</code>仍未定义。接下来，让我们考虑将<code>sum_to_def</code>的主体提取到全局作用域，将其参数固定为<code>n = 10</code>：</p><pre><code class="language-julia hljs">s = 0
for i = 1:10
    t = s + i
    s = t
end
s
@isdefined(t)</code></pre><p>这段代码做了什么的？这是个棘手的问题。答案是“视情况而定”。如果以交互方式输入此代码，则其行为与在函数体中相同。但是，如果代码出现在文件中，它会打印一个歧义警告，并抛出一个未定义变量的错误。让我们先看看它在REPL中的工作情况：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = 0   # global</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for i = 1:10
           t = s + i   # new local `t`
           s = t       # assign global `s`
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s   # global</code><code class="nohighlight hljs ansi" style="display:block;">55</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @isdefined(t)   # global</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><p>REPL通过判断是否定义了同名的全局变量来确定循环内的赋值是赋值给全局变量还是创建新的局部变量，这种行为近似于函数体内的行为。如果存在同名的全局变量，则赋值操作会更新它。如果不存在全局变量，则赋值将创建一个新的局部变量。在这个例子中，我们看到了这两种情况：</p><ul><li><p>没有全局变量<code>t</code>，所以<code>t = s + i</code>创建一个新的<code>t</code>，它是<code>for</code>循环的局部变量。</p></li><li><p>有一个全局变量<code>s</code>，所以<code>s = t</code>赋值给它。</p></li></ul><p>第二条解释了为什么循环的执行会改变<code>s</code>的全局值，第一条解释了为什么在循环执行后<code>t</code>仍然是未定义的。现在，让我们对相同的代码进行改造，模拟代码在文件中的情况，然后执行：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; code = &quot;&quot;&quot;
       s = 0   # global
       for i = 1:10
           t = s + i   # new local `t`
           s = t   # new local `s` with warning
       end
       s,  # global
       @isdefined(t)   # global
       &quot;&quot;&quot;;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; include_string(Main, code)</code><code class="nohighlight hljs ansi" style="display:block;">┌ Warning: Assignment to `s` in soft scope is ambiguous because a global variable by the same name exists: `s` will be treated as a new local. Disambiguate by using `local s` to suppress this warning or `global s` to assign to the existing global variable.
└ @ string:4
ERROR: LoadError: UndefVarError: s not defined
in expression starting at string:2</code></pre><p>这里我们使用<code>include_string</code>来执行代码，就好像它是文件的内容一样。我们也可以将代码保存到文件中，然后在该文件上调用<code>include</code>——结果将是相同的。如你所见，这与在REPL中的结果有很大的不同。让我们来分析一下这里发生了什么：</p><ul><li><p>在执行循环之前，全局变量<code>s</code>被定义为值0。</p></li><li><p>赋值<code>s = t</code>发生在软作用域中——任何函数体或其他硬作用域构造之外的<code>for</code>循环中。</p></li><li><p>因此，适用于软作用域规则的第二种情况，并且赋值是不明确的，因此会发出警告。</p></li><li><p>继续执行，使<code>s</code>成为<code>for</code>循环体的局部变量。</p></li><li><p>由于<code>s</code>是<code>for</code>循环的局部变量，当<code>t = s + i</code>被求值时，它是未定义的，从而导致错误。</p></li><li><p>计算到此结束，但如果到达<code>s</code>和<code>@isdefined(t)</code>，它将返回<code>0</code>和<code>false</code>。</p></li></ul><p>这演示了作用域的一些重要方面：在作用域中，每个变量只能有一种含义，并且该含义与表达式的顺序无关。在循环中表达式<code>s = t</code>的存在导致<code>s</code>是循环的局部变量，这意味着当它出现在<code>t = s + i</code>的右边时，它也是局部变量，即使该表达式首先出现并首先执行。你或许会认为循环第一行的<code>s</code>可以是全局的，循环第二行的<code>s</code>可以是本地的，但实际上是不可能的，因为这两行在同一个作用域块，在给定的作用域，每个变量只能有一种含义。</p><h3 id="关于软作用域"><a class="docs-heading-anchor" href="#关于软作用域">关于软作用域</a><a id="关于软作用域-1"></a><a class="docs-heading-anchor-permalink" href="#关于软作用域" title="Permalink"></a></h3><p>现在，我们已经介绍了所有的局部作用域规则，但是在结束本节之前，应该说明一下为什么在交互和非交互环境中处理模糊的软作用域情况是不同的。人们可能会问两个明显的问题：</p><ol><li><p>为何不在所有地方都像在REPL中那样的工作呢？</p></li><li><p>为和不在所有地方都像在文件中那样工作并去掉警告呢？</p></li></ol><p>在Julia≤0.6,所有全局作用域的工作方式都如同当前的REPL一样：当<code>x = &lt;value&gt;</code>发生在一个循环(或<code>try</code>/<code>catch</code>，或<code>struct</code>体)内，但在函数体(或<code>let</code>块或推导)以外，<code>x</code>在循环内是否为局部的取决于是否定义了全局变量<code>x</code>。这种行为具有直观和方便的优点，因为它尽可能接近函数体内部的行为。特别地，当调试函数的行为时，它使得在函数体和REPL之间来回移动代码变得很容易。然而，它也有一些缺点。首先，这是一种相当复杂的行为：多年来，许多人对这种行为感到困惑，并抱怨它既复杂又难以解释和理解。其次，可以说更糟糕的是，它不利于“大规模”编程。当你在一个地方看到像这样的一小段代码时，很清楚会发生什么：</p><pre><code class="language-julia hljs">s = 0
for i = 1:10
    s += i
end</code></pre><p>显然，其目的是修改现有的全局变量<code>s</code>，不然会是什么呢？然而，并非所有现实世界的代码都是如此简短或清晰。我们发现像下面这样的代码经常大量的出现：</p><pre><code class="language-julia hljs">x = 123

# much later
# maybe in a different file

for i = 1:10
    x = &quot;hello&quot;
    prinntln(x)
end

# much later
# maybe in yet another file
# or maybe back in the first one where `x = 123`

y = x + 234</code></pre><p>现在就不是很明确应该发生什么。因为<code>x + &quot;hello&quot;</code>是一个方法错误，它的意图似乎是让<code>x</code>在<code>for</code>循环中是局部的。但是运行时的值和当时存在的方法不能用来确定变量的作用域。在Julia≤0.6的行为方式下，会存在有人先写了<code>for</code>循环，它可以很好的工作，但后来当别人在远处（可能在不同的文件中）添加了一个新的全局变量，代码突然改变了含义，它可能会显式地终止，更糟的是，有可能默默地做错误的事情。这种“幽灵般的远距离行动”是优秀的程序语言设计应该避免的。</p><p>因此，在Julia 1.0中，简化了作用域规则：在任何局部作用域中，对一个不属于局部变量的名称赋值将创建一个新的局部变量。这完全消除了软作用域的概念，并消除了幽灵行动的可能性。软作用域的删除使大量的bug得到了暴露和修复，这也证明了选择删除它是正确的。但也存在一些不便，如下面的代码所示：</p><pre><code class="language-julia hljs">s = 0
for i = 1:10
    global s += i
end</code></pre><p>看到全局注释了吗？显然，这种情况是不能容忍的。但严格地说，这种需要<code>global</code>的顶层代码存在两个主要问题：</p><ol><li><p>不方便将函数体中的代码复制并粘贴到REPL中进行调试——你必须在调试时添加<code>global</code>注释，然后在拷回函数时删除它们。</p></li><li><p>初学者会在编写这类代码时漏掉<code>global</code>，并对代码不能工作感到莫名其妙——他们得到的错误是<code>s</code>未被定义，这似乎对碰巧犯这种错误的人没有任何启发效果。</p></li></ol><p>从Julia 1.5开始，这段代码在交互式环境中(如REPL或Jupyter笔记本)不需要<code>global</code>注释(就像Julia 0.6)，在文件和其他非交互式环境中，它打印出非常直接的警告：</p><blockquote><p>在软作用域中对<code>s</code>的赋值是不明确的，因为存在同名的全局变量：<code>s</code>将被视为一个新的局部变量。通过使用<code>local s</code>来消除该警告，或使用<code>global s</code>来赋值给现有的全局变量来消除歧义。</p></blockquote><p>这既解决了上述两个问题，又保留了1.0中“大规模编程”好处的行为：全局变量对可能遥远的代码含义没有幽灵影响。在REPL中复制粘贴调试工作良好，初学者也不会遇到任何问题，任何时候，如果有人忘记了一个<code>global</code>注释，或者不小心在一个软作用域中用一个局部隐藏了一个现有的全局变量（虽然听起来很奇怪），他们就会得到一个清晰的警告。</p><p>这种设计的一个重要属性是，任何在文件中执行而没有警告的代码在新的REPL中都将以相同的方式执行。另一方面，如果你使用一个REPL会话并将其保存到文件中，如果它的行为与在REPL中不同，那么你将得到一个警告。</p><h3 id="Let块"><a class="docs-heading-anchor" href="#Let块">Let块</a><a id="Let块-1"></a><a class="docs-heading-anchor-permalink" href="#Let块" title="Permalink"></a></h3><p>与对局部变量的赋值不同，<code>let</code>语句在每次运行时分配新的变量绑定。赋值会修改现有值的位置，<code>let</code>会创建新的位置。这种差异通常并不重要，只有在变量通过闭包存活的时间超过其作用域的情况下才会显现。<code>let</code>语法接受逗号分隔的一系列赋值和变量名：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x, y, z = -1, -1, -1;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; let x = 1, z
           println(&quot;x: $x, y: $y&quot;) # x is local variable, y the global
           println(&quot;z: $z&quot;) # errors as z has not been assigned yet but is local
       end</code><code class="nohighlight hljs ansi" style="display:block;">x: 1, y: -1
ERROR: UndefVarError: z not defined</code></pre><p>赋值是按顺序执行的，在左边的新变量被引入之前，右边的每个变量都在作用域内求值。因此，写<code>let x = x</code>是有意义的，因为两个<code>x</code>变量是不同的，有不同的存储空间。下面是一个需要<code>let</code>行为的例子：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Fs = Vector{Any}(undef, 2); i = 1;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; while i &lt;= 2
           Fs[i] = () -&gt; i
           global i += 1
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Fs[1]()</code><code class="nohighlight hljs ansi" style="display:block;">3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Fs[2]()</code><code class="nohighlight hljs ansi" style="display:block;">3</code></pre><p>在这里，我们创建并存储了两个返回变量<code>i</code>的闭包。然而，它始终是同一个变量<code>i</code>，因此两个闭包的行为是相同的。我们可以使用<code>let</code>为<code>i</code>创建一个新的绑定：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Fs = Vector{Any}(undef, 2); i = 1;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; while i &lt;= 2
           let i = i
               Fs[i] = () -&gt; i
           end
           global i += 1
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Fs[1]()</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Fs[2]()</code><code class="nohighlight hljs ansi" style="display:block;">2</code></pre><p>由于<code>begin</code>构造不引入新的作用域，所以使用零参数<code>let</code>只引入一个新的作用域块而不创建任何新绑定是很有用的：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; let
           local x = 1
           let
               local x = 2
           end
           x
       end</code><code class="nohighlight hljs ansi" style="display:block;">1</code></pre><p>因为<code>let</code>引入了一个新的作用域块，所以内部的局部变量<code>x</code>与外部的局部变量<code>x</code>是不同的。</p><h3 id="循环和推导"><a class="docs-heading-anchor" href="#循环和推导">循环和推导</a><a id="循环和推导-1"></a><a class="docs-heading-anchor-permalink" href="#循环和推导" title="Permalink"></a></h3><p>在循环和推导式中，在其主体作用域中引入的新变量会在每次循环迭代时重新分配，就像循环主体被一个<code>let</code>块包围一样，如下例所示：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Fs = Vector{Any}(undef, 2);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for j = 1:2
           Fs[j] = ()-&gt;j
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Fs[1]()</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Fs[2]()</code><code class="nohighlight hljs ansi" style="display:block;">2</code></pre><p><code>for</code>循环或推导迭代变量总是一个新变量：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f()
           i = 0
           for i = 1:3
               # empty
           end
           return i
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f()</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>然而，有时可以重用现有的局部变量作为迭代变量。这可以通过添加关键字<code>outer</code>方便地完成：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f()
           i = 0
           for outer i = 1:3
               # empty
           end
           return i
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f()</code><code class="nohighlight hljs ansi" style="display:block;">3</code></pre><h2 id="常量"><a class="docs-heading-anchor" href="#常量">常量</a><a id="常量-1"></a><a class="docs-heading-anchor-permalink" href="#常量" title="Permalink"></a></h2><p>变量的一个常见用法是给特定的、不变的值命名。这样的变量只被赋值一次。这个意图可以通过使用<code>const</code>关键字传递给编译器：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; const e = 2.718;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; const pi = 3.142;</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>可以在一个<code>const</code>语句中声明多个变量：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; const a, b = 1, 2</code><code class="nohighlight hljs ansi" style="display:block;">(1, 2)</code></pre><p><code>const</code>声明只能在全局作用域中的全局变量上使用。编译器很难优化涉及全局变量的代码，因为它们的值(甚至它们的类型)几乎在任何时候都可能发生改变。如果全局变量不变，添加<code>const</code>声明就可以解决这个性能问题。</p><p>局部常量则不同的。编译器能够自动确定局部变量何时为常量，因此不需要声明局部常量，实际上目前也不支持局部常量。</p><p>特殊的顶层赋值，例如由<code>function</code>和<code>struct</code>关键字执行的赋值，默认情况下是常量。</p><p>注意，<code>const</code>只影响变量绑定。变量可以绑定到一个可变对象(比如数组)，并且该对象仍然可以被修改。另外，当试图给一个被声明为常量的变量赋值时，可能会出现以下情况：</p><ul><li>如果新值的类型与常量的类型不同，则抛出一个错误：</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; const x = 1.0</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = 1</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: invalid redefinition of constant x</code></pre><ul><li>如果新值的类型与常量相同，则会打印警告：</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; const y = 1.0</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = 2.0</code><code class="nohighlight hljs ansi" style="display:block;">WARNING: redefinition of constant y. This may fail, cause incorrect answers, or produce other errors.
2.0</code></pre><ul><li>如果赋值不会导致变量值的改变，则不会给出消息：</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; const z = 100</code><code class="nohighlight hljs ansi" style="display:block;">100</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; z = 100</code><code class="nohighlight hljs ansi" style="display:block;">100</code></pre><p>最后一条规则适用于不可变对象，只要值不发生改变，变量的重新绑定实际上是被忽略的，例如：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; const s1 = &quot;1&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;1&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s2 = &quot;1&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;1&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pointer.([s1, s2], 1)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Ptr{UInt8}}:
 Ptr{UInt8} @0x00007efd15b8c2f8
 Ptr{UInt8} @0x00007efd15b8c358</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s1 = s2</code><code class="nohighlight hljs ansi" style="display:block;">&quot;1&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pointer.([s1, s2], 1)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Ptr{UInt8}}:
 Ptr{UInt8} @0x00007efd15b8c2f8
 Ptr{UInt8} @0x00007efd15b8c358</code></pre><p>然而，对于可变对象，会按预期打印警告：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; const a = [1]</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Int64}:
 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = [1]</code><code class="nohighlight hljs ansi" style="display:block;">WARNING: redefinition of constant a. This may fail, cause incorrect answers, or produce other errors.
1-element Vector{Int64}:
 1</code></pre><p>请注意，尽管有时可以，但强烈建议不要更改<code>const</code>变量的值，除非在交互使用时为了方便而故意为之。更改常量可能会导致各种问题或意外行为。例如，如果一个方法引用了一个常量，并且在更改该常量之前已经编译过了，那么它将会继续使用原来的值：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; const x = 1</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f() = x</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f()</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = 2</code><code class="nohighlight hljs ansi" style="display:block;">WARNING: redefinition of constant x. This may fail, cause incorrect answers, or produce other errors.
2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f()</code><code class="nohighlight hljs ansi" style="display:block;">1</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ch04function/">« 函数和方法</a><a class="docs-footer-nextpage" href="../ch06datacollection/">数据集 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 20 December 2021 14:01">Monday 20 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
