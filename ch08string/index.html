<!DOCTYPE html>
<html lang="cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>字符串 · Julia程序设计基础</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Julia程序设计基础 logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Julia程序设计基础</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">安装与配置</a></li><li><a class="tocitem" href="../ch02dadatypes/">数据类型</a></li><li><a class="tocitem" href="../ch03controlflows/">控制流</a></li><li><a class="tocitem" href="../ch04function/">函数和方法</a></li><li><a class="tocitem" href="../ch05scope/">变量的作用域</a></li><li><a class="tocitem" href="../ch06datacollection/">数据集</a></li><li><a class="tocitem" href="../ch07array/">数组</a></li><li class="is-active"><a class="tocitem" href>字符串</a><ul class="internal"><li><a class="tocitem" href="#字符串-2"><span>字符串</span></a></li><li><a class="tocitem" href="#字符"><span>字符</span></a></li><li><a class="tocitem" href="#编码"><span>编码</span></a></li><li><a class="tocitem" href="#字体和字形"><span>字体和字形</span></a></li><li><a class="tocitem" href="#字符串-3"><span>字符串</span></a></li><li><a class="tocitem" href="#字符串方法"><span>字符串方法</span></a></li><li><a class="tocitem" href="#字符数组"><span>字符数组</span></a></li><li><a class="tocitem" href="#用户定义字符串"><span>用户定义字符串</span></a></li></ul></li><li><a class="tocitem" href="../ch09metaprograme/">元编程</a></li><li><a class="tocitem" href="../ch10file/">文件</a></li><li><a class="tocitem" href="../ch11guidelines/">编程风格</a></li><li><a class="tocitem" href="../ch12performance/">性能</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>字符串</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>字符串</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="字符串"><a class="docs-heading-anchor" href="#字符串">字符串</a><a id="字符串-1"></a><a class="docs-heading-anchor-permalink" href="#字符串" title="Permalink"></a></h1><p>文本是当今计算中最常用的数据类型之一。文本可以表示特定自然语言中的特定表达式(如英语中的句子)，任意字符的二进制转储(如二进制字节数组)，表达式的多语言表示(其中句子可能包含来自另一种语言的单词)。我们将介绍在Julia中文本是如何表现的。</p><p>一个句子可能包含来自多种语言的符号和字符。例如，英语句子中的数学符号和希腊表达式。最后，文本通常被用作除了使用文本关键字外没有其他方法表示实体的最后手段。对于这种情况，虽然经常使用Julia符号，但是文本也是可以的。本章将对前面所讨论的各个方面作一些详细的探讨。文本使用的多样性带来了许多表示方面的挑战，我们必须从概念上理解Julia语言的设计。虽然文本的结构可能会涉及文档结构和表示的复杂性，但我们将把讨论的范围限制在字符串的概念上。</p><h2 id="字符串-2"><a class="docs-heading-anchor" href="#字符串-2">字符串</a><a class="docs-heading-anchor-permalink" href="#字符串-2" title="Permalink"></a></h2><p>字符串是作为文本表示的字符的集合。虽然它们在特定语言中可能是有意义的句子，但它们可以是完全没有意义的字符的集合。</p><p><em>This is a valid sentence.</em></p><p><em>Abccnajkvnkavnak</em></p><p>前面两行都是有效的字符串，但在英语中不都是有效的句子。</p><h2 id="字符"><a class="docs-heading-anchor" href="#字符">字符</a><a id="字符-1"></a><a class="docs-heading-anchor-permalink" href="#字符" title="Permalink"></a></h2><p>一组字符组成一个字符串。在前面的例子中：</p><p><code>[&#39; &#39;, &#39;T&#39;, &#39;a&#39;, &#39;c&#39;, &#39;d&#39;, ‘e’, ‘h’, ‘i’, ‘l’, ‘n’, ‘s’, ‘t’, &#39;v&#39;]</code>字符组成句子 <em>This is a valid sentence</em>。</p><p>字符在集中的顺序和位置也很重要。</p><h2 id="编码"><a class="docs-heading-anchor" href="#编码">编码</a><a id="编码-1"></a><a class="docs-heading-anchor-permalink" href="#编码" title="Permalink"></a></h2><p>我们平时书写的字符对计算机来说没有任何意义。在计算机中，每个实体都被表示为一个数值或数值的等价二进制值。这样的数字被称为<strong>编码</strong>。在使用美国信息交换标准码(ASCII)作为编码方案的计算机中，字符<code>a</code>被表示为编码值97或0x61。ASCII只是表示英语字符集编码中的一种。另外一种是扩展二进制编码的十进制交换码(EBCDIC)，它曾是IBM大型机的首选，但现在不再流行了。在开始研究文本的Julia语言结构之前，我们将从概念上讨论一些编码（在深入研究一些具体编码之前，先进行一些理论理解）。这个介绍不完全按照时间的先后顺序，因为我们的重点是获得一种直观的理解。</p><h3 id="ASCII"><a class="docs-heading-anchor" href="#ASCII">ASCII</a><a id="ASCII-1"></a><a class="docs-heading-anchor-permalink" href="#ASCII" title="Permalink"></a></h3><p>7位字符表示法，目的是表示所有可打印英语字符，以及一些用于设备间通信(如串行或并行通信通道)的非打印字符。ASCII的设计方式是在特定范围内将大写字母和小写字母分组；类似地，所有数字也都分组在一个范围内。这使得编程和识别字符更加容易，这一点是EBCDIC所欠缺的。与此同时，由于字节已经成为微处理器中的计算单元，这使得最左边的1个自由位可以容纳额外的128个字符。美国国家标准协会(ANSI)考虑了常用的非英语字符，并试图将其中的128个字符作为ANSI字符代码。微软和苹果这样的操作系统供应商也提出了他们自己的字符编码，如Windows-1252编码或Mac Roman编码，等等。它们基本上都支持从0到127的字符代码的一般ASCII规范，但为了方便起见，它们为从128到255的每个字符代码添加了各自的字符集。这导致了在不同操作系统和设备上显示和转换文档时的“编码战争”。业界中使用的术语“高位ASCII”或“扩展ASCII”，本质上是字符码128-255在不同标准之间的变化。</p><h3 id="ISO-8859"><a class="docs-heading-anchor" href="#ISO-8859">ISO-8859</a><a id="ISO-8859-1"></a><a class="docs-heading-anchor-permalink" href="#ISO-8859" title="Permalink"></a></h3><p>ISO-8859是一组编码，包含1-16个代码页，每个代码页代表可以一起表示的一类欧洲语言——有时也称为Latin-1、Latin-2等编码。所有这些代码页都有0-127支持基本ASCII字符，而128-255可能支持一类特殊的欧洲区域语言，如西里尔语、波罗的海语等。这种安排确保了在计算机中轻松地支持欧洲语言。通常，多语言文档或屏幕会使用某种形式的代码页切换命令，并从新代码页中拾取切换的字符编码。当然，它的优点是所有字符串都可以表示为8位值的二进制转储。</p><h3 id="&#39;C&#39;编码"><a class="docs-heading-anchor" href="#&#39;C&#39;编码">&#39;C&#39;编码</a><a id="&#39;C&#39;编码-1"></a><a class="docs-heading-anchor-permalink" href="#&#39;C&#39;编码" title="Permalink"></a></h3><p>‘C’语言是在20世纪70年代末引入的，它使用了非常简单的文本范式。任何二进制8位字节数组都是字符串。数组的最后一个字节必须以字符码(0)或NULL结束。这个概念被称为NULL终止字符串或c字符串，它确保了代码解释保持在字符串操作之外。C语言本身在实现字符串方法时完全忽略了语言内部的编码解释，并期望程序员在他们正在开发的应用程序或系统中处理它。由于缺乏更好的术语，一些计算机系统，如GNU Linux，将其称为C编码。在UNIX等系统中，C编码是系统的默认编码。</p><h3 id="Unicode"><a class="docs-heading-anchor" href="#Unicode">Unicode</a><a id="Unicode-1"></a><a class="docs-heading-anchor-permalink" href="#Unicode" title="Permalink"></a></h3><p>随着计算机的普及，人们越来越清楚地认识到计算不能再局限于一个特定的区域。其次，数据交换还要求数据能够在任何可用的计算系统中显示。第三，因为计算机中可用的存储和内存都变得便宜了，所以表示文本所需的内存可以增加到超过一个字节。不需要再对字符进行单字节限制。一群计算机科学家和来自不同组织和学术机构的语言学家聚集在一个Unicode联盟组织下，提出了通用编码字符集(UCS)。1991年引入的第一组字符集大约有7000个字符，由称为UCS-2的2字节字符表示。很快，随着更多的语言加入到规范中，字符开始增长。这时在一个称为UCS-4的表示中为每个字符分配4个字节。实际上，Unicode规范定义了16个大小为65536(2^16)的代码平面，其中实际使用的值很少。从技术上讲，32位中只有20位真正用于实际目的。然而，许多计算机系统继续在操作系统中实现宽字符，Windows开发了一个本地16位操作系统Windows NT，并停止了旧的Windows 95代码基。在上世纪90年代末和新千年前期，需要使用宏分别编译8位和16位版本的代码。</p><h3 id="Unicode转换"><a class="docs-heading-anchor" href="#Unicode转换">Unicode转换</a><a id="Unicode转换-1"></a><a class="docs-heading-anchor-permalink" href="#Unicode转换" title="Permalink"></a></h3><p>世界上的一部分人正忙于重写操作系统核心以支持宽字符。甚至一些unix派生系统也有4字节实现的宽字符。Ken Thompson提出了重用c编码作为Unicode字符基础的想法。但是，c编码或c字符串不能被用作整个字节的数据被设置为NULL的UCS-2和UCS-4，因为在c语言中，字符串终止字符被定义为0。例如，字符<code>&#39;a&#39;</code>的UCS-2代码是U+0061，其前导字节为0。</p><p>他希望Unicode字符的表示方式是这样的：</p><ol><li><p>ASCII字符在新的编码中仍然有效，这意味着不能对0x00-0x7F范围内的任何字符进行转换。</p></li><li><p>对于任何值为128或更高的字符，必须用多字节字符表示。</p></li><li><p>新的编码必须有一个前导字节，告诉接下来要读取多少个字节。</p></li><li><p>在出现歧义的情况下，应该选择用最少字节数表示的代码。</p></li><li><p>用于前导和后置字节的模式必须是这样的，如果有任何违反，它将很容易识别字符序列是损坏的，以便于在即使没有如CRC等任何冗余检查的情况下更容易传输。</p></li><li><p>这个方案确保除了实际的NULL字符之外，其他字符的字节都不是零。</p></li></ol><p>下面是该方案最终的样子：</p><p><img src="../pictures/utf-8.png" alt="UTF-8"/></p><p>上面的表示称为UTF-8。那21位以外的编码呢？到目前为止，Unicode规范使用的信息不超过21位，但该方案可以容纳多达36位的信息，覆盖整个UCS-4范围。与UTF-8类似，UTF-16考虑将字符代码扩展为每次2字节的字符。此外还有UTF-32转换方案。</p><h3 id="Julia对Unicode的支持"><a class="docs-heading-anchor" href="#Julia对Unicode的支持">Julia对Unicode的支持</a><a id="Julia对Unicode的支持-1"></a><a class="docs-heading-anchor-permalink" href="#Julia对Unicode的支持" title="Permalink"></a></h3><p>Julia语言原生支持Unicode，甚至变量和常量也可以使用Unicode字符。Julia字符串(<code>String</code>类型)在内部被存储为UTF-8编码的Unicode字符流。Julia中的字符(<code>Char</code>)被表示为4字节的UTF-8编码。在Julia中，以UInt8表示的原始字节不是<code>Char</code>。然而，作为一种语言，Julia支持用其他编码表示字符串的结构。还可以使用Julia接口开发自己的字符代码和字符串。你可能需要与原生C/C++应用程序交换信息，这可能需要从Julia代码中将字符串信息交换为<code>Cstring</code>。在C语言中，<code>Cstring</code>是一个以零结束的字符串。</p><h2 id="字体和字形"><a class="docs-heading-anchor" href="#字体和字形">字体和字形</a><a id="字体和字形-1"></a><a class="docs-heading-anchor-permalink" href="#字体和字形" title="Permalink"></a></h2><p>让我们看看a在不同字体中的表示：</p><p><img src="../pictures/glyphsa.png" alt="Glyphs a"/></p><p>字体和字形提供了字符的视觉外观和感觉。作为一种编程语言，Julia没有提供任何控制字体或字形选择的机制。</p><p>现在我们理解了文本计算的各个方面，让我们看看Julia是如何满足这些需求的。</p><h2 id="字符串-3"><a class="docs-heading-anchor" href="#字符串-3">字符串</a><a class="docs-heading-anchor-permalink" href="#字符串-3" title="Permalink"></a></h2><p>在Julia中，<code>String</code>对象可以用以下字面表达式进行初始化。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; str = &quot;This is a string&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;This is a string&quot;</code></pre><p>字符串是不变的，一旦创建，它们就不能被修改。下面是另一种定义字符串的方法，其保留了格式和新行字符，特殊字符不需要额外的引号。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; str = &quot;&quot;&quot;
        This is a preformatted
        &quot;string&quot; &quot;&quot;&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;This is a preformatted\n\&quot;string\&quot; &quot;</code></pre><p>字符串可以包含由其他变量计算得到的信息，并纳入最终计算结果。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = &quot;Jack&quot;;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = &quot;Jill&quot;;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c = &quot;100&quot;;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; str = &quot;$a owes $b $c dollars&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Jack owes Jill 100 dollars&quot;</code></pre><p>字符串中使用的特殊字符，如引号(<code>&quot;</code>)或反斜杠(<code>\</code>)需要使用反斜杠(<code>\</code>)转义。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; str = &quot;This is a \&quot;quoted\\ &#39; string&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;This is a \&quot;quoted\\ &#39; string&quot;</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>字符串是不变的。因此，它们可以驻留在系统内存中，即使在收集垃圾时也不会被覆盖。内存调试器可用于读取随机内存位置。对于像密码这样的敏感数据，你应该考虑使用字节或字符数组结构，并在使用数据后覆盖内存位置。解引用内存对象并强制调用垃圾回收可能不是最安全的选项。</p></div></div><h2 id="字符串方法"><a class="docs-heading-anchor" href="#字符串方法">字符串方法</a><a id="字符串方法-1"></a><a class="docs-heading-anchor-permalink" href="#字符串方法" title="Permalink"></a></h2><p>我们将介绍一些字符串的标准方法。</p><h3 id="比较"><a class="docs-heading-anchor" href="#比较">比较</a><a id="比较-1"></a><a class="docs-heading-anchor-permalink" href="#比较" title="Permalink"></a></h3><p>字符串对象之间可以使用标准比较运算符<code>isequal</code>(<code>==</code>)、<code>isless</code>(<code>&lt;</code>)或大于(<code>&gt;</code>)进行比较。比较通常根据字典顺序。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s1 = &quot;abc&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;abc&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s2 = &quot;def&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;def&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s1 &lt; s2</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s2 &gt; s1</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s1 = &quot;abc&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;abc&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s2 = &quot;abc&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;abc&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s1 == s2</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>等同运算符(<code>===</code>)在不同对象之间进行比较，对于不变的字符串对象，则按位进行比较。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s1 === s2</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h3 id="迭代"><a class="docs-heading-anchor" href="#迭代">迭代</a><a id="迭代-1"></a><a class="docs-heading-anchor-permalink" href="#迭代" title="Permalink"></a></h3><p>就像数组和集一样，字符串也是字符序列的自然集。因此，当对字符串进行迭代时，你能够枚举字符。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = &quot;Julia&quot;;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for c in s
           println(c)
       end</code><code class="nohighlight hljs ansi" style="display:block;">J
u
l
i
a</code></pre><p>与其他集一样，Julia字符串也支持基于1的索引，并在每个位置上显示字符。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s[1], s[2], s[3], s[4], s[5]</code><code class="nohighlight hljs ansi" style="display:block;">(&#39;J&#39;, &#39;u&#39;, &#39;l&#39;, &#39;i&#39;, &#39;a&#39;)</code></pre><p><code>begin</code>和<code>end</code>也可以像在其他类型的集中一样使用。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s[begin], s[begin+2], s[end-1], s[end]</code><code class="nohighlight hljs ansi" style="display:block;">(&#39;J&#39;, &#39;l&#39;, &#39;i&#39;, &#39;a&#39;)</code></pre><p>让我们取一个包含多字节UTF-8字符的字符串。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = &quot;\u2200 x \u2203 y&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;∀ x ∃ y&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; length(s)       # No of characters in the String</code><code class="nohighlight hljs ansi" style="display:block;">7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sizeof(s)       # No fo bytes in the String</code><code class="nohighlight hljs ansi" style="display:block;">11</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s[1]</code><code class="nohighlight hljs ansi" style="display:block;">&#39;∀&#39;: Unicode U+2200 (category Sm: Symbol, math)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s[2]</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: StringIndexError: invalid index [2], valid nearby indices [1]=&gt;&#39;∀&#39;, [4]=&gt;&#39; &#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s[4]</code><code class="nohighlight hljs ansi" style="display:block;">&#39; &#39;: ASCII/Unicode U+0020 (category Zs: Separator, space)</code></pre><p>因此，<code>getindex</code>方法将字节索引作为输入，并返回一个有效的字符。但是，当索引没有映射到有效字符时，就会像<code>s[2]</code>中的情况一样抛出异常。但是，<code>for...in</code>循环可对字符进行迭代。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; for c in s
           println(c)
       end</code><code class="nohighlight hljs ansi" style="display:block;">∀
 
x
 
∃
 
y</code></pre><p>另一种使用索引变量的方式是使用方法<code>nextind</code>。该方法将返回下一个具有有效字符的索引。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; i, l = firstindex(s), lastindex(s);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; while i &lt;= l
           println(s[i])
           i = nextind(s, i)
       end</code><code class="nohighlight hljs ansi" style="display:block;">∀
 
x
 
∃
 
y</code></pre><h3 id="拆分和连接"><a class="docs-heading-anchor" href="#拆分和连接">拆分和连接</a><a id="拆分和连接-1"></a><a class="docs-heading-anchor-permalink" href="#拆分和连接" title="Permalink"></a></h3><p>将字符串拆分为子字符串的最简单方法之一是使用索引，连接则使用运算符(<code>*</code>)。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; str = &quot;This is a String&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;This is a String&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; str[1:4]</code><code class="nohighlight hljs ansi" style="display:block;">&quot;This&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; str[1:4]*str[end-6:end]</code><code class="nohighlight hljs ansi" style="display:block;">&quot;This String&quot;</code></pre><ul><li>由于字符串是不变的，每个子字符串或连接运算都会在它们被连接之前分配中间字符串。可以使用<code>repeat</code>函数或其别名运算符(<code>^</code>)创建文本模式的重复序列。</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; repeat(&quot;A:-&quot;, 5)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;A:-A:-A:-A:-A:-&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; &quot;A:=&quot;^4</code><code class="nohighlight hljs ansi" style="display:block;">&quot;A:=A:=A:=A:=&quot;</code></pre><ul><li><code>join</code>对输入字符串集进行组合。可以选择提供分隔符如逗号(<code>,</code>)和最后连接词如<code>and</code>。</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; join([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;])</code><code class="nohighlight hljs ansi" style="display:block;">&quot;12345&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; join([&quot;Jack&quot;, &quot;Jill&quot;, &quot;Cathy&quot;, &quot;Trevor&quot;], &quot;, &quot;, &quot; and &quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Jack, Jill, Cathy and Trevor&quot;</code></pre><ul><li><code>chomp</code>移除字符串中的最后一个行结束符。</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; str = &quot;This is a\nString\n&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;This is a\nString\n&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; chomp(str)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;This is a\nString&quot;</code></pre><ul><li><code>chop</code>从头部和尾部删除字符。默认情况下，不从头部删除字符，只从尾部删除一个字符。但是，关键字<code>head</code>和<code>tail</code>可以用来分别指定从头部和尾部删掉打字符数。</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; chop(&quot;October&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Octobe&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; chop(&quot;October&quot;, head=2, tail=3)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;to&quot;</code></pre><ul><li><code>split</code>方法根据空格拆分字符串对象并返回一个子字符串对象数组。</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = &quot;\u2200 x \u2203 y&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;∀ x ∃ y&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ss = split(s)</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{SubString{String}}:
 &quot;∀&quot;
 &quot;x&quot;
 &quot;∃&quot;
 &quot;y&quot;</code></pre><ul><li>字符串对象是不变的，任何提取字符串一部分的表达式都将分配一个新的字符串。子字符串是字符串对象的视图。在前面的示例中，数组中所有拆分的子字符串对象都指向同一个字符串对象。子字符串对象扩展了AbstractString接口，因此在需要时可用于转换为字符串对象。<code>split</code>方法也支持分隔符。</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = &quot;\u2200,x,\u2203,y&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;∀,x,∃,y&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ss = split(s, &#39;,&#39;, limit=2)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{SubString{String}}:
 &quot;∀&quot;
 &quot;x,∃,y&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = &quot;\u2200,x,\u2203,y&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;∀,x,∃,y&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ss = rsplit(s, &#39;,&#39;, limit=2)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{SubString{String}}:
 &quot;∀,x,∃&quot;
 &quot;y&quot;</code></pre><p><code>split</code>示例使用逗号(，)作为分隔符，并将分割部分的数量限制为2。与<code>split</code>从左边拆分字符串类似，<code>rsplit</code>从右边拆分字符串。</p><ul><li><code>lpad</code>和<code>rpad</code>为字符串添加前缀或后缀，使其达到指定的长度。</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; lpad(&quot;string&quot;, 10, &quot;p&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;ppppstring&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rpad(&quot;string&quot;, 10, &quot;s&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;stringssss&quot;</code></pre><ul><li><code>strip</code>函数删除字符串两边的空格字符。该函数还可以有选择地接受一个要从两端删除的字符数组。也可以使用计算值为<code>true</code>在两端进行删除。<code>lstrip</code>和<code>rstrip</code>是两个类似于<code>strip</code>的函数，但只分别作用于字符串的左端和右端。</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; strip(&quot;     string 123    &quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;string 123&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; strip(&quot; {a}    sting 123  &quot;,[&#39;{&#39;, &#39;a&#39;, &#39;}&#39;, &#39; &#39;])</code><code class="nohighlight hljs ansi" style="display:block;">&quot;sting 123&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; strip(&quot;    string 123 aaa&quot;) do x
           return x == &#39; &#39; || x == &#39;a&#39;
       end</code><code class="nohighlight hljs ansi" style="display:block;">&quot;string 123&quot;</code></pre><h3 id="大小写转换"><a class="docs-heading-anchor" href="#大小写转换">大小写转换</a><a id="大小写转换-1"></a><a class="docs-heading-anchor-permalink" href="#大小写转换" title="Permalink"></a></h3><p>一些函数都输出结果如字面意义所示：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; uppercase(&quot;Julia&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;JULIA&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; lowercase(&quot;JULiA&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;julia&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; titlecase(&quot;hands on programming in julia&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Hands On Programming In Julia&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; uppercasefirst(&quot;julia&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Julia&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; lowercasefirst(&quot;JuLia&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;juLia&quot;</code></pre><h3 id="模式匹配"><a class="docs-heading-anchor" href="#模式匹配">模式匹配</a><a id="模式匹配-1"></a><a class="docs-heading-anchor-permalink" href="#模式匹配" title="Permalink"></a></h3><p>模式匹配函数可以分为不同的类别。下面给出了其中的一些：</p><ul><li><code>startswith</code>，<code>endswith</code>和<code>contains</code>分别搜索字符串的开始部分，结束部分和字符串中的任何位置，返回它们是否在字符串中出现。<code>occurrence (needle, haystack)</code>是<code>contains(haystack, needle)</code>的另一种表示形式。</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; str = &quot;Introduction to Julia&quot;;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; startswith(str, &quot;Intro&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; endswith(str, &quot;Julia&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; contains(str, &quot;to&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; occursin(&quot;to&quot;, str)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p><code>findfirst</code>和<code>findnext</code>沿着字符串对象搜索模式序列。<code>findlast</code>返回模式最后出现的位置。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; r = findfirst(&quot;o&quot;, &quot;Introduction to Julia&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; while r !== nothing
           println(r)
           r = findnext(&quot;o&quot;, &quot;Introduction to Julia&quot;, r.stop+1)
       end</code><code class="nohighlight hljs ansi" style="display:block;">5:5
11:11
15:15</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; findlast(&quot;o&quot;, &quot;Introduction to Julia&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">15:15</code></pre><p><code>replace</code>将搜索的输入模式更改为选取的另一文本。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; replace(&quot;Introduction to Julia&quot;, &quot;o&quot;=&gt;&quot;a&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Intraductian ta Julia&quot;</code></pre><h3 id="正则表达式"><a class="docs-heading-anchor" href="#正则表达式">正则表达式</a><a id="正则表达式-1"></a><a class="docs-heading-anchor-permalink" href="#正则表达式" title="Permalink"></a></h3><p>正则表达式是一种模式匹配语言构造，它使计算机程序员能够定义与文本字符串匹配的复杂模式。这些模式主要用于编译器设计和标记器等。UNIX中使用正则表达式(regex)进行模式匹配的几个常用应用程序是<code>lex</code>、<code>grep</code>和<code>egrep</code>。与<code>grep</code>支持的标准语法相比，PERL、Python和R等编程语言提供了扩展的正则表达式语法支持。PERL兼容正则表达式(PCRE)库集成到了Julia中。因此，Julia对正则表达式的支持与任何其他语言一样强大。虽然我们在这里展示了一些正则表达式的示例，但这一节并没有专门介绍正则表达式的所有细节。读者需要阅读更专业的文档来深入了解正则表达式。</p><p>可以看到，下面的示例中创建了一个<code>Regex</code>对象。将它与字符串匹配。匹配的对象存储在<code>RegexMatch</code>对象中。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; rx = Regex(&quot;a.a&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">r&quot;a.a&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = match(rx, &quot;abracadabra&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">RegexMatch(&quot;aca&quot;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m.match</code><code class="nohighlight hljs ansi" style="display:block;">&quot;aca&quot;</code></pre><p>偏移匹配可以匹配到<code>ada</code>而不是<code>aca</code>。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = match(rx, &quot;abracadabra&quot;, 5)</code><code class="nohighlight hljs ansi" style="display:block;">RegexMatch(&quot;ada&quot;)</code></pre><p>在下面的例子中，一个<code>@r_str</code>宏(将在下一章详细讨论)被用来初始化<code>Regex</code>对象。<code>rx</code>对象定义了一个捕获组，匹配的正则表达式可以将捕获保存在<code>capture</code>属性中。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; rx = r&quot;a(.)a&quot;;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = match(rx, &quot;abracadabra&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m.captures</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Union{Nothing, SubString{String}}}:
 &quot;c&quot;</code></pre><p>现在使用命名捕获显示相同的示例。可以使用捕获的组名对<code>RegexMatch</code>进行索引来收集捕获的数据。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; rx = Regex(&quot;a(?&lt;key&gt;.)a&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = match(rx, &quot;abracadabra&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m.captures</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Union{Nothing, SubString{String}}}:
 &quot;c&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m[&quot;key&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">&quot;c&quot;</code></pre><p>你还可以将模式多次匹配到字符串中。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; rx = r&quot;a.a&quot;</code><code class="nohighlight hljs ansi" style="display:block;">r&quot;a.a&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = eachmatch(rx, &quot;abracadabra&quot;, overlap=true)</code><code class="nohighlight hljs ansi" style="display:block;">Base.RegexMatchIterator(r&quot;a.a&quot;, &quot;abracadabra&quot;, true)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(m)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{RegexMatch}:
 RegexMatch(&quot;aca&quot;)
 RegexMatch(&quot;ada&quot;)</code></pre><p>当允许重叠字符串时，<code>aca</code>和<code>ada</code>都是匹配的。当<code>overlap</code>参数设置为<code>false</code>时，只匹配<code>aca</code>。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = eachmatch(rx, &quot;abracadabra&quot;, overlap=false)</code><code class="nohighlight hljs ansi" style="display:block;">Base.RegexMatchIterator(r&quot;a.a&quot;, &quot;abracadabra&quot;, false)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(m)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{RegexMatch}:
    RegexMatch(&quot;aca&quot;)</code></pre><p>不仅仅是<code>match</code>或<code>eachmatch</code>, 正则表达式匹配也被作为模式参数用于比如<code>findfirst</code>，<code>findnext</code>，<code>occursin</code>，<code>replace</code>，<code>split</code>，<code>rsplit</code>，<code>startwith</code>和<code>endswith</code>。</p><h3 id="编码-2"><a class="docs-heading-anchor" href="#编码-2">编码</a><a class="docs-heading-anchor-permalink" href="#编码-2" title="Permalink"></a></h3><p>Julia中的字符串对象本质上是Unicode表示。它们是否遵循特定的转换？可以转换为其他东西吗？有些问题对于读者来说是很自然的。如果你还记得迭代中的讨论，<code>nextind</code>方法将索引对齐到下一个UTF-8字符的位置上。这确保字符串对象本质上是UTF-8表示。但是，可以通过函数<code>transcode</code>提取出UTF-8、16和32数组表示。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = &quot;\u2200 x \u2203 y&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;∀ x ∃ y&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transcode(UInt8, s)</code><code class="nohighlight hljs ansi" style="display:block;">11-element Base.CodeUnits{UInt8, String}:
 0xe2
 0x88
 0x80
 0x20
 0x78
 0x20
 0xe2
 0x88
 0x83
 0x20
 0x79</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transcode(UInt16, s)</code><code class="nohighlight hljs ansi" style="display:block;">7-element Vector{UInt16}:
 0x2200
 0x0020
 0x0078
 0x0020
 0x2203
 0x0020
 0x0079</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transcode(UInt32, s)</code><code class="nohighlight hljs ansi" style="display:block;">7-element Vector{UInt32}:
 0x00002200
 0x00000020
 0x00000078
 0x00000020
 0x00002203
 0x00000020
 0x00000079</code></pre><p><code>transcode</code>还可以将UTF字节数组转换为字符串对象。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; transcode(String, transcode(UInt16, s))</code><code class="nohighlight hljs ansi" style="display:block;">&quot;∀ x ∃ y&quot;</code></pre><h3 id="有用的函数"><a class="docs-heading-anchor" href="#有用的函数">有用的函数</a><a id="有用的函数-1"></a><a class="docs-heading-anchor-permalink" href="#有用的函数" title="Permalink"></a></h3><p>有些函数相当直观。然而，不仅仅局限于ASCII字符集或英语字符，所有这些方法都适用于存在相关函数的所有语言的Unicode字符。它们利用Unicode表中的字符类别定义来确定这些属性。例如，所有属于<code>Lu</code>类别的字符对于<code>isuppercase</code>方法都返回真。类似地，当<code>isspace</code>方法查询字符时，类别<code>Zs</code>将被提取。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; isascii(&quot;∀ x ∃ y&quot;), isascii(&quot;abcd ef&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(false, true)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; iscntrl(&#39;a&#39;), iscntrl(&#39;\x1&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">(false, true)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isdigit(&#39;a&#39;), isdigit(&#39;9&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">(false, true)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isxdigit(&#39;a&#39;), isxdigit(&#39;x&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">(true, false)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isletter(&#39;1&#39;), isletter(&#39;a&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">(false, true)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isnumeric(&#39;1&#39;), isnumeric(&#39;௰&#39;) #No. 10 in Tamil (Indian) Language</code><code class="nohighlight hljs ansi" style="display:block;">(true, true)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isuppercase(&#39;A&#39;), islowercase(&#39;a&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">(true, true)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isspace(&#39;\n&#39;), isspace(&#39;\r&#39;), isspace(&#39; &#39;), isspace(&#39;\x20&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">(true, true, true, true)</code></pre><p>在处理字符串和编码时，我们发现一些函数针对单个字符的属性。因此，将字符串转换为字符数组是很重要的。</p><h2 id="字符数组"><a class="docs-heading-anchor" href="#字符数组">字符数组</a><a id="字符数组-1"></a><a class="docs-heading-anchor-permalink" href="#字符数组" title="Permalink"></a></h2><p>如前所述，字符串对象是字符的集。但是，它们不能被修改。你不能像对数组或其他容器类型那样灵活地对它们进行操作。然而，有很多函数可以用来转换字符串对象和创建另外的字符串对象。然而,如果需要，你可以使用<code>collect</code>方法将字符串转换为字符数组。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(&quot;∀ x ∃ y&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">7-element Vector{Char}:
 &#39;∀&#39;: Unicode U+2200 (category Sm: Symbol, math)
 &#39; &#39;: ASCII/Unicode U+0020 (category Zs: Separator, space)
 &#39;x&#39;: ASCII/Unicode U+0078 (category Ll: Letter, lowercase)
 &#39; &#39;: ASCII/Unicode U+0020 (category Zs: Separator, space)
 &#39;∃&#39;: Unicode U+2203 (category Sm: Symbol, math)
 &#39; &#39;: ASCII/Unicode U+0020 (category Zs: Separator, space)
 &#39;y&#39;: ASCII/Unicode U+0079 (category Ll: Letter, lowercase)</code></pre><p>如前面所示，你还可以使用<code>transcode</code>方法来获得字符串对象的UTF-8，16，32转换向量。一旦有了字符数组，就可以在数组操作中以任何需要的方式使用它。</p><h2 id="用户定义字符串"><a class="docs-heading-anchor" href="#用户定义字符串">用户定义字符串</a><a id="用户定义字符串-1"></a><a class="docs-heading-anchor-permalink" href="#用户定义字符串" title="Permalink"></a></h2><p>罗马不是一天建成的，Julia字符串API也不是。字符串是包装在集中的UTF-8表示，该集将字符对象作为<code>eltype</code>。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; eltype(&quot;abcd&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">Char</code></pre><p>该体系结构被进一步扩展，以定义一个抽象的<code>AbstractString</code>类型，该类型将<code>AbstractChar</code>视为一个元素类型。在1.0之前的版本中，Julia有很多这样的实现，比如<code>ASCIIString</code>、<code>UTF8String</code>等等，它实际上是为一些常用的编码方案提供了基础。许多经典的字符串类型在功能上合并到<code>String</code>类型中，一些被移动到一个名为<code>LegacyString.jl</code>的可选包中。虽然使用那个包没有什么显著的好处，但是对于有兴趣尝试和实现自己的字符串类型的人来说，它们是一个很好的参考来源。如果你对实现自己的字符串类型感兴趣，请确保实现了<code>AbstractString</code>和<code>AbstractChar</code>接口。</p><h3 id="AbstractChar"><a class="docs-heading-anchor" href="#AbstractChar">AbstractChar</a><a id="AbstractChar-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractChar" title="Permalink"></a></h3><p>这个接口本质上要求任何派生字符都应该有一个Unicode表示值。同样，给定一个有效的Unicode值，必须能够创建一个字符。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct MyChar &lt;: AbstractChar
           a::UInt32
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; MyChar(n::Number)=MyChar(UInt32(n))</code><code class="nohighlight hljs ansi" style="display:block;">Main.MyChar</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.codepoint(c::MyChar) = c.a</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; MyChar(32)</code><code class="nohighlight hljs ansi" style="display:block;">&#39; &#39;: ASCII/Unicode U+0020 (category Zs: Separator, space)</code></pre><p>如果代<code>codepoint</code>输入值不在编码范围内，构造函数必须抛出错误。</p><h3 id="AbstractString"><a class="docs-heading-anchor" href="#AbstractString">AbstractString</a><a id="AbstractString-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractString" title="Permalink"></a></h3><p><code>AbstractString</code>接口要复杂得多，并且对字符串对象的内部组成也做了一些假设。例如，这些接口定义了在字符串中定义一个字符所需的最小字节数的假设。如果你使用<code>LegacyString</code>，你会意识到<code>ASCIIString</code>使用一个<code>unit8</code>的<code>codeunit</code>，而<code>UTF16String</code>使用一个<code>unit16</code>的<code>codeunit</code>。但两者在代码单元中的内部数据长度相同。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Pkg</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Pkg.add(&quot;LegacyStrings&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">   Resolving package versions...
  No Changes to `~/Example/docs/Project.toml`
  No Changes to `~/Example/docs/Manifest.toml`</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using LegacyStrings</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = ASCIIString(&quot;abcd&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; codeunit(s)</code><code class="nohighlight hljs ansi" style="display:block;">UInt8</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ncodeunits(s)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s16 = UTF16String(transcode(UInt16, &quot;abcd\0&quot;)); # NULL termination</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; codeunit(s16)</code><code class="nohighlight hljs ansi" style="display:block;">UInt16</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ncodeunits(s16)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eltype(s),eltype(s16)</code><code class="nohighlight hljs ansi" style="display:block;">(Char, Char)</code></pre><p>尽管前面例子中的<code>ASCIIString</code>和<code>UTF16String</code>对存储的内部数据有完全不同的内部表示，但它们使用<code>Char</code>作为迭代的<code>eltype</code>。没有为这两种数据类型定义另外的字符类型。</p><p>除了上述方法外，<code>AbstractString</code>的派生类型还需要实现所有迭代和索引方法，如<code>iterate</code>、<code>getindex</code>、<code>nextind</code>、<code>prevind</code>、<code>lastindex</code>、<code>firstindex</code>，以及一些与集相关的方法，如<code>length</code>。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ch07array/">« 数组</a><a class="docs-footer-nextpage" href="../ch09metaprograme/">元编程 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 31 December 2021 10:09">Friday 31 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
