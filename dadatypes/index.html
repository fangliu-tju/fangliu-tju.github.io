<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>数据类型 · Example</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Example</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">安装与配置</a></li><li class="is-active"><a class="tocitem" href>数据类型</a><ul class="internal"><li><a class="tocitem" href="#数据种类"><span>数据种类</span></a></li><li><a class="tocitem" href="#内置数据类型"><span>内置数据类型</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>数据类型</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>数据类型</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="数据类型"><a class="docs-heading-anchor" href="#数据类型">数据类型</a><a id="数据类型-1"></a><a class="docs-heading-anchor-permalink" href="#数据类型" title="Permalink"></a></h1><p>类型是Julia语言的核心。尽管在语法上不需要显式地定义数据的类型，但Julia在编译过程中会对类型进行推断。Julia语言有预定义的类型。用户也可以定义自己的类型。有些类型可以通过参数进行修改。</p><h2 id="数据种类"><a class="docs-heading-anchor" href="#数据种类">数据种类</a><a id="数据种类-1"></a><a class="docs-heading-anchor-permalink" href="#数据种类" title="Permalink"></a></h2><p>通常，动态类型编程语言没有开发良好的类型系统，如Python中的数据类型就是非强制的。Julia类型系统是动态的，但总是在对象实例化时进行推断。这样，Julia在执行代码段或对代码进行即时(JIT)编译之前，数据类型就是已知的了。简而言之，Julia原生支持在使用前定义或推断任意对象或字面量的数据类型。在深入介绍数据类型之前，让我们先了解一下Julia对数据的分类：变量、常量和字面量的知识。</p><h3 id="变量"><a class="docs-heading-anchor" href="#变量">变量</a><a id="变量-1"></a><a class="docs-heading-anchor-permalink" href="#变量" title="Permalink"></a></h3><p>Julia中的变量将名称与值关联起来。名称通常以字母开头的字母数字表示。下面给出了一些在Julia中变量名的例子。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; abc = 1</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; πi = 30</code><code class="nohighlight hljs ansi" style="display:block;">30</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a1 = 1</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 1abc = 2</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: syntax: &quot;1&quot; is not a valid function argument name around REPL[4]:1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sin = 1.0</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cos(0.0)</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cos = 0.0</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: cannot assign a value to variable Base.cos from module Main</code></pre><p>从上面的结果可以看出，变量名可以包含Unicode字符；可以包含数字，但不能以数字开头；以函数名做为变量名时要特别慎重。变量名的另外一个限制是不能使用特殊字符和Julia的关键字，如下面的例程所示。</p><pre><code class="language-julia-repl hljs">julia&gt; a@ = 1
ERROR: syntax: extra token &quot;@&quot; after end of expression

julia&gt; struct = 10
ERROR: syntax: unexpected &quot;=&quot;</code></pre><p>Julia的关键字很少。</p><pre><code class="language-julia hljs">baremodule  begin   break       catch   const   continue
do          else    elseif      end     export  false 
finally     for     function    global  if      import 
let         local   macro       module  quote   return
struct      true    try         using   while </code></pre><p>Julia还具有两字关键字(<code>mutable struct</code>、<code>abstract type</code>等)和中缀操作符(<code>in</code>、<code>isa</code>等)关键字。</p><h4 id="定义与初始化"><a class="docs-heading-anchor" href="#定义与初始化">定义与初始化</a><a id="定义与初始化-1"></a><a class="docs-heading-anchor-permalink" href="#定义与初始化" title="Permalink"></a></h4><p>大部分静态语言，如<code>C</code>，变量的定义和初始化是独立的。定义声明变量的类型，其底层操作是向内存申请一块相应类型的地址空间并命名（变量名）。初始化则在地址空间中存入规定类型的具体值。变量和值的关系是：变量是主体，值是变量的附属。如下面<code>C</code>代码片段所示。</p><pre><code class="language-c hljs">int i;  /* 将i定义为整数类型 */
i = 10; /* 初始化i */
int j = 20; /* 在一条语句中定义并初始化变量 */</code></pre><p>Julia则将变量和值的关系翻转过来：值是主体，变量是值的附属。大多数Julia变量是在对类型进行初始化时定义的。事实上，类型是作为初始化过程的一部分赋给变量的。也可以显式地声明变量将要绑定的值的类型，Julia会尝试将值转换成相应的类型，不成功则会报错。对于REPL中的全局变量，不允许声明变量的类型。例程如下所示。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 1</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">Int64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 1.0</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">Float64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; let a::Int = 1.0
           println(typeof(a))
       end</code><code class="nohighlight hljs ansi" style="display:block;">Int64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; let a::Int = 1.1
           println(typeof(a))
       end</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: InexactError: Int64(1.1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a::Int = 1</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: syntax: type declarations on global variables are not yet supported</code></pre><p>从上面的介绍可以判断，Julia中的一般变量是没有固定地址的，事实也是如此。Julia甚至没有为我们开放变量地址的查询功能（后面会介绍可查询地址的变量类型），这一切都交给了底层程序自动处理。在Julia中，没有初始化的变量是无效的（后面会介绍例外的情况）:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; i</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: i not defined</code></pre><h3 id="常量"><a class="docs-heading-anchor" href="#常量">常量</a><a id="常量-1"></a><a class="docs-heading-anchor-permalink" href="#常量" title="Permalink"></a></h3><p>常量可以看作是不能修改的变量。然而，Julia并没有严格地遵循常量不变的条件。在类型不变的情况下修改常量的值，它会发出警告，但改变常量类型的情况是不允许的。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; const ICONSTANT = 1</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ICONSTANT = 5</code><code class="nohighlight hljs ansi" style="display:block;">WARNING: redefinition of constant ICONSTANT. This may fail, cause incorrect answers, or produce other errors.
5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ICONSTANT = 5.0</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: invalid redefinition of constant ICONSTANT</code></pre><p>在使用中，尽管常量的值是可以修改的，但我们应该严格遵守常量不变的特性，以避免程序在执行中产生不可预见的错误。</p><h3 id="字面量"><a class="docs-heading-anchor" href="#字面量">字面量</a><a id="字面量-1"></a><a class="docs-heading-anchor-permalink" href="#字面量" title="Permalink"></a></h3><p>字面量是表示一个值的常表达式。因为它们出现在变量定义的右边，因此常被称为右首值。它们也是一个值的本质表示形式。下面是一些不同类型的字面表达式。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 2           # Integer</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 2.0         # Double precision Float (Float64)</code><code class="nohighlight hljs ansi" style="display:block;">2.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 2f0         # Single precision Float (Float32)</code><code class="nohighlight hljs ansi" style="display:block;">2.0f0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; &#39;a&#39;         # Char</code><code class="nohighlight hljs ansi" style="display:block;">&#39;a&#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; &quot;string&quot;    # String</code><code class="nohighlight hljs ansi" style="display:block;">&quot;string&quot;</code></pre><p>当我们深入研究类型时，我们将根据特定类型的上下文含义更详细地回顾字面量。通常，变量初始化为<code>var = &lt;literals&gt;</code>。</p><h2 id="内置数据类型"><a class="docs-heading-anchor" href="#内置数据类型">内置数据类型</a><a id="内置数据类型-1"></a><a class="docs-heading-anchor-permalink" href="#内置数据类型" title="Permalink"></a></h2><p>Julia语言自身定义了许多内置类型。而更多的类型则是在Julia库中定义的。Julia语言提供了扩展这些功能的灵活性。此外，定义的类型不作为保留的关键字存在。下面是该语言中一些常用的类型。</p><h3 id="Nothing"><a class="docs-heading-anchor" href="#Nothing">Nothing</a><a id="Nothing-1"></a><a class="docs-heading-anchor-permalink" href="#Nothing" title="Permalink"></a></h3><p><code>Nothing</code>是值<code>nothing</code>的类型。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(nothing)</code><code class="nohighlight hljs ansi" style="display:block;">Nothing</code></pre><p><code>typeof</code>函数可用于查询值所属类型的信息。当代码中确实需要未初始化的变量条件时，可以使用<code>nothing</code>来初始化这个变量。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = nothing</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; i = 6</code><code class="nohighlight hljs ansi" style="display:block;">6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; if i &lt; 5
           a = 5
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">Nothing</code></pre><p>这里，如果<code>i</code>小于5 <code>a</code>就被赋值为5。否则，它仍保持未初始化。<code>Nothing</code>和<code>nothing</code>在函数参数和返回类型中也被广泛使用。</p><h3 id="数值类型"><a class="docs-heading-anchor" href="#数值类型">数值类型</a><a id="数值类型-1"></a><a class="docs-heading-anchor-permalink" href="#数值类型" title="Permalink"></a></h3><p>下面是在Julia中定义为数值数据类型的一些数据类型。</p><h4 id="Bool"><a class="docs-heading-anchor" href="#Bool">Bool</a><a id="Bool-1"></a><a class="docs-heading-anchor-permalink" href="#Bool" title="Permalink"></a></h4><p><code>true</code>和<code>false</code>在Julia中属于<code>Bool</code>类型。数值上，<code>true</code>的值为1,<code>false</code>的值为0。</p><h4 id="整数"><a class="docs-heading-anchor" href="#整数">整数</a><a id="整数-1"></a><a class="docs-heading-anchor-permalink" href="#整数" title="Permalink"></a></h4><p>整型数字类型分为具有不同字节大小的无符号和有符号类型。有符号数字类型有:<code>Int8</code>、<code>Int16</code>、<code>Int32</code>、<code>Int64</code>和<code>Int128</code>。对应的无符号数字类型分别为:<code>UInt8</code>、<code>UInt16</code>、<code>UInt32</code>、<code>UInt64</code>和<code>UInt128</code>。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(1)</code><code class="nohighlight hljs ansi" style="display:block;">Int64</code></pre><p>数字字面量的默认数值类型是<code>Int</code>，根据机器的体系结构，它映射到<code>Int32</code>或<code>Int64</code>。</p><p>对于无符号数字，字面量由<code>0&lt;表示说明符&gt;&lt;数字&gt;</code>指定。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(0b1), typeof(0o7), typeof(0xff)</code><code class="nohighlight hljs ansi" style="display:block;">(UInt8, UInt8, UInt8)</code></pre><p>这些由二进制、八进制和十六进制表示的数字都被映射到<code>UInt8</code>。数字的尺寸由满足字面量所需的最小字节大小决定。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(0xf), typeof(0xfff),typeof(0xfffff), typeof(0xfffffffff), typeof(0xfffffffffffffffff)</code><code class="nohighlight hljs ansi" style="display:block;">(UInt8, UInt16, UInt32, UInt64, UInt128)</code></pre><p>无符号整数的前面也是可以加<code>+/-</code>号的，但加<code>-</code>号的含义不是得到一个负的整数，而是得到该整数的二进制补码（后续将介绍相关知识）。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; -0x2</code><code class="nohighlight hljs ansi" style="display:block;">0xfe</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Int(ans)</code><code class="nohighlight hljs ansi" style="display:block;">254</code></pre><h4 id="浮点数"><a class="docs-heading-anchor" href="#浮点数">浮点数</a><a id="浮点数-1"></a><a class="docs-heading-anchor-permalink" href="#浮点数" title="Permalink"></a></h4><p>根据IEEE 754规范，Julia使用<code>Float16</code>、<code>Float32</code>和<code>Float64</code>来表示半精度、单精度和双精度浮点数。使用字面量<code>f</code>和<code>e</code>作为<code>Float32</code>和<code>Float64</code>的指数分隔符。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(1.0), typeof(1e0),typeof(1.e4)</code><code class="nohighlight hljs ansi" style="display:block;">(Float64, Float64, Float64)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(1.0f0), typeof(1f-6), typeof(1.f4)</code><code class="nohighlight hljs ansi" style="display:block;">(Float32, Float32, Float32)</code></pre><h4 id="抽象类型"><a class="docs-heading-anchor" href="#抽象类型">抽象类型</a><a id="抽象类型-1"></a><a class="docs-heading-anchor-permalink" href="#抽象类型" title="Permalink"></a></h4><p>Julia中的类型可以从抽象类型派生出来。大多数面向对象语言将这种关系视为在类层次结构中描述对象的一种方法。在Julia中，抽象类型仅仅是像接口一样的概念性表示，内部没有数据元素。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; abstract type MyAbstractType end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct MyConcreteType &lt;: MyAbstractType
           member
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = MyConcreteType(5)</code><code class="nohighlight hljs ansi" style="display:block;">Main.MyConcreteType(5)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a isa MyAbstractType</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« 安装与配置</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Sunday 14 November 2021 10:24">Sunday 14 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
