<!DOCTYPE html>
<html lang="cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>数据类型 · Julia程序设计基础</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Julia程序设计基础 logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Julia程序设计基础</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">安装与配置</a></li><li class="is-active"><a class="tocitem" href>数据类型</a><ul class="internal"><li><a class="tocitem" href="#数据种类"><span>数据种类</span></a></li><li><a class="tocitem" href="#内置数据类型"><span>内置数据类型</span></a></li><li><a class="tocitem" href="#用户定义类型"><span>用户定义类型</span></a></li><li><a class="tocitem" href="#Any"><span>Any</span></a></li><li><a class="tocitem" href="#参数数据类型"><span>参数数据类型</span></a></li><li><a class="tocitem" href="#类型上的运算"><span>类型上的运算</span></a></li><li><a class="tocitem" href="#打印数据类型"><span>打印数据类型</span></a></li><li><a class="tocitem" href="#数字在计算机中的存储与运算"><span>数字在计算机中的存储与运算</span></a></li></ul></li><li><a class="tocitem" href="../ch03controlflows/">控制流</a></li><li><a class="tocitem" href="../ch04function/">函数和方法</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>数据类型</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>数据类型</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="数据类型"><a class="docs-heading-anchor" href="#数据类型">数据类型</a><a id="数据类型-1"></a><a class="docs-heading-anchor-permalink" href="#数据类型" title="Permalink"></a></h1><p>类型是Julia语言的核心。尽管在语法上不需要显式地定义数据的类型，但Julia在编译过程中会对类型进行推断。Julia语言有预定义的类型。用户也可以定义自己的类型。有些类型可以通过参数进行修改。</p><h2 id="数据种类"><a class="docs-heading-anchor" href="#数据种类">数据种类</a><a id="数据种类-1"></a><a class="docs-heading-anchor-permalink" href="#数据种类" title="Permalink"></a></h2><p>通常，动态类型编程语言没有开发良好的类型系统，如Python中的数据类型就是非强制的。Julia类型系统是动态的，但总是在对象实例化时进行推断。这样，Julia在执行代码段或对代码进行即时(JIT)编译之前，数据类型就是已知的了。简而言之，Julia原生支持在使用前定义或推断任意对象或字面量的数据类型。在深入介绍数据类型之前，让我们先了解一下Julia对数据的分类：变量、常量和字面量的知识。</p><h3 id="变量"><a class="docs-heading-anchor" href="#变量">变量</a><a id="变量-1"></a><a class="docs-heading-anchor-permalink" href="#变量" title="Permalink"></a></h3><p>Julia中的变量将名称与值关联起来。名称通常以字母开头的字母数字表示。下面给出了一些在Julia中变量名的例子。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; abc = 1</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; πi = 30</code><code class="nohighlight hljs ansi" style="display:block;">30</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a1 = 1</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 1abc = 2</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: syntax: &quot;1&quot; is not a valid function argument name around REPL[4]:1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sin = 1.0</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cos(0.0)</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cos = 0.0</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: cannot assign a value to variable Base.cos from module Main</code></pre><p>从上面的结果可以看出，变量名可以包含Unicode字符；可以包含数字，但不能以数字开头；以函数名做为变量名时要特别慎重。变量名的另外一个限制是不能使用特殊字符和Julia的关键字，如下面的例程所示。</p><pre><code class="language-julia-repl hljs">julia&gt; a@ = 1
ERROR: syntax: extra token &quot;@&quot; after end of expression

julia&gt; struct = 10
ERROR: syntax: unexpected &quot;=&quot;</code></pre><p>Julia的关键字很少。</p><pre><code class="language-julia hljs">baremodule  begin   break       catch   const   continue
do          else    elseif      end     export  false 
finally     for     function    global  if      import 
let         local   macro       module  quote   return
struct      true    try         using   while </code></pre><p>Julia还具有两字关键字(<code>mutable struct</code>、<code>abstract type</code>等)和中缀操作符(<code>in</code>、<code>isa</code>等)关键字。</p><h4 id="定义与初始化"><a class="docs-heading-anchor" href="#定义与初始化">定义与初始化</a><a id="定义与初始化-1"></a><a class="docs-heading-anchor-permalink" href="#定义与初始化" title="Permalink"></a></h4><p>大部分静态语言，如<code>C</code>，变量的定义和初始化是独立的。定义声明变量的类型，其底层操作是向内存申请一块相应类型的地址空间并命名（变量名）。初始化则在地址空间中存入规定类型的具体值。变量和值的关系是：变量是主体，值是变量的附属。如下面<code>C</code>代码片段所示。</p><pre><code class="language-c hljs">int i;  /* 将i定义为整数类型 */
i = 10; /* 初始化i */
int j = 20; /* 在一条语句中定义并初始化变量 */</code></pre><p>Julia则将变量和值的关系翻转过来：值是主体，变量是值的附属。大多数Julia变量是在对类型进行初始化时定义的。事实上，类型是作为初始化过程的一部分赋给变量的。也可以显式地声明变量将要绑定的值的类型，Julia会尝试将值转换成相应的类型，不成功则会报错。对于REPL中的全局变量，不允许声明变量的类型。例程如下所示。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 1</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">Int64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 1.0</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">Float64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; let a::Int = 1.0
           println(typeof(a))
       end</code><code class="nohighlight hljs ansi" style="display:block;">Int64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; let a::Int = 1.1
           println(typeof(a))
       end</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: InexactError: Int64(1.1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a::Int = 1</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: syntax: type declarations on global variables are not yet supported</code></pre><p>从上面的介绍可以判断，Julia中的一般变量是没有固定地址的，事实也是如此。Julia甚至没有为我们开放变量地址的查询功能（后面会介绍可查询地址的变量类型），这一切都交给了底层程序自动处理。在Julia中，没有初始化的变量是无效的（后面会介绍例外的情况）:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; i</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: i not defined</code></pre><h3 id="常量"><a class="docs-heading-anchor" href="#常量">常量</a><a id="常量-1"></a><a class="docs-heading-anchor-permalink" href="#常量" title="Permalink"></a></h3><p>常量可以看作是不能修改的变量。然而，Julia并没有严格地遵循常量不变的条件。在类型不变的情况下修改常量的值，它会发出警告，但改变常量类型的情况是不允许的。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; const ICONSTANT = 1</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ICONSTANT = 5</code><code class="nohighlight hljs ansi" style="display:block;">WARNING: redefinition of constant ICONSTANT. This may fail, cause incorrect answers, or produce other errors.
5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ICONSTANT = 5.0</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: invalid redefinition of constant ICONSTANT</code></pre><p>在使用中，尽管常量的值是可以修改的，但我们应该严格遵守常量不变的特性，以避免程序在执行中产生不可预见的错误。</p><h3 id="字面量"><a class="docs-heading-anchor" href="#字面量">字面量</a><a id="字面量-1"></a><a class="docs-heading-anchor-permalink" href="#字面量" title="Permalink"></a></h3><p>字面量是表示一个值的常表达式。因为它们出现在变量定义的右边，因此常被称为右首值。它们也是一个值的本质表示形式。下面是一些不同类型的字面表达式。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 2           # Integer</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 2.0         # Double precision Float (Float64)</code><code class="nohighlight hljs ansi" style="display:block;">2.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 2f0         # Single precision Float (Float32)</code><code class="nohighlight hljs ansi" style="display:block;">2.0f0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; &#39;a&#39;         # Char</code><code class="nohighlight hljs ansi" style="display:block;">&#39;a&#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; &quot;string&quot;    # String</code><code class="nohighlight hljs ansi" style="display:block;">&quot;string&quot;</code></pre><p>当我们深入研究类型时，我们将根据特定类型的上下文含义更详细地回顾字面量。通常，变量初始化为<code>var = &lt;literals&gt;</code>。</p><h2 id="内置数据类型"><a class="docs-heading-anchor" href="#内置数据类型">内置数据类型</a><a id="内置数据类型-1"></a><a class="docs-heading-anchor-permalink" href="#内置数据类型" title="Permalink"></a></h2><p>Julia语言自身定义了许多内置类型。而更多的类型则是在Julia库中定义的。Julia语言提供了扩展这些功能的灵活性。此外，定义的类型不作为保留的关键字存在。下面是该语言中一些常用的类型。</p><h3 id="Nothing"><a class="docs-heading-anchor" href="#Nothing">Nothing</a><a id="Nothing-1"></a><a class="docs-heading-anchor-permalink" href="#Nothing" title="Permalink"></a></h3><p><code>Nothing</code>是值<code>nothing</code>的类型。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(nothing)</code><code class="nohighlight hljs ansi" style="display:block;">Nothing</code></pre><p><code>typeof</code>函数可用于查询值所属类型的信息。当代码中确实需要未初始化的变量条件时，可以使用<code>nothing</code>来初始化这个变量。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = nothing</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; i = 6</code><code class="nohighlight hljs ansi" style="display:block;">6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; if i &lt; 5
           a = 5
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">Nothing</code></pre><p>这里，如果<code>i</code>小于5 <code>a</code>就被赋值为5。否则，它仍保持未初始化。<code>Nothing</code>和<code>nothing</code>在函数参数和返回类型中也被广泛使用。</p><h3 id="数值类型"><a class="docs-heading-anchor" href="#数值类型">数值类型</a><a id="数值类型-1"></a><a class="docs-heading-anchor-permalink" href="#数值类型" title="Permalink"></a></h3><p>下面是在Julia中定义为数值数据类型的一些数据类型。</p><h4 id="Bool"><a class="docs-heading-anchor" href="#Bool">Bool</a><a id="Bool-1"></a><a class="docs-heading-anchor-permalink" href="#Bool" title="Permalink"></a></h4><p><code>true</code>和<code>false</code>在Julia中属于<code>Bool</code>类型。数值上，<code>true</code>的值为1,<code>false</code>的值为0。</p><h4 id="整数"><a class="docs-heading-anchor" href="#整数">整数</a><a id="整数-1"></a><a class="docs-heading-anchor-permalink" href="#整数" title="Permalink"></a></h4><p>整型数字类型分为具有不同字节大小的无符号和有符号类型。有符号数字类型有:<code>Int8</code>、<code>Int16</code>、<code>Int32</code>、<code>Int64</code>和<code>Int128</code>。对应的无符号数字类型分别为:<code>UInt8</code>、<code>UInt16</code>、<code>UInt32</code>、<code>UInt64</code>和<code>UInt128</code>。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(1)</code><code class="nohighlight hljs ansi" style="display:block;">Int64</code></pre><p>数字字面量的默认数值类型是<code>Int</code>，根据机器的体系结构，它映射到<code>Int32</code>或<code>Int64</code>。</p><p>对于无符号数字，字面量由<code>0&lt;表示说明符&gt;&lt;数字&gt;</code>指定。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(0b1), typeof(0o7), typeof(0xff)</code><code class="nohighlight hljs ansi" style="display:block;">(UInt8, UInt8, UInt8)</code></pre><p>这些由二进制、八进制和十六进制表示的数字都被映射到<code>UInt8</code>。数字的尺寸由满足字面量所需的最小字节大小决定。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(0xf), typeof(0xfff),typeof(0xfffff), typeof(0xfffffffff), typeof(0xfffffffffffffffff)</code><code class="nohighlight hljs ansi" style="display:block;">(UInt8, UInt16, UInt32, UInt64, UInt128)</code></pre><p>无符号整数的前面也是可以加<code>+/-</code>号的，但加<code>-</code>号的含义不是得到一个负的整数，而是得到该整数的二进制补码（后续将介绍相关知识）。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; -0x2</code><code class="nohighlight hljs ansi" style="display:block;">0xfe</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Int(ans)</code><code class="nohighlight hljs ansi" style="display:block;">254</code></pre><h4 id="浮点数"><a class="docs-heading-anchor" href="#浮点数">浮点数</a><a id="浮点数-1"></a><a class="docs-heading-anchor-permalink" href="#浮点数" title="Permalink"></a></h4><p>根据IEEE 754规范，Julia使用<code>Float16</code>、<code>Float32</code>和<code>Float64</code>来表示半精度、单精度和双精度浮点数。使用字面量<code>f</code>和<code>e</code>作为<code>Float32</code>和<code>Float64</code>的指数分隔符。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(1.0), typeof(1e0),typeof(1.e4)</code><code class="nohighlight hljs ansi" style="display:block;">(Float64, Float64, Float64)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(1.0f0), typeof(1f-6), typeof(1.f4)</code><code class="nohighlight hljs ansi" style="display:block;">(Float32, Float32, Float32)</code></pre><h4 id="抽象类型"><a class="docs-heading-anchor" href="#抽象类型">抽象类型</a><a id="抽象类型-1"></a><a class="docs-heading-anchor-permalink" href="#抽象类型" title="Permalink"></a></h4><p>Julia中的类型可以从抽象类型派生出来。大多数面向对象语言将这种关系视为在类层次结构中描述对象的一种方法。在Julia中，抽象类型仅仅是像接口一样的概念性表示，内部没有数据元素。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; abstract type MyAbstractType end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct MyConcreteType &lt;: MyAbstractType
           member
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = MyConcreteType(5)</code><code class="nohighlight hljs ansi" style="display:block;">Main.MyConcreteType(5)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a isa MyAbstractType</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>虽然我们将在后面详细讨论这个概念，但类型只能从一个抽象类型派生出来。中缀运算符<code>isa</code>用于判断特定对象是否属于特定类型。这里类型可以是具体类型也可以是抽象类型。下面是Julia中数字类型的类型层次结构。</p><p><img src="../pictures/numerictypes.png" alt="numerictypes"/></p><h4 id="基本类型"><a class="docs-heading-anchor" href="#基本类型">基本类型</a><a id="基本类型-1"></a><a class="docs-heading-anchor-permalink" href="#基本类型" title="Permalink"></a></h4><p>基本类型是使用固定字节数表示数据的一种具体类型。基本类型的经典例子是整数和浮点数。与大多数语言不同，除了一组固定的内置类型外，Julia允许声明自己的基本类型。实际上，Julia的基本类型都是在语言本身中定义的:</p><pre><code class="language-julia hljs">primitive type Float16 &lt;: AbstractFloat 16 end
primitive type Float32 &lt;: AbstractFloat 32 end
primitive type Float64 &lt;: AbstractFloat 64 end

primitive type Bool &lt;: Integer 8 end
primitive type Char &lt;: AbstractChar 32 end

primitive type Int8    &lt;: Signed   8 end
primitive type UInt8   &lt;: Unsigned 8 end
primitive type Int16   &lt;: Signed   16 end
primitive type UInt16  &lt;: Unsigned 16 end
primitive type Int32   &lt;: Signed   32 end
primitive type UInt32  &lt;: Unsigned 32 end
primitive type Int64   &lt;: Signed   64 end
primitive type UInt64  &lt;: Unsigned 64 end
primitive type Int128  &lt;: Signed   128 end
primitive type UInt128 &lt;: Unsigned 128 end</code></pre><p>声明基本类型的一般语法是:</p><pre><code class="language-julia hljs">primitive type «name» «bits» end
primitive type «name» &lt;: «supertype» «bits» end</code></pre><p>虽然用户可以定义自己的基本类型，但建议只有在现有的基本类型不能满足要求时再定义新的基本类型。相同位值的基本类型本质上是不可互换的，也不能无缝转换。类型层次结构在这类类型的行为中扮演着重要的角色。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; UInt32(3f-1)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: InexactError: UInt32(0.3)</code></pre><p>尽管它们都是32位实体，但单精度浮点数不能在每种情况下都表示为无符号整数。不能创建任意大小位的基本类型，目前仅支持8位倍数的位大小。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; primitive type MyType1 40 end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; primitive type MyType2 4 end</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: invalid number of bits in primitive type MyType2</code></pre><h5 id="位类型"><a class="docs-heading-anchor" href="#位类型">位类型</a><a id="位类型-1"></a><a class="docs-heading-anchor-permalink" href="#位类型" title="Permalink"></a></h5><p>Julia可以在二进制接口层面上与编译完成的语言，如C/C++、FORTRAN等进行无缝地交互，得益于Julia中定义的某些数据类型同这些本地编译语言所使用的类型在二进制布局中是一致的。这种类型被称为<strong>位类型</strong>。Julia中的基本类型都是位类型的数据类型。某些复合数据类型也是位类型。我们将在遇到他们时进一步讨论。位类型可以通过在实例上调用<code>isbits</code>函数或在类型上调用<code>isbitstype</code>函数进行查询。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 10</code><code class="nohighlight hljs ansi" style="display:block;">10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isbits(a)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isbitstype(Int)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h4 id="有理数和复数"><a class="docs-heading-anchor" href="#有理数和复数">有理数和复数</a><a id="有理数和复数-1"></a><a class="docs-heading-anchor-permalink" href="#有理数和复数" title="Permalink"></a></h4><p>虽然有理数和复数是数字类型，但它们不是基本类型。它们是使用复合数据类型创建的，我们将把复合数据类型作为用户定义类型的一部分来介绍。</p><h3 id="字符"><a class="docs-heading-anchor" href="#字符">字符</a><a id="字符-1"></a><a class="docs-heading-anchor-permalink" href="#字符" title="Permalink"></a></h3><p><code>Char</code>是由32位值表示的字符。它是Unicode字符的一个有效UCS-4表示。我们将在String一章详细讨论<code>Char</code>及其与<code>String</code>的关系。<code>AbstractChar</code>抽象类型可方便用户开发自己的类<code>Char</code>数据类型。</p><h3 id="字符串"><a class="docs-heading-anchor" href="#字符串">字符串</a><a id="字符串-1"></a><a class="docs-heading-anchor-permalink" href="#字符串" title="Permalink"></a></h3><p>字符串是字符的集合。虽然大多数字符串是由Unicode字符编码组成的，但它们也可以存储其他类型的二进制数据。<code>AbstractString</code>抽象类型方便用户定义自己的字符串类型。</p><h2 id="用户定义类型"><a class="docs-heading-anchor" href="#用户定义类型">用户定义类型</a><a id="用户定义类型-1"></a><a class="docs-heading-anchor-permalink" href="#用户定义类型" title="Permalink"></a></h2><p>虽然Julia提供了相当多的内置类型，但仍需要将各种属性组合在一起的数据类型。</p><h3 id="结构"><a class="docs-heading-anchor" href="#结构">结构</a><a id="结构-1"></a><a class="docs-heading-anchor-permalink" href="#结构" title="Permalink"></a></h3><p>Julia用<code>struct</code>表示一旦被初始化，其内部属性就不能被修改的自定义复合类型。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Rectangle
           h::Float64
           w::Float64
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; r = Rectangle(10.0, 20.0)</code><code class="nohighlight hljs ansi" style="display:block;">Main.Rectangle(10.0, 20.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; r.h = 15</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: setfield! immutable struct of type Rectangle cannot be changed</code></pre><p><code>Rectangle</code>是一个<code>struct</code>，初始化值为10.0和20.0。属性值不能被修改。函数<code>Rectangle(10.0, 20.0)</code>用来执行初始化。它是一个特殊的函数。当我们讨论函数和方法时，将进行深入介绍。</p><h3 id="可变结构"><a class="docs-heading-anchor" href="#可变结构">可变结构</a><a id="可变结构-1"></a><a class="docs-heading-anchor-permalink" href="#可变结构" title="Permalink"></a></h3><p>假设我们需要<strong>Rectangle</strong>是可修改的，则可以创建一个可变结构，如下所示:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; mutable struct MRectangle
           h::Float64
           w::Float64
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mr = MRectangle(10.0, 20.0)</code><code class="nohighlight hljs ansi" style="display:block;">Main.MRectangle(10.0, 20.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mr.h = 15.0</code><code class="nohighlight hljs ansi" style="display:block;">15.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mr</code><code class="nohighlight hljs ansi" style="display:block;">Main.MRectangle(15.0, 20.0)</code></pre><p>可以看到，属性值在实例化对象之后是可以被修改的。Julia中的复合数据类型也可以从抽象类型派生出来。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; abstract type Shape end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Rectangle &lt;: Shape
           w::Float64
           h::Float64
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Square &lt;: Shape
           l::Float64
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><h3 id="成员"><a class="docs-heading-anchor" href="#成员">成员</a><a id="成员-1"></a><a class="docs-heading-anchor-permalink" href="#成员" title="Permalink"></a></h3><p>Julia中的复合类型具有成员属性，但没有成员函数或方法。Julia的多分派体系结构使函数的行为类似于特定类型的方法，但它们与面向对象语言中的方法不同。有一类特殊的函数，它可以是类型的成员。这些函数被称为<strong>构造函数</strong>。我们将在讨论函数时详细讨论构造函数。成员的类型信息并不总是在复合类型中被指定。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; mutable struct A
           member
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = A(5)</code><code class="nohighlight hljs ansi" style="display:block;">Main.A(5)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a.member)</code><code class="nohighlight hljs ansi" style="display:block;">Int64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a1 = A(&quot;string&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">Main.A(&quot;string&quot;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a1.member)</code><code class="nohighlight hljs ansi" style="display:block;">String</code></pre><h2 id="Any"><a class="docs-heading-anchor" href="#Any">Any</a><a id="Any-1"></a><a class="docs-heading-anchor-permalink" href="#Any" title="Permalink"></a></h2><p>虽然在前面的例子中，模糊性问题在对对象进行实例化时得到了解决，但我们永远不能确定动态成员属性未来将被赋予哪种数据类型。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a.member = &quot;julia&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;julia&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a.member)</code><code class="nohighlight hljs ansi" style="display:block;">String</code></pre><p><code>a.member</code>之前的类型是<code>Int64</code>，现在是<code>String</code>。Julia假定这种未指明的类型为<code>Any</code>。在不能确定类型的情况下，Julia将假定类型为<code>Any</code>。从性能的角度来看，使用<code>Any</code>是不可取的。每次访问<code>Any</code>类型的对象时，它都会重定向到另一个实际的对象。我们不可能事先知道<code>Any</code>对象的大小。实际上，它是一个指向内存中实际对象所在的另一个位置的指针:</p><p><img src="../pictures/anytype.png" alt="anytype"/></p><h2 id="参数数据类型"><a class="docs-heading-anchor" href="#参数数据类型">参数数据类型</a><a id="参数数据类型-1"></a><a class="docs-heading-anchor-permalink" href="#参数数据类型" title="Permalink"></a></h2><p><code>Any</code>作为类型会引入不必要的跳转，因此效率很低。有时，类型不一定会影响算法，但会引入不同的数据位大小。例如，前面介绍的<code>Rational</code>数据类型，分子和分母可以是任何整数类型，如<code>Int8</code>、<code>Int16</code>、<code>Int32</code>、<code>Int64</code>或<code>Int128</code>。<code>Rational</code>数据类型的定义如下:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Rational{T&lt;:Integer} &lt;: Real
           num::T
           den::T
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>两个属性<code>num</code>和<code>den</code>的类型为<code>T</code>，其中<code>T</code>是<code>Integer</code>的子类型。<code>Rational</code>是<code>Real</code>的一个子类型。以下是参数数据类型的一些特性。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rational{Any}</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: TypeError: in Rational, in T, expected T&lt;:Integer, got Type{Any}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rational{Int32} &lt;: Rational</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rational{Int32} &lt;: Rational{Integer}</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><p>理解这种行为尤其重要。尽管<code>Int32</code>是<code>Integer</code>的子类型，但参数表示<code>Rational{Int32}</code>不是<code>Rational{Integer}</code>的子类型。然而，<code>Rational{Int32}</code>是<code>Rational</code>的子类型。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = Rational{Int32}(1,UInt32(2))</code><code class="nohighlight hljs ansi" style="display:block;">1//2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a.num), typeof(a.den)</code><code class="nohighlight hljs ansi" style="display:block;">(Int32, Int32)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = Rational{Integer}(1,UInt32(2))</code><code class="nohighlight hljs ansi" style="display:block;">1//0x0000000000000002</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(b.num), typeof(b.den)</code><code class="nohighlight hljs ansi" style="display:block;">(Int64, UInt64)</code></pre><p>与具体数据类型一样，抽象数据类型也可以参数化。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; abstract type Shape{T&lt;:AbstractFloat} end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Rectangle{T&lt;:AbstractFloat} &lt;: Shape{T}
           w::T
           h::T
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Square{T&lt;:AbstractFloat} &lt;: Shape{T}
           s::T
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>根据上面的方案，针对<code>T</code>可以开发不同的功能，如将<code>T</code>设为<code>Float32</code>或<code>Float64</code>，构建的<code>Rectangle{Float32}</code>类型与<code>Rectangle{Float64}</code>类型完全不同，它们是在编译过程中实例化具体类型时生成的。</p><p>类型的参数化是Julia语言一个非常有用的特性，除此以外，也可以对整数值进行参数化。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Point{T&lt;:AbstractFloat,N}
           x::Vector{T}
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; num_coor(::Point{T,N}) where {T&lt;:AbstractFloat,N} = N</code><code class="nohighlight hljs ansi" style="display:block;">num_coor (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p2 = Point{Float32,2}([1f0,2f0])</code><code class="nohighlight hljs ansi" style="display:block;">Main.Point{Float32, 2}(Float32[1.0, 2.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p3 = Point{Float32,3}([1f0,2f0,3f0])</code><code class="nohighlight hljs ansi" style="display:block;">Main.Point{Float32, 3}(Float32[1.0, 2.0, 3.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; num_coor(p2)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; num_coor(p3)</code><code class="nohighlight hljs ansi" style="display:block;">3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; push!(p2.x,3)</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float32}:
 1.0
 2.0
 3.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p2</code><code class="nohighlight hljs ansi" style="display:block;">Main.Point{Float32, 2}(Float32[1.0, 2.0, 3.0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; num_coor(p2)</code><code class="nohighlight hljs ansi" style="display:block;">2</code></pre><p>可以看出，类型中使用的<code>N</code>是用作类型参数的整数。</p><h2 id="类型上的运算"><a class="docs-heading-anchor" href="#类型上的运算">类型上的运算</a><a id="类型上的运算-1"></a><a class="docs-heading-anchor-permalink" href="#类型上的运算" title="Permalink"></a></h2><p>某些操作适用于类型。在前面，我们已经看到了一些，本节将详细介绍它们。</p><h3 id="typeof"><a class="docs-heading-anchor" href="#typeof">typeof</a><a id="typeof-1"></a><a class="docs-heading-anchor-permalink" href="#typeof" title="Permalink"></a></h3><p>此函数提供与类型的实例相关联的具体类型。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 1 // 2</code><code class="nohighlight hljs ansi" style="display:block;">1//2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">Rational{Int64}</code></pre><p>类型本身也有类型，它们都是<code>DataType</code>类型的实例。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(Int)</code><code class="nohighlight hljs ansi" style="display:block;">DataType</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(Any)</code><code class="nohighlight hljs ansi" style="display:block;">DataType</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(DataType)</code><code class="nohighlight hljs ansi" style="display:block;">DataType</code></pre><h3 id="别名"><a class="docs-heading-anchor" href="#别名">别名</a><a id="别名-1"></a><a class="docs-heading-anchor-permalink" href="#别名" title="Permalink"></a></h3><p>与任何其他实例对象一样，类型可以进行比较和赋值。下面是来自<code>base/boot.jl</code>的代码片段。</p><pre><code class="language-julia hljs">if Int === Int64
    const UInt = UInt64
else
    const UInt = UInt32
end</code></pre><p><code>Int</code>对象与<code>Int64</code>对象进行比较，如果相同则<code>UInt</code>初始化为<code>UInt64</code>，否则初始化为<code>UInt32</code>。因此根据机器架构，<code>UInt</code>成为<code>UInt64</code>或<code>UInt32</code>的别名。</p><h3 id="isa"><a class="docs-heading-anchor" href="#isa">isa</a><a id="isa-1"></a><a class="docs-heading-anchor-permalink" href="#isa" title="Permalink"></a></h3><p>判断实例是否属于特定类型。<code>isa</code>也可以用作中缀运算符。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; isa(1,Number)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isa(1,Matrix)</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isa(1,Int)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; &quot;julia&quot; isa String</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h3 id="supertype"><a class="docs-heading-anchor" href="#supertype">supertype</a><a id="supertype-1"></a><a class="docs-heading-anchor-permalink" href="#supertype" title="Permalink"></a></h3><p>这个函数返回一个类型的直接超类型。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; supertype(Int32)</code><code class="nohighlight hljs ansi" style="display:block;">Signed</code></pre><p><code>&gt;:</code>用于指定（在结构或函数定义阶段）或判断一个类是否是另一个类的超类。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Integer &gt;: UInt8</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Float64 &gt;: Float16</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><h3 id=":"><a class="docs-heading-anchor" href="#:">&lt;:</a><a id=":-1"></a><a class="docs-heading-anchor-permalink" href="#:" title="Permalink"></a></h3><p>此操作符用于表示一个类型是否是另一个类型的子类型。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Int32 &lt;: Integer</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Int32 &lt;: AbstractFloat</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Int32 &lt;: Real</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Int32 &lt;: Signed</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h2 id="打印数据类型"><a class="docs-heading-anchor" href="#打印数据类型">打印数据类型</a><a id="打印数据类型-1"></a><a class="docs-heading-anchor-permalink" href="#打印数据类型" title="Permalink"></a></h2><p>在定义了复杂的数据类型后，常需要以有意义的方式表示数据。默认情况下，所有成员都将作为元组打印。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct A
           a1::Int32
           a2::Float64
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = A(1,2)</code><code class="nohighlight hljs ansi" style="display:block;">Main.A(1, 2.0)</code></pre><p>其次，数据经常打印在REPL上。要禁止在REPL上打印数据，可以用分号(<code>;</code>)结束语句。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a</code><code class="nohighlight hljs ansi" style="display:block;">Main.A(1, 2.0)</code></pre><p>默认情况下，<code>Nothing</code>不会标记输出。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; nothing</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><h3 id="show"><a class="docs-heading-anchor" href="#show">show</a><a id="show-1"></a><a class="docs-heading-anchor-permalink" href="#show" title="Permalink"></a></h3><p>默认情况下，为了在REPL上显示输出，会在数据类型上调用相关的<code>show</code>方法。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct A
           a1::Int32
           a2::Float64
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = A(1, 2)</code><code class="nohighlight hljs ansi" style="display:block;">Main.A(1, 2.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function Base.show(io::IO, a::A)
           println(io, &quot;a1: &quot;, a.a1, &quot; a2: &quot;, a.a2)
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a</code><code class="nohighlight hljs ansi" style="display:block;">a1: 1 a2: 2.0</code></pre><h3 id="print"><a class="docs-heading-anchor" href="#print">print</a><a id="print-1"></a><a class="docs-heading-anchor-permalink" href="#print" title="Permalink"></a></h3><p><code>show</code>用于在任何类型的输出设备上显示数据，而<code>print</code>只能用于输出文本信息。如果没有引入特定的打印例程，则在调用<code>print</code>时在内部使用<code>show</code>。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; print(a)</code><code class="nohighlight hljs ansi" style="display:block;">a1: 1 a2: 2.0</code></pre><h3 id="string"><a class="docs-heading-anchor" href="#string">string</a><a id="string-1"></a><a class="docs-heading-anchor-permalink" href="#string" title="Permalink"></a></h3><p>此函数可用于将任何类型转换为其字符串表示形式。当没有提供适当的转换方法时，将在内部调用<code>print</code>函数以获取数据类型的文本表示。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; string(a)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;a1: 1 a2: 2.0\n&quot;</code></pre><p>在前面的代码中可以清楚地看到<code>print</code>或底层<code>show</code>的用法。而字符串中额外的行尾则归因于<code>println</code>的使用，它向语句添加了一个<em>EOL</em>。如果想去掉它，只需要将<code>show</code>中的<code>println</code>换为<code>print</code>即可。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function Base.show(io::IO, a::A)
           print(io, &quot;a1: &quot;, a.a1, &quot; a2: &quot;, a.a2)
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; string(a)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;a1: 1 a2: 2.0&quot;</code></pre><h2 id="数字在计算机中的存储与运算"><a class="docs-heading-anchor" href="#数字在计算机中的存储与运算">数字在计算机中的存储与运算</a><a id="数字在计算机中的存储与运算-1"></a><a class="docs-heading-anchor-permalink" href="#数字在计算机中的存储与运算" title="Permalink"></a></h2><p>在Julia中，如果你输入<span>$(\sqrt3)^2$</span>，结果将是2.9....96，其中9重复了15次。相比与传统的数学运算，计算机的运算方式有两个明显且本质的区别:</p><ol><li><p>计算机只能表示有限数量的数字;</p></li><li><p>计算机中表示的数字只能有有限多个有效数字。</p></li></ol><p>因此，能够在计算机中精确表示的数字只是有理数的一个子集。每当计算机执行一个运算，当结果不是一个可以在计算机中精确表示的数字时，就会用一个近似值来代替这个数字。这被称为<em>舍入误差</em>：用计算机进行实数计算时产生的错误。</p><h3 id="实数的浮点表示方法"><a class="docs-heading-anchor" href="#实数的浮点表示方法">实数的浮点表示方法</a><a id="实数的浮点表示方法-1"></a><a class="docs-heading-anchor-permalink" href="#实数的浮点表示方法" title="Permalink"></a></h3><p>下面是在计算机中表示实数的一般模型：</p><p class="math-container">\[x=s(.a_1a_2...a_{t})_{\beta}\times\beta^{e} \tag{1}\]</p><p>其中</p><p class="math-container">\[\begin{align*}
s &amp; → x=±1 的符号 \\[2ex] 
e &amp; → 指数，范围为L≤e≤U \\[2ex] 
(.a_1... a_{t})_{\beta} &amp; = \dfrac{a_1}{\beta}+\dfrac{a_2}{\beta^2}+\cdots+\dfrac{a_t}{\beta^t}；尾数 \\[2ex]
β &amp; → 基数 \\[2ex]
t &amp; → 有效数字个数；精度 
\end{align*}\]</p><p>在浮点表示法(1)中，如果我们以这样一种方式指定<span>$e$</span>，即<span>$a_1≠ 0$</span>，那么表示将是唯一的。这称为<strong>规格化</strong>的浮点表示法。例如，如果<span>$β = 10$</span>，在规格化的浮点数中，我们将把<span>$0.012$</span>写成<span>$0.12 × 10^{−1}$</span>，而不是<span>$0.012 × 10^0$</span>或<span>$0.0012 × 10^1$</span>。</p><p>在当今大多数计算机中，基数是<span>$β = 2$</span>。过去老式的IBM大型机中曾使用过基数8和16。一些手持计算器使用基数10。莫斯科国立大学开发的Setun计算机，使用的基数是3，但并没有得到广泛推广。</p><p>对于<span>$s$</span>，<span>$β$</span>，<span>$t$</span>，<span>$e$</span>的值，在一般浮点模型(1)中有多种选择。IEEE 64位浮点表示是当今大多数计算机中使用的特定模型：</p><p class="math-container">\[x=(-1)^s(1.a_2a_3... a_{53})_2 2^{e-1023} \tag{2}\]</p><ul><li><p>注意在方程(1)和(2)中<span>$s$</span>的不同表现形式。在(2)中，<span>$s$</span>为0或1。<span>$s = 0$</span>，<span>$x$</span>是正的；<span>$s = 1$</span>, <span>$x$</span>是负的。</p></li><li><p>由于<span>$β = 2$</span>，在<span>$x$</span>的规格化浮点表示中，小数点后的第一个(非零)位必然是1。因此我们不需要存储这个数字。这就是为什么在(2)中我们把<span>$x$</span>写成从1开始的小数。即使精度是<span>$t = 52$</span>，我们也能够访问到第53位有效数字<span>$a_{53}$</span>。</p></li><li><p>指数的范围是:<span>$0≤e≤2047$</span>。稍后会讨论2047的来源。但首先，我们讨论一下为什么在(2)表示法中我们用<span>$e - 1023$</span>作为指数，而不是简单地用<span>$e$</span>(在(1)表示法中)作为指数。如果最小的可能指数是<span>$e = 0$</span>，那么计算机能生成的最小正数将是<span>$(1.00…0)_2 = 1$</span>：当然，我们需要计算机来表示小于1的数字！这就是为什么我们在表示(2)中使用称为<strong>有偏指数</strong>的移位表达式<span>$e - 1023$</span>。注意，有偏指数的范围是<span>$- 1023≤e - 1023≤1024$</span>。</p></li></ul><p>下图说明了计算机的物理位如何与上面的表示相对应。下表中编号为1到64的每个单元对应于计算机内存中的物理位。</p><p><img src="../pictures/physicalbits.png" alt="Physical bits"/></p><ul><li><p>第一位是符号位：它存储<span>$s$</span>的值，0或1。</p></li><li><p>蓝色的2到12位存储指数<span>$e$</span>(不是<span>$e−1023$</span>)。使用11位，可以生成从<span>$0$</span>到<span>$2^{11}−1 = 2047$</span>的整数。下面是如何得到<span>$e$</span>的最小值和最大值：</p></li></ul><p class="math-container">\[e=(00...0)_2=0 \\[1ex] 
e=(11...1)_2 =2^0+2^1+...+2^{10}=\dfrac{2^{11}-1}{2-1}=2047\]</p><ul><li>红色的52位，存储有效数字<span>$a_2$</span>到<span>$a_{53}$</span>。</li></ul><p><strong>例1</strong>：求10.375的浮点表示形式。</p><p><strong>解</strong>： 通过计算 <span>$10=0\times2^0+\textcolor{blue}{1}× 2^1 + \textcolor{green}{0}\times2^2+\textcolor{red}{1}\times2^3$</span> 和 <span>$0.375=0\times2^{-1}+\textcolor{blue}{1}\times2^{-2}+\textcolor{green}{1}\times2^{-3}$</span> 可以得到 <span>$10=(\textcolor{red}{1}\textcolor{green}{0}\textcolor{blue}{1}0)_2$</span> 和 <span>$0.375=(.0\textcolor{blue}{1}\textcolor{green}{1})_2$</span>。最终得到：</p><p class="math-container">\[10.375=(1010.011)_2=(1.010011)_2\times2^3\]</p><p>式中<span>$(1.010011)_2 × 2^3$</span>为该数字的规格化的浮点表示。现在我们将其改写为式(2)的表示形式：</p><p class="math-container">\[10.375=(-1)^0(1.010011)_2\times2^{1026-1023}\]</p><p>由于<span>$1026 =(10000000010)_2$</span>，按位表示的最终结果为：</p><p><img src="../pictures/base10number.png" alt="基于10的数"/></p><p>注意因为数字是正数，第一个符号位是0。接下来的11位(蓝色)代表指数<span>$e = 1026$</span>，下一组红色的位是尾数，尾数的最末一位有效数字以后用0填充。在Julia中，我们可以通过输入<code>bitstring(10.375)</code>来逐位表示：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitstring(10.375)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;0100000000100100110000000000000000000000000000000000000000000000&quot;</code></pre><p><strong>特殊情况：0，无穷，非数</strong></p><p>在浮点算术中有两个零：<span>$+0.0$</span>和<span>$−0.0$</span>，它们有特殊的表示。在表示0时，所有的指数位和尾数位都设置为0。符号位是0的代表<span>$+0.0$</span>，1的代表<span>$−0.0$</span>：</p><p><img src="../pictures/zeros.png" alt="zeros"/></p><p>当指数位设置为0时，我们有<span>$e = 0$</span>，因此<span>$e−1023 =−1023$</span>。这种将所有指数位设置为零的情况，是为<span>$±0.0$</span>和<strong>非规格化</strong>数字保留的。非规格化数用来表示靠近0的数或0。</p><p>下面是计算机中正负无穷数的表示方法：</p><p><img src="../pictures/inf.png" alt="正负无穷数"/></p><p>当指数位全设置为1时，我们有<span>$e = 2047$</span>，因此<span>$e−1023 = 1024$</span>。这种安排是专门为<span>$±∞$</span>以及其他特殊值，如NaN(非数)保留的；当尾数等于0时表示无穷大，尾数不等于0时表示非数。</p><p>综上所述，尽管(2)中的<span>$−1023≤e−1023≤1024$</span>，但在表示非零实数时，我们只能访问<span>$−1022≤e−1023≤1023$</span>的指数范围。</p><p>因此，计算机可以表示的最小正实数（非规格化）为：</p><p class="math-container">\[x=(-1)^0(0.00...1)_2\times2^{-1022}=2^{-52}\times2^{-1022}=5.0\times10^{-324}\]</p><p>最大正实数（规格化）为：</p><p class="math-container">\[x=(-1)^0(1.11...1)_2\times2^{1023}=\left(1+\dfrac{1}{2}+\dfrac{1}{2^2}+...+\dfrac{1}{2^{52}} \right)\times2^{1023}=(2-2^{-52})\times2^{1023}≈0.18\times10^{309}\]</p><p>在计算过程中，如果得到一个小于最小浮点数的数字，则会产生<strong>下溢错误</strong>。大于最大值的数字会产生<strong>上溢错误</strong>。</p><p>Julia中上溢和下溢错误分别是正负无穷：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; nextfloat((2.0-2^(-52))*2.0^1023)</code><code class="nohighlight hljs ansi" style="display:block;">Inf</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; prevfloat(-(2.0-2^(-52))*2.0^1023)</code><code class="nohighlight hljs ansi" style="display:block;">-Inf</code></pre><p>其运算方式与水银式温度计类似。</p><h3 id="整数的表示方法"><a class="docs-heading-anchor" href="#整数的表示方法">整数的表示方法</a><a id="整数的表示方法-1"></a><a class="docs-heading-anchor-permalink" href="#整数的表示方法" title="Permalink"></a></h3><p>在前一节中，我们讨论了计算机中实数的表示方法。这里我们将简要讨论整数的表示方法。计算机如何表示整数<span>$n$</span>？与实数类似，我们以2为基数开始写<span>$n$</span>。我们有64位来表示它的有效数字和符号。与浮点数一样，我们为符号分配一位，将其余的63位用于有效数字。当对整数进行加法运算时，这种方法有一些缺点。另一种方法被称为<strong>二进制补码</strong>，它更常用，包括在Julia中。</p><p>举个例子，假设我们的计算机是8位的。要用二进制补码表示12(或任何正整数)，只需将它写成以2为基数展开的形式：<span>$(00001100)_2$</span>。为了表示−12，我们做如下操作：翻转所有数位，用0替换1，用1替换0，然后在结果上加1。翻转数字12，我们得到<span>$(11110011)_2$</span>，加上1（二进制）得到<span>$(11110100)_2$</span>。因此，−12在二进制补码法中被表示为<span>$(11110100)_2$</span>。为了表示-12，费了那么大的功夫，感觉有点奇怪，但当把12和-12二进制表示相加时，这种表示方法的优势立刻显现：</p><p class="math-container">\[(00001100)_2+(11110100)_2=(\textcolor{red}{1}00000000)_2\]</p><p>这个和的前8位(从右到左)，也就是计算机能表示的(忽略红色数字1)，是<span>$(00000000)_2$</span>。所以就像以10为基数的<span>$12 +(- 12)= 0$</span>一样，这些数的表示形式的和也是0。</p><p>我们可以用Julia实现64位的计算。函数<code>bitstring</code>输出一个整数的数位，对于负数使用二进制补码：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitstring(12)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;0000000000000000000000000000000000000000000000000000000000001100&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bitstring(-12)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;1111111111111111111111111111111111111111111111111111111111110100&quot;</code></pre><p>你可以验证当截断到64位时，这些表示的和为0。</p><p>下面是另一个说明二进制补码优点的例子。考虑−3和5的表现，</p><p class="math-container">\[-3=(11111101)_2 和 5 =(00000101)_2\]</p><p>−3和5的和是2；那么它们表示形式的二进制和呢？我们有：</p><p class="math-container">\[(11111101)_2+(00000101)_2=(\textcolor{red}{1}00000010)_2\]</p><p>如果我们忽略红色的第9位，结果是<span>$(10)_2$</span>，结果也确实是2。注意，如果我们遵循浮点表示中使用的相同方法，并将最左边的位分配给整数的符号，就不会有这个属性。</p><p>还记得对无符号整数取负的例子吧，它实际上返回的就是原整数的二进制补码。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 0xc</code><code class="nohighlight hljs ansi" style="display:block;">0x0c</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; -0xc</code><code class="nohighlight hljs ansi" style="display:block;">0xf4</code></pre><p>在二进制补码中，使用64位，可以表示<span>$−2^{63} =−9223372036854775808$</span>和<span>$2^{63}−1 =9223372036854775807$</span>之间的整数。小于或大于这个范围的任何整数都会产生<strong>下溢</strong>或<strong>上溢</strong>错误。</p><p>整数的溢出与浮点数有所不同，如下所示：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemax(Int64)</code><code class="nohighlight hljs ansi" style="display:block;">9223372036854775807</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemin(Int64)</code><code class="nohighlight hljs ansi" style="display:block;">-9223372036854775808</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemax(Int64) + 1</code><code class="nohighlight hljs ansi" style="display:block;">-9223372036854775808</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typemin(Int64) - 1</code><code class="nohighlight hljs ansi" style="display:block;">9223372036854775807</code></pre><p>当获得一个超过最大（或最小）可能值的整数时，Julia绕到最小（或最大）的整数，并继续计算。其运算方法与指针式钟表完全一样。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« 安装与配置</a><a class="docs-footer-nextpage" href="../ch03controlflows/">控制流 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 16 November 2021 16:50">Tuesday 16 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
