<!DOCTYPE html>
<html lang="cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>数据集 · Julia程序设计基础</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Julia程序设计基础 logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Julia程序设计基础</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">安装与配置</a></li><li><a class="tocitem" href="../ch02dadatypes/">数据类型</a></li><li><a class="tocitem" href="../ch03controlflows/">控制流</a></li><li><a class="tocitem" href="../ch04function/">函数和方法</a></li><li><a class="tocitem" href="../ch05scope/">变量的作用域</a></li><li class="is-active"><a class="tocitem" href>数据集</a><ul class="internal"><li><a class="tocitem" href="#预定义数据结构"><span>预定义数据结构</span></a></li><li><a class="tocitem" href="#元组"><span>元组</span></a></li><li><a class="tocitem" href="#范围"><span>范围</span></a></li><li><a class="tocitem" href="#数组"><span>数组</span></a></li><li><a class="tocitem" href="#关联集"><span>关联集</span></a></li><li><a class="tocitem" href="#集合"><span>集合</span></a></li><li><a class="tocitem" href="#迭代"><span>迭代</span></a></li><li><a class="tocitem" href="#生成器和推导"><span>生成器和推导</span></a></li></ul></li><li><a class="tocitem" href="../ch07array/">数组</a></li><li><a class="tocitem" href="../ch08string/">字符串</a></li><li><a class="tocitem" href="../ch09metaprograme/">元编程</a></li><li><a class="tocitem" href="../ch10file/">文件</a></li><li><a class="tocitem" href="../ch11guidelines/">编程风格</a></li><li><a class="tocitem" href="../ch12performance/">性能</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>数据集</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>数据集</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="数据集"><a class="docs-heading-anchor" href="#数据集">数据集</a><a id="数据集-1"></a><a class="docs-heading-anchor-permalink" href="#数据集" title="Permalink"></a></h1><p>每种编程语言都提供了一定的最小数量的数据结构集来将多个数据元素表示为容器。即数组、字典、集合和元组，等等。</p><h2 id="预定义数据结构"><a class="docs-heading-anchor" href="#预定义数据结构">预定义数据结构</a><a id="预定义数据结构-1"></a><a class="docs-heading-anchor-permalink" href="#预定义数据结构" title="Permalink"></a></h2><p>1975年，Niklaus Wirth，一个著名的计算机专家和编程语言PASCAL的作者写了一本书：算法+数据结构=程序。明确强调了数据结构和算法在编程中的重要性。几乎没有任何现代编程语言不提供对数据结构的内建支持，Julia也不例外。许多数据结构是在Julia核心语言中定义的，而更广泛的数据结构是在像<code>DataStrctures.jl</code>这样的包中定义的。在本章中，我们重点介绍该语言在不需要使用任何附加包的情况下定义的数据结构，如：</p><ol><li><p>元组</p></li><li><p>数组</p></li><li><p>字典</p></li><li><p>集合</p></li></ol><h2 id="元组"><a class="docs-heading-anchor" href="#元组">元组</a><a id="元组-1"></a><a class="docs-heading-anchor-permalink" href="#元组" title="Permalink"></a></h2><p>元组在Julia中非常常见，以至于我们经常不把它们作为一种专门的数据结构来看待。在前面，我们介绍了元组的一些属性，下面将进行更详细的介绍。以下是它的功能概要：</p><ol><li><p>不变性</p></li><li><p>异构性</p></li><li><p>可在模式匹配中使用</p></li><li><p>可通过索引访问元素</p></li></ol><p>下面是一些例子：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = (1, &quot;string&quot;, 1.0)</code><code class="nohighlight hljs ansi" style="display:block;">(1, &quot;string&quot;, 1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)                   # 异构性</code><code class="nohighlight hljs ansi" style="display:block;">Tuple{Int64, String, Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a[1]                        # 通过索引访问</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a[1] = 6                    # 不变性</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching setindex!(::Tuple{Int64, String, Float64}, ::Int64, ::Int64)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b, c = a                    # 模式匹配</code><code class="nohighlight hljs ansi" style="display:block;">(1, &quot;string&quot;, 1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c</code><code class="nohighlight hljs ansi" style="display:block;">&quot;string&quot;</code></pre><h3 id="NTuple"><a class="docs-heading-anchor" href="#NTuple">NTuple</a><a id="NTuple-1"></a><a class="docs-heading-anchor-permalink" href="#NTuple" title="Permalink"></a></h3><p><code>NTuple{N, T}</code>是具有<code>N</code>个类型为<code>T</code>的元组的参数定义。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; NTuple{3, Int}</code><code class="nohighlight hljs ansi" style="display:block;">Tuple{Int64, Int64, Int64}</code></pre><p>你可以像这样创建一个接受元组参数的方法：写成<code>f(::NTuple{3, Int})</code>而不要写成<code>f(::Tuple{Int64, Int64, Int64})</code>。</p><p>当你希望创建一个包含特定模式的<code>N</code>个参数的元组时，可以使用函数<code>ntuple</code>。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = ntuple(x-&gt;4, 10)</code><code class="nohighlight hljs ansi" style="display:block;">(4, 4, 4, 4, 4, 4, 4, 4, 4, 4)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">NTuple{10, Int64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = ntuple(i-&gt;i*1.0, 10)</code><code class="nohighlight hljs ansi" style="display:block;">(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">NTuple{10, Float64}</code></pre><h3 id="作为集的元组"><a class="docs-heading-anchor" href="#作为集的元组">作为集的元组</a><a id="作为集的元组-1"></a><a class="docs-heading-anchor-permalink" href="#作为集的元组" title="Permalink"></a></h3><p><code>Tuple</code>可以作为元素集使用。这意味着它们可以被迭代，拥有集的典型函数，如<code>length</code>。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; length(a)</code><code class="nohighlight hljs ansi" style="display:block;">10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for i = 1:length(a)
           println(a[i])
       end</code><code class="nohighlight hljs ansi" style="display:block;">1.0
2.0
3.0
4.0
5.0
6.0
7.0
8.0
9.0
10.0</code></pre><h3 id="作为类型参数的整数"><a class="docs-heading-anchor" href="#作为类型参数的整数">作为类型参数的整数</a><a id="作为类型参数的整数-1"></a><a class="docs-heading-anchor-permalink" href="#作为类型参数的整数" title="Permalink"></a></h3><p>观察<code>NTuple</code>类型的一个发现是，它有一个作为类型的整数参数。这同样适用于任何可变或不可变类型。让我们创建一个<code>Point</code>类型，它可以被用于2或3维情况。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Point{N}
           data::NTuple{N, Float32}
           Point(d...)=new{length(d)}(d)
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; const Point2D = Point{2}</code><code class="nohighlight hljs ansi" style="display:block;">Main.Point{2}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; const Point3D = Point{3}</code><code class="nohighlight hljs ansi" style="display:block;">Main.Point{3}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function dist(p1::Point2D, p2::Point2D)
           dx, dy = (p1.data[1] - p2.data[1], p1.data[2] - p2.data[2])
           return sqrt(dx*dx+dy*dy)
       end</code><code class="nohighlight hljs ansi" style="display:block;">dist (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function dist(p1::Point3D, p2::Point3D)
           dx, dy, dz = (p1.data[1] - p2.data[1],
                         p1.data[2] - p2.data[2],
                         p1.data[3] - p2.data[3])
           return sqrt(dx*dx+dy*dy+dz*dz)
       end</code><code class="nohighlight hljs ansi" style="display:block;">dist (generic function with 2 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist(Point(1, 2), Point(3, 4))</code><code class="nohighlight hljs ansi" style="display:block;">2.828427f0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist(Point(1, 2, 3), Point(3, 4, 5))</code><code class="nohighlight hljs ansi" style="display:block;">3.4641016f0</code></pre><p>在前面的例子中，我们定义了<code>Point{N}</code>的别名<code>Point2D</code>和<code>Point3D</code>，为这两种类型定义了两个<code>dist</code>函数，并确保可以基于整数值2或3进行分派。<code>Point{2}</code>和<code>Point{3}</code>是两种不同的类型。由于<code>NTuple</code>是集类型，我们可以使用<code>dist</code>方法来处理<code>Point{N}</code>。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Point{N}
           data::NTuple{N, Float32}
           Point(d...)=new{length(d)}(d)
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function dist(p1::Point{N}, p2::Point{N}) where N
           sumval = 0f0
           for i=1:N
               d = p1.data[i] - p2.data[i]
               sumval += d*d
           end
           return sqrt(sumval)
       end</code><code class="nohighlight hljs ansi" style="display:block;">dist (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist(Point(1, 2), Point(3, 4))</code><code class="nohighlight hljs ansi" style="display:block;">2.828427f0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist(Point(1, 2, 3), Point(3, 4, 5))</code><code class="nohighlight hljs ansi" style="display:block;">3.4641016f0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist(Point(1f0, 2f0, 3f0), Point(1, 2))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching dist(::Main.Point{3}, ::Main.Point{2})
Closest candidates are:
  dist(::Main.Point{N}, !Matched::Main.Point{N}) where N at REPL[2]:1</code></pre><p>如果我们不使用参数形式的<code>Point{N}</code>，而是使用<code>Point</code>，会是错误的吗？<code>Point{2}</code>和<code>Point{3}</code>是两种不同的类型。<code>dist</code>函数会为两种不同的类型分别编译吗？我们可以试一下。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Point{N}
           data::NTuple{N, Float32}
           Point(d...)=new{length(d)}(d)
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function dist(p1::Point, p2::Point)
           N = length(p1.data)
           sumval = 0f0
           for i = 1:N
               d = p1.data[i] - p2.data[i]
               sumval += d*d
           end
           return sqrt(sumval)
       end</code><code class="nohighlight hljs ansi" style="display:block;">dist (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist(Point(1, 2),Point(3, 4))</code><code class="nohighlight hljs ansi" style="display:block;">2.828427f0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist(Point(1, 2, 3), Point(3, 4, 5))</code><code class="nohighlight hljs ansi" style="display:block;">3.4641016f0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dist(Point(1f0, 2f0, 3f0), Point(1, 2))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: BoundsError: attempt to access Tuple{Float32, Float32} at index [3]</code></pre><p>现在，我们可以将<code>Point{2}</code>和<code>Point{3}</code>参数传递给同一个函数。这说明只创建了一个方法，没有为<code>Point{2}</code>和<code>Point{3}</code>版本编译两个方法。哪个方式是正确的？这是一个设计决策，而不是编程语言的概念。<code>Point2D</code>和<code>Point3D</code>是可混合使用的吗？我们需要支持<code>Point{N1}</code>和<code>Point{N2}</code>的混合</code>dist</code>方法吗？如果是，则下面是一种可能的实现方法。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Point{N}
           data::NTuple{N, Float32}
           Point(d...)=new{length(d)}(d)
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function dist(p1::Point{N}, p2::Point{N}) where N
           sumval = 0f0
           for i=1:N
               d = p1.data[i] - p2.data[i]
               sumval += d*d
           end
           return sqrt(sumval)
       end</code><code class="nohighlight hljs ansi" style="display:block;">dist (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function dist(p1::Point{N1}, p2::Point{N2}) where {N1, N2}
           N1 &gt; N2 &amp;&amp; return dist(p2, p1)
           tp = Point(p1.data..., ntuple(i-&gt;0f0, N2-N1)...)
           return dist(tp, p2)
       end</code><code class="nohighlight hljs ansi" style="display:block;">dist (generic function with 2 methods)</code></pre><ul><li><p>我们为具有相同维数<code>N</code>的<code>Point{N}</code>创建了一个方法。</p></li><li><p>然后我们创建了另一个方法，可以输入不同维度的点。</p></li><li><p>这里，我们假设第一个参数的维数小于第二个参数。</p></li><li><p>如果第一个参数不小于第二个参数，我们通过翻转参数来调用方法。从而确保第一个参数的维数小于第二个(N1 &lt; N2)。</p></li><li><p>我们创建一个与<code>p2</code>维数相同的临时点(<code>tp</code>)，方法是向更高维度填充零，并调用<code>dist(tp, p2)</code>。</p></li></ul><h3 id="值参数"><a class="docs-heading-anchor" href="#值参数">将数值作为类型参数</a><a id="值参数-1"></a><a class="docs-heading-anchor-permalink" href="#值参数" title="Permalink"></a></h3><p>让我们看看下面的代码控制流：</p><pre><code class="language-julia hljs">if val == 1
    f1()
elseif val == 2
    f2()
elseif val == 3
    f3()
else
    f4()
end</code></pre><p>这些函数是否可以使用多分派而不是使用<code>if...elseif...else</code>？</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct MyVal{N}
           MyVal(N)=new{N}()
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(::MyVal{N}) where N = N</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f(::MyVal{1})
           println(&quot;Called from 1&quot;)
       end</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 2 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(MyVal(2))</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f(MyVal(1))</code><code class="nohighlight hljs ansi" style="display:block;">Called from 1</code></pre><ul><li><p><code>MyVal{N}</code>基于<code>N</code>的值定义类型。</p></li><li><p>方法<code>f</code>适用于<code>MyVal{N}</code>的所有值。</p></li><li><p>仅为<code>MyVal{1}</code>定义了一个专用方法<code>f</code>。</p></li><li><p>现在<code>f(MyVal(2))</code>调用一般方法，<code>f(MyVal(1))</code>调用特定方法。</p></li></ul><h3 id="单例"><a class="docs-heading-anchor" href="#单例">单例</a><a id="单例-1"></a><a class="docs-heading-anchor-permalink" href="#单例" title="Permalink"></a></h3><p>当类型定义中没有变量时，实例化时只会为该类型创建唯一一个对象。这样的对象称为<strong>单例</strong>。上面创建的值类型就是一个单例，因为该类型内不包含任何变量。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; MyVal(1) === MyVal(1)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; MyVal(1) === MyVal(2)</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><p><code>MyVal{1}</code>与<code>MyVal{2}</code>是不同的类型。因此，由初始化创建的对象是两个不同的对象。Julia虽然可以使用值参数，但它可能不是性能最优的方法。Julia内置提供了符合以上所有原则的<code>Val{N}</code>类型，我们将在Julia的性能管理一章中进一步讨论这个问题。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>不仅整数类型，即使符号也可以用作值类型参数。</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; MyVal(:a)</code><code class="nohighlight hljs ansi" style="display:block;">Main.MyVal{:a}()</code></pre><h2 id="范围"><a class="docs-heading-anchor" href="#范围">范围</a><a id="范围-1"></a><a class="docs-heading-anchor-permalink" href="#范围" title="Permalink"></a></h2><p>有时我们需要增大或减小的具有连续或固定步长的数字。这称为<strong>范围</strong>。下面是一些例子：</p><h3 id="UnitRange"><a class="docs-heading-anchor" href="#UnitRange">UnitRange</a><a id="UnitRange-1"></a><a class="docs-heading-anchor-permalink" href="#UnitRange" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a=1:5</code><code class="nohighlight hljs ansi" style="display:block;">1:5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">UnitRange{Int64}</code></pre><p><code>a</code>是一个<code>UnitRange</code>，这意味着它包含从1到5的所有自然数。<code>UnitRange</code>的增量步长总是1。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; for i=a
           println(i)
       end</code><code class="nohighlight hljs ansi" style="display:block;">1
2
3
4
5</code></pre><h3 id="StepRange"><a class="docs-heading-anchor" href="#StepRange">StepRange</a><a id="StepRange-1"></a><a class="docs-heading-anchor-permalink" href="#StepRange" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; b=1:2:5</code><code class="nohighlight hljs ansi" style="display:block;">1:2:5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(b)</code><code class="nohighlight hljs ansi" style="display:block;">StepRange{Int64, Int64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for i=b
           println(i)
       end</code><code class="nohighlight hljs ansi" style="display:block;">1
3
5</code></pre><p><code>b</code>是一个间隔为2的<code>StepRange</code>。</p><h3 id="降序范围"><a class="docs-heading-anchor" href="#降序范围">降序范围</a><a id="降序范围-1"></a><a class="docs-heading-anchor-permalink" href="#降序范围" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; c=5:-1:1</code><code class="nohighlight hljs ansi" style="display:block;">5:-1:1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(c)</code><code class="nohighlight hljs ansi" style="display:block;">StepRange{Int64, Int64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for i=c
           println(i)
       end</code><code class="nohighlight hljs ansi" style="display:block;">5
4
3
2
1</code></pre><p><code>c</code>是步长为-1的<code>StepRange</code>。所以在迭代时，我们按5到1的递减顺序输出。</p><p>范围用于迭代、索引和初始化集。它们可以有更复杂的参数，也可以将浮点数用于初始值、步长和最终值。下面给出一个浮点数范围的例子。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; d=1:2.1:6.0</code><code class="nohighlight hljs ansi" style="display:block;">1.0:2.1:5.2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(d)</code><code class="nohighlight hljs ansi" style="display:block;">StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}</code></pre><h2 id="数组"><a class="docs-heading-anchor" href="#数组">数组</a><a id="数组-1"></a><a class="docs-heading-anchor-permalink" href="#数组" title="Permalink"></a></h2><p>数组可以被看作是将对象作为容器保存的具有特定类型的连续内存地址。它们可以通过索引和迭代访问。与元组不同，数组是可变的。可以添加、删除或修改数组中的元素。甚至其他数据结构(如队列和堆栈)也可以使用数组作为容器来实现。本节将介绍数组的基础知识。</p><p>数组表示为<code>Array{T, N}</code>，其中<code>T</code>为类型，<code>N</code>为维数。<code>Array{T, 1}</code>或一维数组的别名为<code>Vector</code>，<code>Array{T, 2}</code>的别名为<code>Matrix</code>。这两者在科学计算中都有特殊的意义。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = [1, 2, 3]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 1
 2
 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = [1 2 3]</code><code class="nohighlight hljs ansi" style="display:block;">1×3 Matrix{Int64}:
 1  2  3</code></pre><p>v是一个<code>Vector{Int64}</code>或<code>Array{Int64,1}</code>。类似地，<code>m</code>是一个<code>Matrix{Int64}</code>或<code>Array{Int64, 2}</code>。多维数组可以在方括号([])内使用空格(<code></code>)分隔列和分号(<code>;</code>)分隔行而形成。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m1 = [1 2 3; 4 5 6]</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Int64}:
 1  2  3
 4  5  6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m2 = [1 2; 3 4; 5 6]</code><code class="nohighlight hljs ansi" style="display:block;">3×2 Matrix{Int64}:
 1  2
 3  4
 5  6</code></pre><p>可以看出，分号(<code>;</code>)在定义中充当行分隔符。</p><h3 id="内存布局和索引"><a class="docs-heading-anchor" href="#内存布局和索引">内存布局和索引</a><a id="内存布局和索引-1"></a><a class="docs-heading-anchor-permalink" href="#内存布局和索引" title="Permalink"></a></h3><p>数组成员可以通过索引访问。下面是使用前面定义的矩阵<code>m1</code>和<code>m2</code>的一些例子：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m1[1, 2]</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m1[2, 2]</code><code class="nohighlight hljs ansi" style="display:block;">5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m2[1, 2]</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m2[2, 2]</code><code class="nohighlight hljs ansi" style="display:block;">4</code></pre><p>因此，数组成员的访问方式为：<code>array[row_index, column_index]</code>。</p><p>数组中的数据存储为分配给某个位置的连续内存块。索引根据索引值指向数组的特定位置。下图显示了<code>m1</code>和<code>m2</code>的内存布局：</p><p><img src="../pictures/arraylayout.png" alt="arraylayout"/></p><p>与C/C++中数据在这两种情况下都存储为1、2、3、4、5和6不同，Julia中的顺序与FORTRAN一样，以行为主顺序存储数据。这本质上意味着数据的存储方式是将一列中各行的所有元素都挨在一起，然后是下一列。这对于经常使用C/C++或Python编程的人来说，可能会有点不习惯。其次，Julia中的索引与FORTRAN一样从1开始，而不是0。</p><h3 id="分页的效果"><a class="docs-heading-anchor" href="#分页的效果">分页的效果</a><a id="分页的效果-1"></a><a class="docs-heading-anchor-permalink" href="#分页的效果" title="Permalink"></a></h3><p>内部循环增加行号，外部循环增加列号这种内存分页，对于小数组可能无关紧要，但对于非常大的数组会有很多好处。在多维数组中，右边的维度必然构成外部循环，左边的维度必然指定为内部循环。推荐的伪码如下：</p><pre><code class="nohighlight hljs">for col=1:100000
    for row=1:1000
        do_something(m[row, col])
    end
end</code></pre><h3 id="构造函数"><a class="docs-heading-anchor" href="#构造函数">构造函数</a><a id="构造函数-1"></a><a class="docs-heading-anchor-permalink" href="#构造函数" title="Permalink"></a></h3><p>下面是一些构造函数的示例：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Array{Int}(undef, 1, 2)</code><code class="nohighlight hljs ansi" style="display:block;">1×2 Matrix{Int64}:
 -4426670745849954304  139984303357540</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Array{Int}(undef, 2)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 139985526378864
 139985526411360</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Array{Int, 2}(undef, (2, 3))</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Int64}:
               0  0  139981574111232
 139981574111232  0                0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Array{Float32}(undef, (2, 3))</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Float32}:
 -1.77533f-17  -1.77535f-17  0.0
  4.5671f-41    4.5671f-41   0.0</code></pre><p><code>undef</code>是一种特殊类型的对象，用于定义包含未定义值的数组。Julia通常是在实例化对象时对它们进行初始化的。数组是一种容器类型，有时需要在内部值还未知时就定义它们。数组的一般构造函数是<code>Array{T,N}(undef, dims)</code>，其中<code>dims</code>是一个大小为<code>N</code>的元组或一个有<code>N</code>个值的可变参数。在类型参数中指定N是可选的，人们也可以调用函数<code>Array{T} (undef, dims)</code>。</p><p>对于<code>Array{T,N}</code>，当<code>T</code>是<code>isbits</code>类型时，数组被完全分配为未初始化的位模式。因此打印的值是不可预测的。例如：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct A
           i::Int
           f::Float64
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = A(1, 1); isbits(a)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; aar = Array{A}(undef,(2, 2))</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Main.A}:
 A(1, 1.0e-323)  A(5, 3.0e-323)
 A(3, 2.0e-323)  A(-1, NaN)</code></pre><p>现在让我们看看以下非位类型数组的场景：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct T
           a::A
           b
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = T(A(1, 1), 1); isbits(b)</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bar = Array{T}(undef, (2, 2))</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Main.T}:
 #undef  #undef
 #undef  #undef</code></pre><p>当<code>isbits</code>为<code>false</code>时，虽然<code>Array</code>被分配为容器，但实际的对象还没被初始化。实际的对象需要在对数组进行适当的初始化时分配。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bar[1, 1] = bar[2, 1] = bar[1, 2] = bar[2, 2] = b</code><code class="nohighlight hljs ansi" style="display:block;">Main.T(Main.A(1, 1.0), 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bar</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Main.T}:
 T(A(1, 1.0), 1)  T(A(1, 1.0), 1)
 T(A(1, 1.0), 1)  T(A(1, 1.0), 1)</code></pre><p>你还可以发现数组的可变特性，元素在数组使用<code>undef</code>值初始化之后可以被赋值。</p><p>就像<code>N</code>维的泛型<code>Array{T,N}</code>一样，<code>Vector{T}</code>和<code>Matrix{T}</code>也可以有类似的构造函数。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Vector{Int}(undef, 3)</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 139984077918576
 139984077848080
 139984067808336</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Matrix{Int}(undef, 3, 3)</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Int64}:
               0                2                3
               1                1                1
 139985305652992  139985305652993  139985305652993</code></pre><p>虽然构造函数是初始化<code>Array</code>的一种方法，但还有其他方便的方法，我们将在下面介绍。</p><h3 id="zeros和ones"><a class="docs-heading-anchor" href="#zeros和ones">zeros和ones</a><a id="zeros和ones-1"></a><a class="docs-heading-anchor-permalink" href="#zeros和ones" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; zeros(Float32, (2, 3))</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Float32}:
 0.0  0.0  0.0
 0.0  0.0  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ones(Float32, (2, 3))</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{Float32}:
 1.0  1.0  1.0
 1.0  1.0  1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ones(UInt8, (2, 3))</code><code class="nohighlight hljs ansi" style="display:block;">2×3 Matrix{UInt8}:
 0x01  0x01  0x01
 0x01  0x01  0x01</code></pre><p>给定类型和维数，该函数创建一个数组，以指定的类型填充0或1。</p><h3 id="trues和falses"><a class="docs-heading-anchor" href="#trues和falses">trues和falses</a><a id="trues和falses-1"></a><a class="docs-heading-anchor-permalink" href="#trues和falses" title="Permalink"></a></h3><p>让我们看看下面的两段代码：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; zb = zeros(Bool, (8, 8))</code><code class="nohighlight hljs ansi" style="display:block;">8×8 Matrix{Bool}:
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sizeof(zb)</code><code class="nohighlight hljs ansi" style="display:block;">64</code></pre><p>可以看到，<code>Bool</code>变量占用一个字节的存储空间，而这个数组需要64个字节的数据。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; z = falses(8, 8)</code><code class="nohighlight hljs ansi" style="display:block;">8×8 BitMatrix:
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sizeof(z)</code><code class="nohighlight hljs ansi" style="display:block;">8</code></pre><p>因为所有的元素都用一个位表示，<code>z</code>的大小只有8个字节(64位)，它创建了一个<code>BitArray</code>，而不是<code>Array</code>。因为使用一个位来存储一个字节的信息，当元素为布尔值时，<code>BitArray</code>是一种高效的数组存储方式。与<code>falses</code>类似，<code>trues(dims)</code>用<code>true</code>位值初始化<code>BitArray</code>。</p><h3 id="fill和similar"><a class="docs-heading-anchor" href="#fill和similar">fill和similar</a><a id="fill和similar-1"></a><a class="docs-heading-anchor-permalink" href="#fill和similar" title="Permalink"></a></h3><p><code>fill(val, dims)</code>创建一个值为<code>val</code>的数组。数组的类型取决于值<code>val</code>的类型。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = fill(5.0, (2, 2))</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 5.0  5.0
 5.0  5.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = fill(5, (2, 2))</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Int64}:
 5  5
 5  5</code></pre><p><code>similar(a, elem_type, dims)</code>通过使用数组<code>a</code>的元素默认类型和/或<code>dims</code>尺寸，创建一个未初始化的<code>elem_type</code>数组。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = similar(a, Int)</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Int64}:
 139984082098208  139984082098448
 139984076635888  139984092657360</code></pre><h3 id="collect"><a class="docs-heading-anchor" href="#collect">collect</a><a id="collect-1"></a><a class="docs-heading-anchor-permalink" href="#collect" title="Permalink"></a></h3><p><code>collect(elem_type, collection)</code>是一个从数据集创建数组的实用方法。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(1:3)</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 1
 2
 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(Float64, 1:2:3)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 1.0
 3.0</code></pre><h3 id="reshape"><a class="docs-heading-anchor" href="#reshape">reshape</a><a id="reshape-1"></a><a class="docs-heading-anchor-permalink" href="#reshape" title="Permalink"></a></h3><p>数组在内存中是线性连续分配的，索引以行为主的格式指向它们。<code>reshape</code>是创建数组的另一种方便的方法。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = collect(1:16)</code><code class="nohighlight hljs ansi" style="display:block;">16-element Vector{Int64}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = reshape(a, (4, 4))</code><code class="nohighlight hljs ansi" style="display:block;">4×4 Matrix{Int64}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c = reshape(b, (2, 8))</code><code class="nohighlight hljs ansi" style="display:block;">2×8 Matrix{Int64}:
 1  3  5  7   9  11  13  15
 2  4  6  8  10  12  14  16</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = reshape(c, (8, 2))</code><code class="nohighlight hljs ansi" style="display:block;">8×2 Matrix{Int64}:
 1   9
 2  10
 3  11
 4  12
 5  13
 6  14
 7  15
 8  16</code></pre><p>虽然数组的形状改变了，但以行为主的数据排序仍然保持。</p><h3 id="hcat,-vcat,-hvcat"><a class="docs-heading-anchor" href="#hcat,-vcat,-hvcat">hcat, vcat, hvcat</a><a id="hcat,-vcat,-hvcat-1"></a><a class="docs-heading-anchor-permalink" href="#hcat,-vcat,-hvcat" title="Permalink"></a></h3><p>这些方法将输入数组组合起来创建一个新的数组对象。<code>vcat</code>创建一个数组，其中输入数组沿着维度1放置。在一组矩阵上，其效果是数组一个接一个地向下放置。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; vcat([1 2; 3 4], [5 6; 7 8], [9 10; 11 12])</code><code class="nohighlight hljs ansi" style="display:block;">6×2 Matrix{Int64}:
  1   2
  3   4
  5   6
  7   8
  9  10
 11  12</code></pre><p><code>hcat</code>创建一个数组，其中输入数组沿着维度2放置。在一组矩阵上，其效果是数组一个接一个地向右放置。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; hcat([1 2; 3 4], [5 6; 7 8], [9 10; 11 12])</code><code class="nohighlight hljs ansi" style="display:block;">2×6 Matrix{Int64}:
 1  2  5  6   9  10
 3  4  7  8  11  12</code></pre><p><code>hvcat(rows::Tuple{Int}, arrays...)</code>通过使用在第一个参数中给出的<code>rows</code>元组数据来指定每行中连接的参数个数，这样形成的行一个接一个地堆叠起来，形成最终的数组。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; hvcat((2, 2, 2), [1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12])</code><code class="nohighlight hljs ansi" style="display:block;">6×2 Matrix{Int64}:
  1   3
  2   4
  5   7
  6   8
  9  11
 10  12</code></pre><p>在前面的例子中，向量以2个为一组并排放置。这样就产生了3个中间矩阵。它们是：</p><p class="math-container">\[\begin{bmatrix}
1 &amp; 3 \\
2 &amp; 4
\end{bmatrix}, 
\begin{bmatrix}
5 &amp; 7 \\
6 &amp; 8
\end{bmatrix}和
\begin{bmatrix}
9 &amp; 11 \\
10 &amp; 12
\end{bmatrix}\]</p><p>现在，把它们一个叠一个，就得到了最终的输出。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; hvcat(6, [1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12])</code><code class="nohighlight hljs ansi" style="display:block;">2×6 Matrix{Int64}:
 1  3  5  7   9  11
 2  4  6  8  10  12</code></pre><p>同样，在上面的例子中，将6个向量相邻放置，形成一个矩阵。</p><h2 id="关联集"><a class="docs-heading-anchor" href="#关联集">关联集</a><a id="关联集-1"></a><a class="docs-heading-anchor-permalink" href="#关联集" title="Permalink"></a></h2><p>在关联集中，集的元素以键/值对的形式存储。可以通过索引键或对键进行高效搜索来访问这些值。常用的有字典、多维字典、集合(尽管集合只保留键而忽略值)。大多数关联集都派生自抽象类型<code>AbstractDict{K, V}</code>。</p><h3 id="字典"><a class="docs-heading-anchor" href="#字典">字典</a><a id="字典-1"></a><a class="docs-heading-anchor-permalink" href="#字典" title="Permalink"></a></h3><p><code>Dict{K,V}</code>是Julia中一个相对简单的关联集。参数<code>K</code>指定键的类型，<code>V</code>指定值的类型。唯一的要求是必须为类型<code>K</code>定义一个哈希函数。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;c&quot;=&gt;2, &quot;b&quot;=&gt;3)</code><code class="nohighlight hljs ansi" style="display:block;">Dict{String, Int64} with 3 entries:
  &quot;c&quot; =&gt; 2
  &quot;b&quot; =&gt; 3
  &quot;a&quot; =&gt; 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d[&quot;b&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d[&quot;a&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; println(d)</code><code class="nohighlight hljs ansi" style="display:block;">Dict(&quot;c&quot; =&gt; 2, &quot;b&quot; =&gt; 3, &quot;a&quot; =&gt; 1)</code></pre><p><code>Dict{K,V}</code>不能为同一个键保存多个值。定义中重复的键将覆盖先前定义的值。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;c&quot;=&gt;2, &quot;b&quot;=&gt;3, &quot;a&quot;=&gt;4)</code><code class="nohighlight hljs ansi" style="display:block;">Dict{String, Int64} with 3 entries:
  &quot;c&quot; =&gt; 2
  &quot;b&quot; =&gt; 3
  &quot;a&quot; =&gt; 4</code></pre><h3 id="get方法"><a class="docs-heading-anchor" href="#get方法">get方法</a><a id="get方法-1"></a><a class="docs-heading-anchor-permalink" href="#get方法" title="Permalink"></a></h3><p><code>get(dict, key, defval)</code>方法用于从字典对象中提取信息。下面是一些例子：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get(d, &quot;a&quot;, 3)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; get(d, &quot;e&quot;, 0)</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>当该键是字典的一部分时，将返回与该键相关联的值。然而，当该键不存在时，将返回函数中指定的默认值。</p><p>大多数情况下，<code>Dict{K,V}</code>对象可以像数组一样使用，只不过索引是键。使用<code>getindex</code>或它的别名(<code>[]</code>)从字典中获取值。与<code>get</code>方法不同的是，当在字典中找不到键时，<code>getindex</code>会抛出一个错误异常。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; getindex(d, &quot;e&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: KeyError: key &quot;e&quot; not found</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; getindex(d, &quot;a&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d[&quot;e&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: KeyError: key &quot;e&quot; not found</code></pre><p><code>get!(dict, key, value)</code>方法类似于<code>get(dict, key, defval)</code>方法，但是会在字典中键不可用的位置插入键值对。在前面的例子中：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; get!(d, &quot;a&quot;, 0)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; get!(d, &quot;e&quot;, 0)</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d</code><code class="nohighlight hljs ansi" style="display:block;">Dict{String, Int64} with 4 entries:
  &quot;c&quot; =&gt; 2
  &quot;e&quot; =&gt; 0
  &quot;b&quot; =&gt; 3
  &quot;a&quot; =&gt; 4</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>在Julia中，通常的惯例是在函数名的末尾添加一个叹号(!)字符来表示要改变函数的参数值。由于<code>get!(dict, key, value)</code>方法更改对象字典, 叹号字符被添加到末尾。</p></div></div><h3 id="setindex!方法"><a class="docs-heading-anchor" href="#setindex!方法">setindex!方法</a><a id="setindex!方法-1"></a><a class="docs-heading-anchor-permalink" href="#setindex!方法" title="Permalink"></a></h3><p>与get方法类似，<code>setindex!</code>方法或其别名(<code>[]</code>)用作给左侧元素赋值。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; d[&quot;e&quot;] = 10</code><code class="nohighlight hljs ansi" style="display:block;">10</code></pre><p>或比较不常用的用法：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; setindex!(d, 11, &quot;e&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">Dict{String, Int64} with 4 entries:
  &quot;c&quot; =&gt; 2
  &quot;e&quot; =&gt; 11
  &quot;b&quot; =&gt; 3
  &quot;a&quot; =&gt; 4</code></pre><h3 id="哈希化"><a class="docs-heading-anchor" href="#哈希化">哈希化</a><a id="哈希化-1"></a><a class="docs-heading-anchor-permalink" href="#哈希化" title="Permalink"></a></h3><p>要使<code>Dict{K,V}</code>正常工作，需要实现<code>hash(k::K, h::Int)</code>。对于<code>k</code>的每个实例，函数返回一个唯一的整数。这种唯一性确保在<code>Dict{k,V}</code>中只存储一个键。</p><h2 id="集合"><a class="docs-heading-anchor" href="#集合">集合</a><a id="集合-1"></a><a class="docs-heading-anchor-permalink" href="#集合" title="Permalink"></a></h2><p><code>Set</code>是一个集，其中每个元素只能保留一个实例。集合中元素的顺序不重要。下面的示例给出了一些集合方法。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = Set([2 3 4 5 1 2 3])</code><code class="nohighlight hljs ansi" style="display:block;">Set{Int64} with 5 elements:
  5
  4
  2
  3
  1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 6 in s</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 5 in s</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = Set([4 5 7 8 9])</code><code class="nohighlight hljs ansi" style="display:block;">Set{Int64} with 5 elements:
  5
  4
  7
  9
  8</code></pre><h3 id="并和交"><a class="docs-heading-anchor" href="#并和交">并和交</a><a id="并和交-1"></a><a class="docs-heading-anchor-permalink" href="#并和交" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; union(s, t)</code><code class="nohighlight hljs ansi" style="display:block;">Set{Int64} with 8 elements:
  5
  4
  7
  2
  9
  8
  3
  1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; intersect(s, t)</code><code class="nohighlight hljs ansi" style="display:block;">Set{Int64} with 2 elements:
  5
  4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; union!(s, t)</code><code class="nohighlight hljs ansi" style="display:block;">Set{Int64} with 8 elements:
  5
  4
  7
  2
  9
  8
  3
  1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s</code><code class="nohighlight hljs ansi" style="display:block;">Set{Int64} with 8 elements:
  5
  4
  7
  2
  9
  8
  3
  1</code></pre><p><code>union!</code>类似于<code>union</code>，但会更新第一个参数。类似于<code>union</code>，<code>symdiff</code>和<code>setdiff</code>方法被定义为对称差和集合差。<code>issubset</code>方法提供判断一个集合与另一个集合的子集关系。</p><h2 id="迭代"><a class="docs-heading-anchor" href="#迭代">迭代</a><a id="迭代-1"></a><a class="docs-heading-anchor-permalink" href="#迭代" title="Permalink"></a></h2><p>迭代是集的基本操作之一。我们将介绍如何在集中使用各种迭代操作。</p><h3 id="for循环"><a class="docs-heading-anchor" href="#for循环">for循环</a><a id="for循环-1"></a><a class="docs-heading-anchor-permalink" href="#for循环" title="Permalink"></a></h3><p>Julia中经典的for循环是将一个索引变量映射到一个范围对象并遍历它。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; for i=5:-2:1
           println(i)
       end</code><code class="nohighlight hljs ansi" style="display:block;">5
3
1</code></pre><p>循环不仅仅局限于范围对象。也可以使用其他类型的集。下面是一些例子：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = [1.0 2 3; 4 5 6; 7 8 9];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for i=b
           println(i)
       end</code><code class="nohighlight hljs ansi" style="display:block;">1.0
4.0
7.0
2.0
5.0
8.0
3.0
6.0
9.0</code></pre><p>除了<code>for...=</code>以外，<code>for...in</code>也可以被使用。for循环的这种表示与前面类似，只是语法看起来更适合于集。让我们看看它在字典对象上的用法。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; for p in d
           println(p)
       end</code><code class="nohighlight hljs ansi" style="display:block;">&quot;c&quot; =&gt; 2
&quot;e&quot; =&gt; 11
&quot;b&quot; =&gt; 3
&quot;a&quot; =&gt; 4</code></pre><p><code>Dict{K,V}</code>元素存储为<code>Pair{K,V}</code>，并默认打印为：K =&gt; V。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; for (k, v) in d
           println(&quot;Key: &quot;, k, &quot; Value: &quot;, v)
       end</code><code class="nohighlight hljs ansi" style="display:block;">Key: c Value: 2
Key: e Value: 11
Key: b Value: 3
Key: a Value: 4</code></pre><h3 id="function...do"><a class="docs-heading-anchor" href="#function...do">function...do</a><a id="function...do-1"></a><a class="docs-heading-anchor-permalink" href="#function...do" title="Permalink"></a></h3><p>让我们来看一个函数，它以数组作为输入，并以数组的形式返回所有值的平方。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function collect_square(v)
           a = similar(v)
           for i=1:length(v)
               a[i] = v[i]*v[i]
           end
           return a
       end</code><code class="nohighlight hljs ansi" style="display:block;">collect_square (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect_square(1:4)</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Int64}:
  1
  4
  9
 16</code></pre><p>如果我们要扩展这个函数，使其在计算任意函数而不仅仅是平方后返回值，我们可以按以下方式扩展它：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function collect_function(f::Function, v)
           a = similar(v)
           for i=1:length(v)
               a[i] = f(v[i])
           end
           return a
       end</code><code class="nohighlight hljs ansi" style="display:block;">collect_function (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect_function(x-&gt;x^3, 1:4)</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Int64}:
  1
  8
 27
 64</code></pre><p>另一种调用相同方法的方式是使用<code>function...do</code>符号。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect_function(1:4) do x
           return x^3
       end</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Int64}:
  1
  8
 27
 64</code></pre><p><code>map</code>是一个具有类似符号的函数。它将集元素的每个值映射给函数，并将函数求值的结果作为集返回。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; map(1:4) do x
           return x^3
       end</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Int64}:
  1
  8
 27
 64</code></pre><h3 id="迭代框架"><a class="docs-heading-anchor" href="#迭代框架">迭代框架</a><a id="迭代框架-1"></a><a class="docs-heading-anchor-permalink" href="#迭代框架" title="Permalink"></a></h3><p>我们看到了几个使用for循环遍历序列和集的例子。这实际上是通过完成迭代框架实现的。如果要编写自定义的迭代器，就需要实现这个框架。下面介绍了一些基本的思想。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = collect(3:2:10);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for i=v
           println(i)
       end</code><code class="nohighlight hljs ansi" style="display:block;">3
5
7
9</code></pre><p>同样的可以写成以下形式：</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; next = iterate(v)</code><code class="nohighlight hljs ansi" style="display:block;">(3, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; while next !== nothing
           value, state = next
           println(value)
           next = iterate(v, state)
       end</code><code class="nohighlight hljs ansi" style="display:block;">3
5
7
9</code></pre><h3 id="迭代方法"><a class="docs-heading-anchor" href="#迭代方法">迭代方法</a><a id="迭代方法-1"></a><a class="docs-heading-anchor-permalink" href="#迭代方法" title="Permalink"></a></h3><p><code>iterate(collection)</code>返回第一个元素和初始状态，如果不存在值则返回<code>nothing</code>。</p><p>在前面示例的返回值(3,2)中，3是第一个元素的值，2是表示状态的内部参数。尽管它看起来像是下一个值的索引，但我们不应该有这种假设，因为它完全是由特定的实现来定义的。</p><p><code>iterate(collection，state)</code>返回下一个元素和状态，如果不存在额外的元素则返回<code>nothing</code>。</p><p>必须为所有的迭代器类型实现迭代方法。</p><h3 id="可选方法"><a class="docs-heading-anchor" href="#可选方法">可选方法</a><a id="可选方法-1"></a><a class="docs-heading-anchor-permalink" href="#可选方法" title="Permalink"></a></h3><p>这些方法需要由迭代器作者选择性地定义。</p><p><code>IteratorSize(IterType)</code>是一个辅助方法，它表明迭代器是否具有长度或形状。基于此确定必须为集迭代器定义尺寸或/和长度方法。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.IteratorSize(Vector{Int})</code><code class="nohighlight hljs ansi" style="display:block;">Base.HasShape{1}()</code></pre><p><code>IteratorEltype(IterType)</code>是一个辅助方法，它决定迭代器是否具有特定的元素类型。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.IteratorEltype(Vector{Int})</code><code class="nohighlight hljs ansi" style="display:block;">Base.HasEltype()</code></pre><p><code>eltype(IterType)</code>返回迭代方法第一个参数的类型。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; eltype(Vector{Int})</code><code class="nohighlight hljs ansi" style="display:block;">Int64</code></pre><h3 id="实例"><a class="docs-heading-anchor" href="#实例">实例</a><a id="实例-1"></a><a class="docs-heading-anchor-permalink" href="#实例" title="Permalink"></a></h3><p>我们创建一个<code>Squares</code>类型，它将提供一组直到类型中存储值为止的数字的平方序列。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Squares
           value::Int
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.iterate(s::Squares) = s.value &lt;= 0 ? nothing : (1, 2)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.iterate(s::Squares, state) = s.value &lt; state ? nothing : (state*state, state+1)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for i=Squares(3)
           println(i)
       end</code><code class="nohighlight hljs ansi" style="display:block;">1
4
9</code></pre><p>上面的例子只适用于简单的for循环。使用<code>collect</code>方法创建数组还无法工作。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(Squares(3))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching length(::Main.Squares)
Closest candidates are:
  length(!Matched::Union{Base.KeySet, Base.ValueIterator}) at /usr/share/julia/base/abstractdict.jl:58
  length(!Matched::Union{LinearAlgebra.Adjoint{T, S}, LinearAlgebra.Transpose{T, S}} where {T, S}) at /usr/share/julia/stdlib/v1.7/LinearAlgebra/src/adjtrans.jl:171
  length(!Matched::Base.Generator) at /usr/share/julia/base/generator.jl:50
  ...</code></pre><p>所以我们添加一个<code>length</code>方法来实现这个目的。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.length(s::Squares)=s.value</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(Squares(3))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Any}:
 1
 4
 9</code></pre><p>数组可以被正确填充，但类型是<code>Any</code>。定义<code>eltype(IteratorType)</code>方法将确保创建正确的数组类型。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.eltype(::Type{Squares}) = Int</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eltype(Squares)</code><code class="nohighlight hljs ansi" style="display:block;">Int64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(Squares(3))</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 1
 4
 9</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>Type{Squares}</code>是一种特殊类型，它的唯一实例对象是<code>Squares</code>。这是必需的，因为<code>eltype</code>是该类型本身而不是该类型实例的函数。</p></div></div><h2 id="生成器和推导"><a class="docs-heading-anchor" href="#生成器和推导">生成器和推导</a><a id="生成器和推导-1"></a><a class="docs-heading-anchor-permalink" href="#生成器和推导" title="Permalink"></a></h2><p>在Julia中，数组和集在科学计算中被广泛使用。语言必须提供创建和操作数组的方便途径。推导表示为创建这样的数组提供了便利。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [i*i for i=1:3]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Int64}:
 1
 4
 9</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; [i*j for i=1:3, j=1:3]</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Int64}:
 1  2  3
 2  4  6
 3  6  9</code></pre><p>在前面的示例中，推导式用于创建单维和多维数组。下面是一个索引可能依赖于另一个索引的示例。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [i*j for i=1:3 for j=i:3]</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{Int64}:
 1
 2
 3
 4
 6
 9</code></pre><p>推导式计算完整的数组。有时也需要使用称为<strong>生成器</strong>的延迟执行迭代器(在需要时计算值，而不是所有元素)。</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; gen=(i*j for i=1:3 for j=i:3)</code><code class="nohighlight hljs ansi" style="display:block;">Base.Iterators.Flatten{Base.Generator{UnitRange{Int64}, Main.var&quot;#2#3&quot;}}(Base.Generator{UnitRange{Int64}, Main.var&quot;#2#3&quot;}(Main.var&quot;#2#3&quot;(), 1:3))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for v=gen
           println(v)
       end</code><code class="nohighlight hljs ansi" style="display:block;">1
2
3
4
6
9</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ch05scope/">« 变量的作用域</a><a class="docs-footer-nextpage" href="../ch07array/">数组 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 31 December 2021 10:09">Friday 31 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
