var documenterSearchIndex = {"docs":
[{"location":"ch08string/#字符串","page":"字符串","title":"字符串","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"文本是当今计算中最常用的数据类型之一。文本可以表示特定自然语言中的特定表达式(如英语中的句子)，任意字符的二进制转储(如二进制字节数组)，表达式的多语言表示(其中句子可能包含来自另一种语言的单词)。我们将介绍在Julia中文本是如何表现的。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"一个句子可能包含来自多种语言的符号和字符。例如，英语句子中的数学符号和希腊表达式。最后，文本通常被用作除了使用文本关键字外没有其他方法表示实体的最后手段。对于这种情况，虽然经常使用Julia符号，但是文本也是可以的。本章将对前面所讨论的各个方面作一些详细的探讨。文本使用的多样性带来了许多表示方面的挑战，我们必须从概念上理解Julia语言的设计。虽然文本的结构可能会涉及文档结构和表示的复杂性，但我们将把讨论的范围限制在字符串的概念上。","category":"page"},{"location":"ch08string/#字符串-2","page":"字符串","title":"字符串","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"字符串是作为文本表示的字符的集合。虽然它们在特定语言中可能是有意义的句子，但它们可以是完全没有意义的字符的集合。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"This is a valid sentence.","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"Abccnajkvnkavnak","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"前面两行都是有效的字符串，但在英语中不都是有效的句子。","category":"page"},{"location":"ch08string/#字符","page":"字符串","title":"字符","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"一组字符组成一个字符串。在前面的例子中：","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"[' ', 'T', 'a', 'c', 'd', ‘e’, ‘h’, ‘i’, ‘l’, ‘n’, ‘s’, ‘t’, 'v']字符组成句子 This is a valid sentence。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"字符在集中的顺序和位置也很重要。","category":"page"},{"location":"ch08string/#编码","page":"字符串","title":"编码","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"我们平时书写的字符对计算机来说没有任何意义。在计算机中，每个实体都被表示为一个数值或数值的等价二进制值。这样的数字被称为编码。在使用美国信息交换标准码(ASCII)作为编码方案的计算机中，字符a被表示为编码值97或0x61。ASCII只是表示英语字符集编码中的一种。另外一种是扩展二进制编码的十进制交换码(EBCDIC)，它曾是IBM大型机的首选，但现在不再流行了。在开始研究文本的Julia语言结构之前，我们将从概念上讨论一些编码（在深入研究一些具体编码之前，先进行一些理论理解）。这个介绍不完全按照时间的先后顺序，因为我们的重点是获得一种直观的理解。","category":"page"},{"location":"ch08string/#ASCII","page":"字符串","title":"ASCII","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"7位字符表示法，目的是表示所有可打印英语字符，以及一些用于设备间通信(如串行或并行通信通道)的非打印字符。ASCII的设计方式是在特定范围内将大写字母和小写字母分组；类似地，所有数字也都分组在一个范围内。这使得编程和识别字符更加容易，这一点是EBCDIC所欠缺的。与此同时，由于字节已经成为微处理器中的计算单元，这使得最左边的1个自由位可以容纳额外的128个字符。美国国家标准协会(ANSI)考虑了常用的非英语字符，并试图将其中的128个字符作为ANSI字符代码。微软和苹果这样的操作系统供应商也提出了他们自己的字符编码，如Windows-1252编码或Mac Roman编码，等等。它们基本上都支持从0到127的字符代码的一般ASCII规范，但为了方便起见，它们为从128到255的每个字符代码添加了各自的字符集。这导致了在不同操作系统和设备上显示和转换文档时的“编码战争”。业界中使用的术语“高位ASCII”或“扩展ASCII”，本质上是字符码128-255在不同标准之间的变化。","category":"page"},{"location":"ch08string/#ISO-8859","page":"字符串","title":"ISO-8859","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"ISO-8859是一组编码，包含1-16个代码页，每个代码页代表可以一起表示的一类欧洲语言——有时也称为Latin-1、Latin-2等编码。所有这些代码页都有0-127支持基本ASCII字符，而128-255可能支持一类特殊的欧洲区域语言，如西里尔语、波罗的海语等。这种安排确保了在计算机中轻松地支持欧洲语言。通常，多语言文档或屏幕会使用某种形式的代码页切换命令，并从新代码页中拾取切换的字符编码。当然，它的优点是所有字符串都可以表示为8位值的二进制转储。","category":"page"},{"location":"ch08string/#'C'编码","page":"字符串","title":"'C'编码","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"‘C’语言是在20世纪70年代末引入的，它使用了非常简单的文本范式。任何二进制8位字节数组都是字符串。数组的最后一个字节必须以字符码(0)或NULL结束。这个概念被称为NULL终止字符串或c字符串，它确保了代码解释保持在字符串操作之外。C语言本身在实现字符串方法时完全忽略了语言内部的编码解释，并期望程序员在他们正在开发的应用程序或系统中处理它。由于缺乏更好的术语，一些计算机系统，如GNU Linux，将其称为C编码。在UNIX等系统中，C编码是系统的默认编码。","category":"page"},{"location":"ch08string/#Unicode","page":"字符串","title":"Unicode","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"随着计算机的普及，人们越来越清楚地认识到计算不能再局限于一个特定的区域。其次，数据交换还要求数据能够在任何可用的计算系统中显示。第三，因为计算机中可用的存储和内存都变得便宜了，所以表示文本所需的内存可以增加到超过一个字节。不需要再对字符进行单字节限制。一群计算机科学家和来自不同组织和学术机构的语言学家聚集在一个Unicode联盟组织下，提出了通用编码字符集(UCS)。1991年引入的第一组字符集大约有7000个字符，由称为UCS-2的2字节字符表示。很快，随着更多的语言加入到规范中，字符开始增长。这时在一个称为UCS-4的表示中为每个字符分配4个字节。实际上，Unicode规范定义了16个大小为65536(2^16)的代码平面，其中实际使用的值很少。从技术上讲，32位中只有20位真正用于实际目的。然而，许多计算机系统继续在操作系统中实现宽字符，Windows开发了一个本地16位操作系统Windows NT，并停止了旧的Windows 95代码基。在上世纪90年代末和新千年前期，需要使用宏分别编译8位和16位版本的代码。","category":"page"},{"location":"ch08string/#Unicode转换","page":"字符串","title":"Unicode转换","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"世界上的一部分人正忙于重写操作系统核心以支持宽字符。甚至一些unix派生系统也有4字节实现的宽字符。Ken Thompson提出了重用c编码作为Unicode字符基础的想法。但是，c编码或c字符串不能被用作整个字节的数据被设置为NULL的UCS-2和UCS-4，因为在c语言中，字符串终止字符被定义为0。例如，字符'a'的UCS-2代码是U+0061，其前导字节为0。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"他希望Unicode字符的表示方式是这样的：","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"ASCII字符在新的编码中仍然有效，这意味着不能对0x00-0x7F范围内的任何字符进行转换。\n对于任何值为128或更高的字符，必须用多字节字符表示。\n新的编码必须有一个前导字节，告诉接下来要读取多少个字节。\n在出现歧义的情况下，应该选择用最少字节数表示的代码。\n用于前导和后置字节的模式必须是这样的，如果有任何违反，它将很容易识别字符序列是损坏的，以便于在即使没有如CRC等任何冗余检查的情况下更容易传输。\n这个方案确保除了实际的NUL字符之外，其他字符的字节都不是零。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"下面是该方案最终的样子：","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"(Image: UTF-8)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"上面的表示称为UTF-8。那21位以外的编码呢？到目前为止，Unicode规范使用的信息不超过21位，但该方案可以容纳多达36位的信息，覆盖整个UCS-4范围。与UTF-8类似，UTF-16考虑将字符代码扩展为每次2字节的字符。此外还有UTF-32转换方案。","category":"page"},{"location":"ch08string/#Julia对Unicode的支持","page":"字符串","title":"Julia对Unicode的支持","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"Julia语言原生支持Unicode，甚至变量和常量也可以使用Unicode字符。Julia字符串(String类型)在内部被存储为UTF-8编码的Unicode字符流。Julia中的字符(Char)被表示为4字节的UTF-8编码。在Julia中，以UInt8表示的原始字节不是Char。然而，作为一种语言，Julia支持用其他编码表示字符串的结构。还可以使用Julia接口开发自己的字符代码和字符串。你可能需要与原生C/C++应用程序交换信息，这可能需要从Julia代码中将字符串信息交换为Cstring。在C语言中，Cstring是一个以零结束的字符串。","category":"page"},{"location":"ch08string/#字体和字形","page":"字符串","title":"字体和字形","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"让我们看看a在不同字体中的表示：","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"(Image: Glyphs a)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"字体和字形提供了字符的视觉外观和感觉。作为一种编程语言，Julia没有提供任何控制字体或字形选择的机制。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"现在我们理解了文本计算的各个方面，让我们看看Julia是如何满足这些需求的。","category":"page"},{"location":"ch08string/#字符串-3","page":"字符串","title":"字符串","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"在Julia中，String对象可以用以下字面表达式进行初始化。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"str = \"This is a string\"","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"字符串是不变的，一旦创建，它们就不能被修改。下面是另一种定义字符串的方法，其保留了格式和新行字符，特殊字符不需要额外的引号。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"str = \"\"\"\n This is a preformatted\n \"string\" \"\"\"","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"字符串可以包含由其他变量计算得到的信息，并纳入最终计算结果。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"a = \"Jack\";\nb = \"Jill\";\nc = \"100\";\nstr = \"$a owes $b $c dollars\"","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"字符串中使用的特殊字符，如引号(\")或反斜杠(\\)需要使用反斜杠(\\)转义。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"str = \"This is a \\\"quoted\\\\ ' string\"","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"note: Note\n字符串是不变的。因此，它们可以驻留在系统内存中，即使在收集垃圾时也不会被覆盖。内存调试器可用于读取随机内存位置。对于像密码这样的敏感数据，你应该考虑使用字节或字符数组结构，并在使用数据后覆盖内存位置。解引用内存对象并强制调用垃圾回收可能不是最安全的选项。","category":"page"},{"location":"ch08string/#字符串方法","page":"字符串","title":"字符串方法","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"我们将介绍一些字符串的标准方法。","category":"page"},{"location":"ch08string/#比较","page":"字符串","title":"比较","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"字符串对象之间可以使用标准比较运算符isequal(==)、isless(<)或大于(>)进行比较。比较通常根据字典顺序。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s1 = \"abc\"\ns2 = \"def\"\ns1 < s2\ns2 > s1\ns1 = \"abc\"\ns2 = \"abc\"\ns1 == s2","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"等同运算符(===)在不同对象之间进行比较，对于不变的字符串对象，则按位进行比较。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s1 === s2","category":"page"},{"location":"ch08string/#迭代","page":"字符串","title":"迭代","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"就像数组和集一样，字符串也是字符序列的自然集。因此，当对字符串进行迭代时，你能够枚举字符。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s = \"Julia\";\nfor c in s\n    println(c)\nend","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"与其他集一样，Julia字符串也支持基于1的索引，并在每个位置上显示字符。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s[1], s[2], s[3], s[4], s[5]","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"begin和end也可以像在其他类型的集中一样使用。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s[begin], s[begin+2], s[end-1], s[end]","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"让我们取一个包含多字节UTF-8字符的字符串。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s = \"\\u2200 x \\u2203 y\"\nlength(s)       # No of characters in the String\nsizeof(s)       # No fo bytes in the String\ns[1]\ns[2]\ns[4]","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"因此，getindex方法将字节索引作为输入，并返回一个有效的字符。但是，当索引没有映射到有效字符时，就会像s[2]中的情况一样抛出异常。但是，for...in循环可对字符进行迭代。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"for c in s\n    println(c)\nend","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"另一种使用索引变量的方式是使用方法nextind。该方法将返回下一个具有有效字符的索引。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"i, l = firstindex(s), lastindex(s);\nwhile i <= l\n    println(s[i])\n    i = nextind(s, i)\nend","category":"page"},{"location":"ch08string/#拆分和连接","page":"字符串","title":"拆分和连接","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"将字符串拆分为子字符串的最简单方法之一是使用索引，连接则使用运算符(*)。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"str = \"This is a String\"\nstr[1:4]\nstr[1:4]*str[end-6:end]","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"由于字符串是不变的，每个子字符串或连接运算都会在它们被连接之前分配中间字符串。可以使用repeat函数或其别名运算符(^)创建文本模式的重复序列。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"repeat(\"A:-\", 5)\n\"A:=\"^4","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"join对输入字符串集进行组合。可以选择提供分隔符如逗号(,)和最后连接词如and。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"join([\"1\", \"2\", \"3\", \"4\", \"5\"])\njoin([\"Jack\", \"Jill\", \"Cathy\", \"Trevor\"], \", \", \" and \")","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"chomp移除字符串中的最后一个行结束符。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"str = \"This is a\\nString\\n\"\nchomp(str)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"chop从头部和尾部删除字符。默认情况下，不从头部删除字符，只从尾部删除一个字符。但是，关键字head和tail可以用来分别指定从头部和尾部删掉打字符数。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"chop(\"October\")\nchop(\"October\", head=2, tail=3)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"split方法根据空格拆分字符串对象并返回一个子字符串对象数组。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s = \"\\u2200 x \\u2203 y\"\nss = split(s)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"字符串对象是不变的，任何提取字符串一部分的表达式都将分配一个新的字符串。子字符串是字符串对象的视图。在前面的示例中，数组中所有拆分的子字符串对象都指向同一个字符串对象。子字符串对象扩展了AbstractString接口，因此在需要时可用于转换为字符串对象。split方法也支持分隔符。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s = \"\\u2200,x,\\u2203,y\"\nss = split(s, ',', limit=2)\ns = \"\\u2200,x,\\u2203,y\"\nss = rsplit(s, ',', limit=2)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"split示例使用逗号(，)作为分隔符，并将分割部分的数量限制为2。与split从左边拆分字符串类似，rsplit从右边拆分字符串。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"lpad和rpad为字符串添加前缀或后缀，使其达到指定的长度。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"lpad(\"string\", 10, \"p\")\nrpad(\"string\", 10, \"s\")","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"strip函数删除字符串两边的空格字符。该函数还可以有选择地接受一个要从两端删除的字符数组。也可以使用计算值为true在两端进行删除。lstrip和rstrip是两个类似于strip的函数，但只分别作用于字符串的左端和右端。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"strip(\"     string 123    \")\nstrip(\" {a}    sting 123  \",['{', 'a', '}', ' '])\nstrip(\"    string 123 aaa\") do x\n    return x == ' ' || x == 'a'\nend","category":"page"},{"location":"ch08string/#大小写转换","page":"字符串","title":"大小写转换","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"一些函数都输出结果如字面意义所示：","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"uppercase(\"Julia\")\nlowercase(\"JULiA\")\ntitlecase(\"hands on programming in julia\")\nuppercasefirst(\"julia\")\nlowercasefirst(\"JuLia\")","category":"page"},{"location":"ch08string/#模式匹配","page":"字符串","title":"模式匹配","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"模式匹配函数可以分为不同的类别。下面给出了其中的一些：","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"startswith，endswith和contains分别搜索字符串的开始部分，结束部分和字符串中的任何位置，返回它们是否在字符串中出现。occurrence (needle, haystack)是contains(haystack, needle)的另一种表示形式。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"str = \"Introduction to Julia\";\nstartswith(str, \"Intro\")\nendswith(str, \"Julia\")\ncontains(str, \"to\")\noccursin(\"to\", str)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"findfirst和findnext沿着字符串对象搜索模式序列。findlast返回模式最后出现的位置。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"r = findfirst(\"o\", \"Introduction to Julia\");\nwhile r !== nothing\n    println(r)\n    r = findnext(\"o\", \"Introduction to Julia\", r.stop+1)\nend\nfindlast(\"o\", \"Introduction to Julia\")","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"replace将搜索的输入模式更改为选取的另一文本。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"replace(\"Introduction to Julia\", \"o\"=>\"a\")","category":"page"},{"location":"ch08string/#正则表达式","page":"字符串","title":"正则表达式","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"正则表达式是一种模式匹配语言构造，它使计算机程序员能够定义与文本字符串匹配的复杂模式。这些模式主要用于编译器设计和标记器等。UNIX中使用正则表达式(regex)进行模式匹配的几个常用应用程序是lex、grep和egrep。与grep支持的标准语法相比，PERL、Python和R等编程语言提供了扩展的正则表达式语法支持。PERL兼容正则表达式(PCRE)库集成到了Julia中。因此，Julia对正则表达式的支持与任何其他语言一样强大。虽然我们在这里展示了一些正则表达式的示例，但这一节并没有专门介绍正则表达式的所有细节。读者需要阅读更专业的文档来深入了解正则表达式。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"可以看到，下面的示例中创建了一个Regex对象。将它与字符串匹配。匹配的对象存储在RegexMatch对象中。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"rx = Regex(\"a.a\")\nm = match(rx, \"abracadabra\")\nm.match","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"偏移匹配可以匹配到ada而不是aca。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"m = match(rx, \"abracadabra\", 5)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"在下面的例子中，一个@r_str宏(将在下一章详细讨论)被用来初始化Regex对象。rx对象定义了一个捕获组，匹配的正则表达式可以将捕获保存在capture属性中。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"rx = r\"a(.)a\";\nm = match(rx, \"abracadabra\");\nm.captures","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"现在使用命名捕获显示相同的示例。可以使用捕获的组名对RegexMatch进行索引来收集捕获的数据。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"rx = Regex(\"a(?<key>.)a\");\nm = match(rx, \"abracadabra\");\nm.captures\nm[\"key\"]","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"你还可以将模式多次匹配到字符串中。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"rx = r\"a.a\"\nm = eachmatch(rx, \"abracadabra\", overlap=true)\ncollect(m)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"当允许重叠字符串时，aca和ada都是匹配的。当overlap参数设置为false时，只匹配aca。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"m = eachmatch(rx, \"abracadabra\", overlap=false)\ncollect(m)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"不仅仅是match或eachmatch, 正则表达式匹配也被作为模式参数用于比如findfirst，findnext，occursin，replace，split，rsplit，startwith和endswith。","category":"page"},{"location":"ch08string/#编码-2","page":"字符串","title":"编码","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"Julia中的字符串对象本质上是Unicode表示。它们是否遵循特定的转换？可以转换为其他东西吗？有些问题对于读者来说是很自然的。如果你还记得迭代中的讨论，nextind方法将索引对齐到下一个UTF-8字符的位置上。这确保字符串对象本质上是UTF-8表示。但是，可以通过函数transcode提取出UTF-8、16和32数组表示。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s = \"\\u2200 x \\u2203 y\"\ntranscode(UInt8, s)\ntranscode(UInt16, s)\ntranscode(UInt32, s)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"transcode还可以将UTF字节数组转换为字符串对象。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"transcode(String, transcode(UInt16, s))","category":"page"},{"location":"ch08string/#有用的函数","page":"字符串","title":"有用的函数","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"有些函数相当直观。然而，不仅仅局限于ASCII字符集或英语字符，所有这些方法都适用于存在相关函数的所有语言的Unicode字符。它们利用Unicode表中的字符类别定义来确定这些属性。例如，所有属于Lu类别的字符对于isuppercase方法都返回真。类似地，当isspace方法查询字符时，类别Zs将被提取。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"isascii(\"∀ x ∃ y\"), isascii(\"abcd ef\")\niscntrl('a'), iscntrl('\\x1')\nisdigit('a'), isdigit('9')\nisxdigit('a'), isxdigit('x')\nisletter('1'), isletter('a')\nisnumeric('1'), isnumeric('௰') #No. 10 in Tamil (Indian) Language\nisuppercase('A'), islowercase('a')\nisspace('\\n'), isspace('\\r'), isspace(' '), isspace('\\x20')","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"在处理字符串和编码时，我们发现一些函数针对单个字符的属性。因此，将字符串转换为字符数组是很重要的。","category":"page"},{"location":"ch08string/#字符数组","page":"字符串","title":"字符数组","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"如前所述，字符串对象是字符的集。但是，它们不能被修改。你不能像对数组或其他容器类型那样灵活地对它们进行操作。然而，有很多函数可以用来转换字符串对象和创建另外的字符串对象。然而,如果需要，你可以使用collect方法将字符串转换为字符数组。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"collect(\"∀ x ∃ y\")","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"如前面所示，你还可以使用transcode方法来获得字符串对象的UTF-8，16，32转换向量。一旦有了字符数组，就可以在数组操作中以任何需要的方式使用它。","category":"page"},{"location":"ch08string/#用户定义字符串","page":"字符串","title":"用户定义字符串","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"罗马不是一天建成的，Julia字符串API也不是。字符串是包装在集中的UTF-8表示，该集将字符对象作为eltype。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"eltype(\"abcd\")","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"该体系结构被进一步扩展，以定义一个抽象的AbstractString类型，该类型将AbstractChar视为一个元素类型。在1.0之前的版本中，Julia有很多这样的实现，比如ASCIIString、UTF8String等等，它实际上是为一些常用的编码方案提供了基础。许多经典的字符串类型在功能上合并到String类型中，一些被移动到一个名为LegacyString.jl的可选包中。虽然使用那个包没有什么显著的好处，但是对于有兴趣尝试和实现自己的字符串类型的人来说，它们是一个很好的参考来源。如果你对实现自己的字符串类型感兴趣，请确保实现了AbstractString和AbstractChar接口。","category":"page"},{"location":"ch08string/#AbstractChar","page":"字符串","title":"AbstractChar","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"这个接口本质上要求任何派生字符都应该有一个Unicode表示值。同样，给定一个有效的Unicode值，必须能够创建一个字符。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"struct MyChar <: AbstractChar \n    a::UInt32\nend\nMyChar(n::Number)=MyChar(UInt32(n))\nBase.codepoint(c::MyChar) = c.a\nMyChar(32)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"如果代codepoint输入值不在编码范围内，构造函数必须抛出错误。","category":"page"},{"location":"ch08string/#AbstractString","page":"字符串","title":"AbstractString","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"AbstractString接口要复杂得多，并且对字符串对象的内部组成也做了一些假设。例如，这些接口定义了在字符串中定义一个字符所需的最小字节数的假设。如果你使用LegacyString，你会意识到ASCIIString使用一个unit8的codeunit，而UTF16String使用一个unit16的codeunit。但两者在代码单元中的内部数据长度相同。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"using Pkg\nPkg.add(\"LegacyStrings\")\nusing LegacyStrings\ns = ASCIIString(\"abcd\");\ncodeunit(s)\nncodeunits(s)\ns16 = UTF16String(transcode(UInt16, \"abcd\\0\")); # NULL termination\ncodeunit(s16)\nncodeunits(s16)\neltype(s),eltype(s16)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"尽管前面例子中的ASCIIString和UTF16String对存储的内部数据有完全不同的内部表示，但它们使用Char作为迭代的eltype。没有为这两种数据类型定义另外的字符类型。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"除了上述方法外，AbstractString的派生类型还需要实现所有迭代和索引方法，如iterate、getindex、nextind、prevind、lastindex、firstindex，以及一些与集相关的方法，如length。","category":"page"},{"location":"ch04function/#函数和方法","page":"函数和方法","title":"函数和方法","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"大多数代码都可以在类似shell的REPL接口中输入，如同正在编写脚本一样。但是，当你使用函数，向其传入或从中传出数据时，Julia的真正能力才体现出来。为了发挥多分派接口的强大功能，学习函数和方法成为Julia编程的基本需要。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"没有一个产品级应用是在单个文件中使用顺序语句开发出来的。大多数程序员喜欢将程序分割成小块的可执行单元。这解决了两个问题。首先，它创建了可重用单元，这些单元可以在更大的程序中的不同位置被多次调用。其次，小单元可以很容易地进行单元测试。因此，它们提高了代码的可靠性。我们将尝试以编程的方式解决国际象棋中的8皇后问题，并在此过程中理解Julia中的函数。","category":"page"},{"location":"ch04function/#皇后问题","page":"函数和方法","title":"8皇后问题","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"它是算法和人工智能领域的一个经典问题。目标是在满足不相互攻击的前提下，在棋盘上放置最大数量的皇后。下图给出了一种可能解。然而，这个解不是唯一的。我们将编写一个程序来解决8皇后问题。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"(Image: eight queens)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"在设计出问题的完整解决方案之前，我们必须有一个程序单元，作为输入信息，它接收两个皇后的位置，并输出皇后是否相互攻击。","category":"page"},{"location":"ch04function/#两个相互安全的皇后","page":"函数和方法","title":"两个相互安全的皇后","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"Julia中的这些小程序单元叫做函数。我们将创建一个函数，它接受两个皇后的输入位置，返回皇后的路径是否重叠则。以下是皇后互相攻击的条件。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"皇后有相同的x或y坐标：x₂ = x₁或y₂ = y₁。\n皇后彼此在对角线上，即：x₂ - x₁ = y₂ - y₁。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"如果两边的符号相同，就得到x_1 - y_1= x_2 - y_2。同样地，如果符号相反，我们会得到x_1 + y_1= x_2 + y_2。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"根据观察，我们在Julia中有以下函数:","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function attacks(x1, y1, x2, y2)\n    if x1 == x2\n        return true\n    elseif y1 == y2\n        return true\n    elseif x1 - y1 == x2 - y2\n        return true\n    elseif x1 + y1 == x2 + y2\n        return true\n    else\n        return false\n    end\nend\nattacks(1, 2, 4, 5)\nattacks(1, 2, 4, 6)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function...end是定义函数的分隔符。return语句用于返回函数的最终输出。一个函数可以有多个返回语句。上面的函数有5个return语句，返回的都是布尔值。","category":"page"},{"location":"ch04function/#运算符","page":"函数和方法","title":"运算符","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"在前面的函数中，我们使用了几个运算符和变量。很明显，+和-是两个数之间的加减二元运算符。==是比较两个值是否相等的运算符。在Julia中，运算符被视为普通函数，它们可以返回一个值。==运算符返回布尔值，该函数仅由if条件和布尔返回值组成。我们可以用逻辑或(||)运算符的简单组合来重写这个函数。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function attacks(x1, y1, x2, y2)\n    return x1 == x2 || y1 == y2 || x1 - y1 == x2 - y2 || x1 + y1 == x2 + y2\nend\nattacks(1, 2, 4, 5) # hide\nattacks(1, 2, 4, 6) # hide","category":"page"},{"location":"ch04function/#简洁格式","page":"函数和方法","title":"简洁格式","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"尽管我们推荐使用return关键字，但Julia函数对它不是强制的。如果未指定，end语句之前的表达式的值将作为函数的返回值返回。因此，下面是前面所述函数的另一种表示:","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function attacks(x1, y1, x2, y2)\n    x1 == x2 || y1 == y2 || x1 - y1 == x2 - y2 || x1 + y1 == x2 + y2\nend\nattacks(1, 2, 4, 5) # hide\nattacks(1, 2, 4, 6) # hide","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"Julia进一步简化了函数，使其看起来更像一个数学表达式。同样的函数也可以写成:","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"attacks(x1, y1, x2, y2) = (x1 == x2 || y1 == y2 || x1 - y1 == x2 - y2 || x1 + y1 == x2 + y2)\nattacks(1, 2, 4, 5) # hide\nattacks(1, 2, 4, 6) # hide","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"上述格式只适用于函数体内只有一条语句的情况。如函数体内有多条语句，但仍想使用简洁格式，则可使用begin...end块定义复合表达式。然而，对于包含多个语句的函数，不建议使用简洁形式。下面的例子尽管是一个有效的Julia函数，但作为风格指南，还是不鼓励使用它。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"attacks(x1, y1, x2, y2) = begin\n    if x1 == x2\n        return true\n    elseif y1 == y2\n        return true\n    elseif x1 - y1 == x2 - y2\n        return true\n    elseif x1 + y1 == x2 + y2\n        return true\n    else\n        return false\n    end\nend","category":"page"},{"location":"ch04function/#匿名函数","page":"函数和方法","title":"匿名函数","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"Julia中的函数可以像任何其他对象一样赋给变量。我们可以定义一个匿名函数，并通过下面的代码赋给变量attacks_var:","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"attacks_var = (x1, y1, x2, y2) -> (x1 == y2 || y1 == y2 || x1 - y1 == x2 - y2 || x1 + y1 == x2 + y2)\nattacks_var(1, 2, 3, 4)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"attacks_var的行为类似于一个函数，但它实际上是一个变量，一个匿名函数被赋给了它，这为Julia提供了很大的灵活性。","category":"page"},{"location":"ch04function/#输入参数","page":"函数和方法","title":"输入参数","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"attacks函数有四个输入参数。函数的输入参数在Julia中也是一种数据类型，称为元组。元组是一个不可变集合，在Julia中指定逗号分隔的值时创建。它们也可以通过在圆括号中包含几个逗号分隔的值来表示。空元组可以用一个空括号表示，当元组只有一个元素时，必须在这个元素后面加一个逗号。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"1, 2\na = ()\ntypeof(a)\na = (1)\ntypeof(a)\na = (1,)\ntypeof(a)\na = (2, 3)\ntypeof(a)\na[1]\na[1] = 5","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"可以看到，元组中的元素可以通过索引进行访问。但是，它的元素不能被修改。下面是一些基于变量位置从元组对变量进行多重赋值的示例。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"i, j = 1, 2\ni\nj\ni = 1, 2 # i是一个元组\ni\ni, = 1, 2 # i是一个整数\ni","category":"page"},{"location":"ch04function/#定数量输入参数","page":"函数和方法","title":"定数量输入参数","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"如果我们用5或3个输入参数调用方法会发生什么？","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"attacks(1, 2, 3, 4, 5)\nattacks(1, 2, 3)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"报告错误，说明函数仅定义了考虑4个输入参数的情况。但是，由于在函数定义中没有指定参数类型，程序默认将参数类型设置为Any，因此该函数可以接受任何类型的输入数据。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"输入参数是可选的。下面是一个没有输入参数的函数:","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function hello_world()\n    println(\"Hello world!\")\nend\nhello_world()","category":"page"},{"location":"ch04function/#变数量输入参数","page":"函数和方法","title":"变数量输入参数","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"可以在Julia中定义接受可变数量参数(varargs)的函数。参数使用模式匹配和递归进行分配。以下是一些例子:","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"mysum(x, y...) = x + mysum(y...)\nmysum(x) = x\nmysum(1, 2)\nmysum(1, 2, 3)\nmysum(1, 2, 3, 4, 5, 6, 7)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"让我们看看另一个从输入参数计算最大值的函数。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"mymax(x, y...) = mymax(x, mymax(y...))\nmymax(x, y) = x > y ? x : y\nmymax(1, 2, 3)\nmymax(4, 10, 3, 2, 1)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"当你指定mymax(x)时会发生什么？当然，它必然给出一个错误，因为没有只接受一个参数作为输入的函数。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"mymax(1)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"它可以很容易地通过添加一个输入参数的函数来修复，如下所示:","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"mymax(x) = x\nmymax(1)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"让我们看看mymax定义了多少个方法。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"methods(mymax)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"我们有1个、2个和可变数量输入参数共3个mymax方法。","category":"page"},{"location":"ch04function/#默认值","page":"函数和方法","title":"默认值","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"让我们稍微修改一下mymax函数，这样就不需要创建单参数函数了。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"mymax(x, y...) = mymax(x, mymax(y...))\nmymax(x, y=x) = x > y ? x : y\nmethods(mymax)\nmymax(1)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"我们只引入两个函数：一个有可变数量的参数，另一个有两个参数，但其中一个带有默认值。系统内部生成了3个函数，只有一个参数的函数映射到了有两个参数但其中一个是默认值的函数。","category":"page"},{"location":"ch04function/#汇集和分散","page":"函数和方法","title":"汇集和分散","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"在函数定义中对一个输入参数使用运算符...时，其行为称为汇集。它尝试接受多个输入，并将它们表示为单个元组变量。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function test(args...)\n    println(typeof(args))\nend\ntest(1, 2, 3, 4.0)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"因为args是一个元组，所以可以通过索引来访问参数值。一些实现可以使用递归来处理变输入参数数量函数，就像我们前面定义的mymax和mysum方法一样。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"让我们回到皇后攻击函数。皇后被表示为x和y位置的元组是很自然的，例如(12)。然而，我们创建的函数有4个参数。在这种情况下，分散会有所帮助。在函数调用中，...运算符将目标集合展开，并将单个值作为函数的输入传递。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"q1 = (1, 2)\nq2 = (3, 4)\nattacks(q1..., q2...)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"虽然汇集和分散为Julia中的函数式编程提供了显著的好处，但它们不是性能友好的运算符。因此，在需要时，必须谨慎地使用它们。","category":"page"},{"location":"ch04function/#返回值","page":"函数和方法","title":"返回值","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"所有Julia函数都显式或隐式地返回一个值。我们在前面定义的各种攻击函数中看到了这些示例。一个函数可以什么都不返回吗？这样的函数仍然会返回nothing，它是一个Nothing类型的单例实例。前面介绍的hello_world()函数就是一个类似的例子。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"a = hello_world()\ntypeof(a)","category":"page"},{"location":"ch04function/#类型安全","page":"函数和方法","title":"类型安全","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"让我们再次以最初冗长的攻击函数为例，但对其进行了一些小修改。我们从函数中删除返回false的else语句。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function attacks(x1, y1, x2, y2)\n    if x1 == x2\n        return true\n    elseif y1 == y2\n        return true\n    elseif x1 - y1 == x2 - y2\n        return true\n    elseif x1 + y1 == x2 + y2\n        return true\n    end\nend\na = attacks(1, 2, 3, 4)\nb = attacks(1, 2, 3, 5)\ntypeof(a), typeof(b)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"你可能会发现在代码中使用nothing代替false是可以接受的。但是，由于可能存在类型稳定性问题，这种做法是不可取的。根据函数的输入，函数调用者可能得到Bool值或Nothing值。这种类型的不一致性可能导致调用者不能为返回值分配适当的资源，并且可能进行许多超出需要的额外分配，或者可能不得不将Any作为返回类型。我们将在性能一章中详细讨论代码性能受到类型稳定性问题影响的实例。从函数返回类型一致的返回值通常是一个好方法。其次，类型安全问题不能完全消除。它们并不总是对性能产生不利影响。Julia提供了识别它们的工具。我们稍后将详细讨论。返回类型并不是类型安全问题的唯一来源。由于Julia类型是可选的，各种输入参数以及输入参数与常量表达式的相互作用也会导致类型安全问题。我们将在性能管理一章中用实例介绍其中一部分内容。","category":"page"},{"location":"ch04function/#多返回值","page":"函数和方法","title":"多返回值","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"大多数编程语言都坚持一个函数只返回一个值。这同样适用于Julia。使用Julia的元组类型，可以返回多个值。我们将扩展攻击函数，将路径相交的原因作为另一个返回值同布尔值一起返回给我们。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function attacks_with_reason(x1, y1, x2, y2)\n    if x1 == x2\n        return true, :x\n    elseif y1 == y2\n        return true, :y\n    elseif x1 - y1 == x2 - y2\n        return true, :diag\n    elseif x1 + y1 == x2 + y2\n        return true, :xdiag\n    else\n        return false, :na\n    end\nend\nattacks_with_reason(1, 2, 3, 4)\nattacks_with_reason(1, 2, 3, 1)\nattacks_with_reason(1, 2, 3, 2)\nattacks_with_reason(1, 2, 2, 1)\nattacks_with_reason(1, 2, 1, 3)","category":"page"},{"location":"ch04function/#递归","page":"函数和方法","title":"递归","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"递归是函数式编程中常用的编程范式，在Julia中也同样流行。在递归编程中，要遵循以下过程:","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"函数应该在问题的一个子集内调用自己。\n必须有一个确定的使递归终止的条件。\n对结果进行集合以得到最终输出。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"我们将应用所有这些条件来解决8皇后问题。目前，我们已经找到了判断皇后是否会攻击其他皇后的一种机制。我们将通过递归地从上到下向每一行添加一个皇后来解决这个问题。假设我们考虑一个大小为8×8的棋盘。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"首先考虑第1行，在第1行起始列位置1上添加一个皇后。\n然后在第2行添加一个皇后。\na) 我们从列1开始不断增加列序号，直到找到一个不受其他皇后攻击的列为止。这里将使用前面开发的攻击函数来进行检验。\nb) 如果可以放置皇后，则马上放置并递归调用这个函数来检查是否可以将皇后放置在第3行、第4行、...，直到第8行。\nc) 如果放置成功，则返回函数结果，不成功则递归地转回紧邻的上一行，继续寻找下一个可以放置的列。\n如果能够在最后一行添加一个皇后，则返回true。\n如果在任意一行中添加皇后失败，则返回false。\n使用递归方法的变参数数量的函数非常有用，它提供了一种跟踪已添加的所有列的自然机制。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"所提出的方法并不局限于8皇后问题，而是可以用于N皇后问题。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"attacks(x1, y1, x2, y2) = \n       (x1 == x2 || y1 == y2 || x1 - y1 == x2 - y2 || x1 + y1 == x2 + y2)\nfunction queens(N,xs...)\n    currentrow = length(xs) + 1         # 当前要检验的行 \n    if currentrow > N                   # 如果成立，则所有行都检验成功了\n        println(\"Final Positions: \",xs) # 按行打印最终列位置\n        return true                     # 返回成功解决问题\n    end\n    for i = 1:N                         # 检验每一列\n        res = false                     # 初始设置皇后不相互攻击\n        for j = 1:currentrow-1          # 对当前行与前面以完成的各行进行攻击检验\n            (res = attacks(currentrow, i, j, xs[j])) && break # 对当前行的i列与前面各行进行攻击检验，攻击返回true并结束检验，不攻击返回false并继续检验直到所有行都检验完毕\n        end\n        res && continue                 # 攻击，则检验当前行的下一列\n        v = queens(N,xs...,i)           # 不攻击，则将该列（按顺序首先找到的可行列）加到列位置列表中，并继续对下一行进行检验，返回成功与否\n        v && return v                   # 成功则返回，不成功则在当前行寻找下一个不攻击的可行列\n    end\n    return false                        # 所有列都检验完，仍找不到可行列，则返回失败\nend\nqueens(8)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"作为递归的一部分，可以在函数调用的开头添加println语句来观察变数量参数的行为。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function queens(N,xs...)\n    println(xs)\n    currentrow = length(xs) + 1     \n    # ...    \n    if currentrow > N                   # hide\n        println(\"Final Positions: \",xs) # hide\n        return true                     # hide\n    end                                 # hide\n    for i = 1:N                         # hide\n        res = false                     # hide\n        for j = 1:currentrow-1          # hide\n            (res = attacks(currentrow, i, j, xs[j])) && break # hide\n        end                             # hide\n        res && continue                 # hide\n        v = queens(N,xs...,i)           # hide\n        v && return v                   # hide\n    end                                 # hide\n    return false                        # hide\nend                                     # hide\nqueens(8)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"程序得到的解如下图所示。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"(Image: solution)","category":"page"},{"location":"ch04function/#多分派和多态","page":"函数和方法","title":"多分派和多态","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"在面向对象的编程中，通常只有单分派和多态，而没有多分派。多态被用来描述基于方法所操作的对象的行为的改变。简单地说，area在矩形对象和三角形对象上使用的计算方法是不同的。在前面的例子中，我们看到函数的行为因参数的数量不同而不同。本节，我们将看到函数可以根据参数的类型表现出不同的行为。在Julia中，当同名函数根据参数的类型和个数具有不同的行为时，它们被称为方法。","category":"page"},{"location":"ch04function/#数据类型","page":"函数和方法","title":"数据类型","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"下面的示例显示了两个area函数：一个用于Triangle类型，另一个用于Rectangle类型。由于这两个形状都是父抽象类型Shape的子类型，我们可以修改默认的show方法，以便从show方法中调用相关的area函数。Base.show是在REPL中显示对象时调用的默认方法。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"abstract type Shape end\nstruct Rectangle <: Shape\n    w::Float32\n    h::Float32\nend\nstruct Triangle <: Shape\n    a::Float32\n    b::Float32\n    c::Float32\nend\narea(r::Rectangle) = r.w*r.h\nfunction area(t::Triangle)\n    a, b, c = t.a, t.b, t.c\n    s = (a + b + c)/2\n    return sqrt(s*(s-a)*(s-b)*(s-c))\nend\nr, t = Rectangle(3, 4), Triangle(3, 4, 5)\narea(r)\narea(t)\nBase.show(io::IO, s::Shape) = print(io, \"Shape Type: \", typeof(s), \" Area: \", area(s))\nr\nt\nmethods(show, (IO,Union{Shape,Rectangle,Triangle}))\nmethods(area)","category":"page"},{"location":"ch04function/#多分派","page":"函数和方法","title":"多分派","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"在典型的面向对象语言中，方法与对象相关联。根据对象类型调用特定的函数。这种方法分派是作为单分派接口调用的。然而，支持多分派接口的语言不会将函数关联到特定类型上。根据对象运行时的类型，函数解析到相应的方法接口并调用最相关的方法。area方法不是矩形类型或三角形类型的方法，而是根据对象类型从多分派查询表中查找得到的。另外，从上面的例程可以看到，对于Rectangle和Triangle两种不同的类型，show只定义了一种方法，这称为多态，实际上，上述show方法的多态性是通过对area函数进行多分派来实现的。","category":"page"},{"location":"ch04function/#构造函数","page":"函数和方法","title":"构造函数","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"对象可以有内在的约束，在创建它们时，必须强制执行，以避免创建无效对象。构造函数可实现这个目的。在矩形或三角形的类型定义中，可通过构造函数来避免当边为负值时创建无效对象。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"struct RectangleA\n    w::Float32\n    h::Float32\n    function RectangleA(w::Real, h::Real)\n        (w > 0 && h > 0) || error(\"invalid rectangle with non-positive h or w\")\n        return new(w,h)\n    end\nend","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"创建对象现在调用定义的构造函数。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"a = RectangleA(1.0,-4.0)\na = RectangleA(1//5, 4//5)\na = RectangleA(1, 4)\na = RectangleA(1.0, 4.0)\na = RectangleA(1.0, 4)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"构造函数可以接受任何实数作为输入参数，并确保不允许非正数作为实参的一部分。假设我们要创建两个额外的构造函数来构造正方形。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"RectangleA(a=1.0) = RectangleA(a, a)\nRectangleA()\nRectangleA(2.0)\nmethods(RectangleA)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"我们用一条语句创建了两个构造函数，其中一个是由于默认实参而创建的。现在可以看到创建了3个构造函数，其中两个是在类型定义之外声明的外部构造函数。一个是在类型定义中声明的内部构造函数。创建内部构造函数是为了确保构造约束得到强制执行。使用外部构造函数主要是为了方便和提供构造灵活性。如果没有提供构造函数，则自动产生默认构造函数来初始化该类型的属性。在前面的RectangleA示例中，当没有定义其他内部构造函数时，将创建以下默认的内部构造函数：","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"RectangleA(h::Float32, w::Float32)=new(h,w)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"new函数是一个只能在内部构造函数中使用的特殊函数。它以定义中的顺序初始化参数来创建对象。","category":"page"},{"location":"ch04function/#返回值-2","page":"函数和方法","title":"返回值","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"构造函数必须返回一个初始化良好的对象。在Julia中，期望在对构造函数的调用结束时得到正确初始化的对象。虽然在某些情况下，由于性能原因，复合对象可能不被初始化，但这种情况通常是一个特例。构造函数必须返回一个它试图构造的类型的对象。","category":"page"},{"location":"ch04function/#参数化数据类型","page":"函数和方法","title":"参数化数据类型","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"在前面讨论参数化数据类型时，我们没有详细说明它们对函数和分派接口或构造函数的影响。在下面创建的RectangleB类型中，我们希望使用任何Real类型作为矩形属性的参数类型。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"struct RectangleB{T <: Real}\n    w::T\n    h::T\nend\nRectangleB(2//3, 1//4)\nRectangleB(1f0, 2f0)\nRectangleB(2//3, 1f0)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"默认构造函数RectangleB(::T, ::T) where T<:Real被创建，但T只能是同一种特定的类型。它不能同时是Rational{Int64}和Float32。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"RectangleB{Int}('a', 1f0)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"但是，当我们显式地指定参数类型作为构造函数的一部分时，类型可以被正确地转换。","category":"page"},{"location":"ch04function/#分派接口","page":"函数和方法","title":"分派接口","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"让我们创建两个方法，aspect_ratio和area。比率是矩形的宽高比。面积是矩形的高度与宽度的乘积。在前面的示例中我们已经看到了area方法的实现。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"area(r::RectangleB) = r.w*r.h\naspect_ratio(r::RectangleB) = r.w/r.h\nr1, r2, r3= RectangleB(1//2, 2//3), RectangleB(1.5, 0.5), RectangleB(1, 2)\narea(r1), area(r2), area(r3)\naspect_ratio(r1), aspect_ratio(r2), aspect_ratio(r3)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"根据矩形的参数类型，area函数返回的值是Rational{Int}和Int，但在aspect_ratio函数中似乎忽略了这个规则。运算符/是一个浮点除法运算符。Julia中的有理或除法运算符是//。让我们为aspect_ratio建立一个针对于整数和有理数类型的方法。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"aspect_ratio(r::RectangleB{T}) where T<:Union{Integer, Rational} = r.w//r.h\naspect_ratio(r1), aspect_ratio(r2), aspect_ratio(r3)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"显然，Rational和Integer类型的方法被分派到了新方法，而其他数字类型(如Float64)则被分派到了旧方法。T<:Union{Integer, Rational}本质上意味着类型可以从Integer或Rational类型上派生出来。联合在Julia中广泛用于表示多个类型中的一个。你也可以像下面的例子一样使用3种方法，而不是使用联合。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"aspect_ratio(r::RectangleB{T}) where T<:Integer = r.w//r.h\naspect_ratio(r::RectangleB{T}) where T<:Rational = r.w//r.h","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"重点是要从参数类型中子类型之间的关系的角度来理解分派规则。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"RectangleB{Rational{Int}} <: RectangleB{Rational}\nRectangleB{Rational{Int}} <: RectangleB\nRectangleB{Rational} <: RectangleB","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"子类型关系仅与直接参数类型相关。RectangleB{Rational{Int}}不是RectangleB{Rational}的子类型，而是RectangleB的子类型。","category":"page"},{"location":"ch04function/#类型互动","page":"函数和方法","title":"类型互动","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"让我们看看以下的一些例子：","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"1f0 + 2\n1f0 + 2.0","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"我们将Int类型与Float32类型相加，返回的结果是一个Float32。类似地，我们将Float32与Float64相加，结果得到一个Float64。所有这些似乎都很自然。似乎Int被提升为Float32，然后执行加法运算。与其他编程语言不同，Julia的类型提升不是隐式的。任何类型的转换都需要显式地执行。Julia核心库内部定义了许多这样的规则，这些规则被显式地调用，结构就是我们看到的这些无缝转换。","category":"page"},{"location":"ch04function/#转换","page":"函数和方法","title":"转换","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"初始化任何值的典型方法是通过构造函数。例如，你可以通过指定Int(1.0)将像1.0这样的整型浮点值转换为Int。但是，Int(1.5)会抛出一个InexactError。在大多数情况下，这是由程序员显式地调用来实现的。但是，有时转换是通过隐式调用来实现的。在这种情况下，调用convert(T, x)。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function f()\n    i::Int = 0\n    i = 1.5\n    return i\nend\nf()","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"i是定义为Int类型的变量。当将值1.5赋给它时，将调用convert方法，从而抛出InexactError。对于数值类型，convert方法调用T(x)或构造函数，在本例中为Int64(1.5)。前面的RectangleB示例可显示更详细的情况。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"RectangleB{Int}('a', 1.0)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"在这种情况下，RectangleB{Int}作为构造函数提供，convert(Int, 'a')和convert(Int, 1.0)被隐式调用，Char和Float64被转换为Int。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"RectangleB{Int}(\"abc\", 1.0)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"不存在从String到Int的转换方法导致了构造函数失败。","category":"page"},{"location":"ch04function/#提升","page":"函数和方法","title":"提升","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"让我们再看看RectangleP类型。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"struct RectangleP{T <: Real}\n    w::T\n    h::T\nend","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"当没有指定构造函数时，将定义一个默认构造函数，如下所示：","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"struct RectangleP{T<:Real}\n    w::T\n    h::T\n    RectangleP(w::T, h::T) where T<:Real = new{T}(w, h)\nend\nRectangleP(1, 2.0)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"RectangleP(1, 2.0)失败。有办法解决这个问题吗？","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function RectangleP(w::T1, h::T2) where {T1<:Real, T2<:Real}\n    w1, h1 = promote(w, h)\n    return RectangleP(w1, h1)\nend\nRectangleP(1, 2.0)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"我们定义了一个支持两个形参的外部构造函数。参数从Real中派生出来，但可以彼此不同。我们对参数调用promote方法来获得提升了的函数参数，然后根据提升的参数创建RectangleP。上面例子的情况是，在Int和Float64的提升中，Float64将是提升的类型。这种行为在下面的例子中会清楚地展现。假设我们要确定能同时塞入两个RectangleP对象的一个RectangleP的尺寸限制（假设矩形不旋转）。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function minrect(r1::RectangleP, r2::RectangleP)\n    w = r1.w < r2.w ? r1.w : r2.w\n    h = r1.h < r2.h ? r1.h : r2.h\n    return RectangleP(w, h)\nend\nminrect(RectangleP(1, 2), RectangleP(2.0, 0.5))\nminrect(RectangleP(1, 2), RectangleP(3.0, 4.0))","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"虽然前面的代码没有错，但你可能已经注意到函数基于输入数据会返回一个RectangleP{Float64}或RectangleP{Int}的情况。从类型稳定性的角度来看，这绝对是不可取的。当RectangleP{Float64}和RectangleP{Int}相互作用时，我们可以创建一个Base.promote_rule以便产生正确的提升。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"Base.promote_rule(::Type{RectangleP{T}}, ::Type{RectangleP{S}}) where {T<:Real, S<:Real} = RectangleP{promote_type(S, T)}\nBase.convert(::Type{RectangleP{T}}, x::RectangleP{S}) where {T<:Real, S<:Real} = S === T ? x : RectangleP(T(x.w), T(x.h))\nfunction minrect(tr1::RectangleP, tr2::RectangleP)\n    r1, r2 = promote(tr1, tr2)\n    w = r1.w < r2.w ? r1.w : r2.w\n    h = r1.h < r2.h ? r1.h : r2.h\n    return RectangleP(w, h)\nend\nminrect(RectangleP(1,2), RectangleP(3.0,4.0))","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"为了保持一致，我们必须确保提升产生一致的类型。因为对Float64和Int64提升的结果是Float64，所以我们希望确保RectangleP{Float64}和RectangleP{Int}之间的提升得到RectangleP{Float64}。其次，我们创建一个转换方法来将RectangleP{S}转换为RectangleP{T}。当在minrect中调用promote时，会在内部调用promote_rule和convert方法。数据被转换为RectangleP{Float64}。因此，最终的返回类型将是RectangleP{Float64}。","category":"page"},{"location":"ch03controlflows/#控制流","page":"控制流","title":"控制流","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"分支和循环等控制流是命令式编程风格的核心。作为一种多范式编程语言，Julia支持所有知名的命令式风格和结构。","category":"page"},{"location":"ch03controlflows/#复合语句","page":"控制流","title":"复合语句","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"语句是程序员给计算机下达的命令。如打印一段文字，或给一个变量赋初值。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"println(\"Hello, world!\")\na = 10.0","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"Julia每次只能执行一条语句。如果需要把多条语句作为一个大型的复合执行单元（如同一条语句）来看待，则可以使用begin和end块将任意语句集包围起来。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"z = begin\n    x = 1\n    y = 2\n    x + y\nend\nz","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"块中最后一个表达式的值作为复合块的值。同样的表达式可以在单行中写成使用大括号包围的由分号分隔的语句集。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"z = (x = 1; y = 2; x + y)","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"下面也是有效的复合语句。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"z = (x = 1;\n    y = 2;\n    x + y)\nz = begin x=1; y=2; x+y end","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"由上可见，要在单行中编写多条语序，需要使用;将每条语句分隔开来。另外，Julia是通过最小语义单元来判断输入的内容是否是单行的，而不是通过回车换行来判断。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"a =\n1","category":"page"},{"location":"ch03controlflows/#注释","page":"控制流","title":"注释","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"随着程序越来越长，越来越复杂，阅读起来也变得更加困难。因此，通过对程序增加笔记来说明它到底做了些什么是一个非常明智的方法。这些笔记被称为注释，它们以 # 号开头：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"# 计算已用时间的百分比（总时长是60分）\npercentage = (20 * 100) / 60","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"在这个例子中，注释独占一行。你也可以将注释放到一行的末尾：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"percentage = (20 * 100) / 60  # 已用时间的百分比","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"# 号以后的所有内容都被程序忽略掉——它对程序的执行不起任何作用。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"当我们写的注释需要连续占用很多行，这时在每行的开头都使用#会很麻烦。还有一种情况，我们可能需要在同一行的一条语句的中间插入注释，这时#会完全失效（因为#以后的内容被全部忽略），Julia提供的另一种注释方法#=...=#可以解决这类问题。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"#= 一行注释\n   另外一行注释\n=#\nv = 5   \nb = #=在中间插入注释=# 3.2","category":"page"},{"location":"ch03controlflows/#分支","page":"控制流","title":"分支","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"条件语句是编程语言的核心。它们提供了在代码中定义分支的途径，并且是迭代编程的基础。使用本地goto进行分支足以模拟编程语言中的任何迭代模型。","category":"page"},{"location":"ch03controlflows/#if...else","page":"控制流","title":"if...else","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"if...else是Julia中最常见的条件执行形式。一个典型的if条件如下所示:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"if <Boolean condition>\n    # do something\nelse\n    # do the something else\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"else部分是可选的。条件必须是布尔值。与布尔值true或false相同的整数不能代替对应的布尔值。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"if 1\n    println(\"Integer is good for Bool\")\nend\nif Bool(1)\n    println(\"Bool now\")\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"if表达式返回被执行分支的值。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"i = 1\nstr = if i > 1\n    \"Greater\"\nelse\n    \"Less\"\nend\nstr","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"同样的表达式也可以用三元运算符?和:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"str = i > 1 ? \"Greater\" : \"Less\"\nstr","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"虽然在大多数表达式中可以不使用空格，但在?和:两侧的空格则是必须的。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"julia> str = i > 1? \"Greater\" : \"Less\"\nERROR: syntax: space required before \"?\" operator\n\njulia> str = i > 1 ? \"Greater\": \"Less\"\nERROR: syntax: space required before colon in \"?\" expression","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"当遇到多重分支操作时，可使用if...elseif...else结构。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"val = 3\nif val == 1\n    \"one\"\nelseif val == 2\n    \"two\"\nelseif val == 3\n    \"three\"\nelseif val == 4\n    \"four\"\nelse\n    \"unknown\"\nend","category":"page"},{"location":"ch03controlflows/#非结构分支","page":"控制流","title":"非结构分支","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"诸如if...elseif...else的结构分支，是编程语言中条件执行的最优选择。然而，一些语言具有goto语句来将执行分支跳转到代码中的特定位置。Julia也使用宏@goto和@label提供了这样的功能。它们有以下限制:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"它们被限制在特定的代码块中。@goto可以在同一代码块中使用@label。\n它们不能跨函数使用。\n它们会影响代码的可读性。因此，通常在大多数结构化编程语言中不使用。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"Julia具有结构化分支和迭代，因此完全可以不使用非结构化分支。下面的代码仅是使用@goto和@label来对从1到10的连续数进行求和的示例:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"begin\n    s = 0\n    n = 10\n    @label loop\n    s = s + n\n    n = n - 1\n    if n > 0\n        @goto loop\n    end\n    s\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"显然，对于序列求和，迭代要比非结构化分支简单得多。","category":"page"},{"location":"ch03controlflows/#短路求值","page":"控制流","title":"短路求值","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"Julia中的&&和||运算符分别对应逻辑“和”和“或”运算。此外，它们还有一个附加的短路求值属性：它们不一定对第二个参数求值(也有按位的&和|运算符，可以用作逻辑的“和”和“或”，它们不具有短路行为，但要注意&和|的优先级高于&&和||)。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"短路求值与条件求值非常相似：在由这些运算符连接的一系列布尔表达式中，整个链的最终布尔值由计算最小数量的表达式来确定。这意味着：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"在表达式a && b中，子表达式b仅在a的计算结果为true时才被计算。\n在表达式a || b中，子表达式b仅在a的计算结果为false时才计算。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"理由是：如果是a是false，不管b的值如何，a && b必是false。同样，如果是a是true，不管b的值如何，a || b必是true。&&和||都是右结合的，但&&的优先级高于||。验证这种行为的方法很容易：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"t(x) = (println(x); true)\nf(x) = (println(x); false)\nt(1) && t(2)\nt(1) && f(2)\nf(1) && t(2)\nf(1) && f(2)\nt(1) || t(2)\nt(1) || f(2)\nf(1) || t(2)\nf(1) || f(2)","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"可以很容易地以同样的方式验证&&和||运算符各种组合的结合性和优先级。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"这种行为在Julia中经常被用来代替非常简短的if语句。if <条件> <语句> end可以写成<条件> && <语句>（可以读作：<条件>成立则执行<语句>）。类似地，if !<条件> <语句> end可以写成<条件> || <语句>可以读作：<条件>成立否则执行<语句>）。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"例如，一个递归的阶乘可以这样定义：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"function fact(n::Int)\n    n >= 0 || error(\"n must be non-negative\")\n    n == 0 && return 1\n    n * fact(n-1)\nend\nfact(5)\nfact(0)\nfact(-1)","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"不需要短路求值的布尔运算可以通过按位布尔运算符来完成：&和|。它们是普通函数，支持中缀运算符语法，总是对实参进行求值计算：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"f(1) & t(2)\nt(1) | t(2)","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"就像if、elseif或三元运算符中使用的条件表达式一样，&&或||的运算数必须是布尔值(true或false)。在条件链中除了最后一项的任何地方使用非布尔值都是错误的：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"1 && true","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"另一方面，可以在条件链的末尾使用任何类型的表达式。它将根据前面的条件被计算和返回：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"true && (x = (1, 2, 3))\nfalse && (x = (1, 2, 3))","category":"page"},{"location":"ch03controlflows/#迭代","page":"控制流","title":"迭代","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"虽然我们可以使用非结构化分支goto实现代码的迭代执行，但作为一种高级语言，Julia提供了迭代执行的特定语言结构。最常见的是for和while。","category":"page"},{"location":"ch03controlflows/#for","page":"控制流","title":"for","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"s = 0;\nfor i = 1:10\n    s = s + i\nend\ns","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"在上面的代码片段中，我们从1枚举到10，并将值累加到s。在for循环中，我们将一个步长为1的范围对象1:10赋给参数i。该对象也可以写成1:1:10，表示<初始值>:<步长>:<最终值>。现在，我们修改代码，使其只对奇数进行累加。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"s = 0;\nfor i = 1:2:10\n    println(i)\n    s = s + i\nend\ns","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"可以看出，将范围对象的步长更改为2就可以达到预期的结果。","category":"page"},{"location":"ch03controlflows/#continue和break","page":"控制流","title":"continue和break","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"让我们在求和时忽略所有能被3整除的数。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"s = 0;\nfor i = 1:10\n    if i % 3 == 0\n        continue\n    end\n    println(i)\n    s = s + i\nend\ns","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"在这种情况下，continue用于跳过所有能被3整除的数。continue确保在迭代器仍处于活动状态时，表达式后面的代码块被排除在计算之外，而在代码中使用break将终止循环。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"s = 0;\nfor i = 1:10\n    if i % 3 == 0\n        break\n    end\n    println(i)\n    s = s + i\nend\ns","category":"page"},{"location":"ch03controlflows/#for...in","page":"控制流","title":"for...in","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"除了范围对象，for也可以与其他具有迭代器功能的序列对象一起使用。我们将在后面详细讨论迭代器接口。下面是一个for...in语法的代码片段。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"for i in [5,10,15]\n    println(i)\nend","category":"page"},{"location":"ch03controlflows/#多范围对象","page":"控制流","title":"多范围对象","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"一个for循环可以遍历多个范围对象。效果是在由左侧指定外层循环的范围的笛卡尔积上迭代。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"for i=1:3, j=1:2\n    println((i,j))\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"内部范围也可以受外部范围值的影响。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"for i=1:3, j=1:i\n    println((i, j))\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"这里的for循环是一个单独的循环，break语句可以完全终止它，这与嵌套的for循环只终止内部循环不同。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"for i=1:3, j=1:2\n    println((i, j))\n    if i == j\n        break\n    end\nend\nfor i=1:3\n    for j=1:2\n        println((i, j))\n        if i == j\n            break\n        end\n    end\nend","category":"page"},{"location":"ch03controlflows/#while","page":"控制流","title":"while","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"在Julia中，for用于迭代器和范围对象。while则更灵活，可以在任何条件下发挥作用。只要条件为真，循环就会继续执行。下面是一般语法。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"while <Boolean_condition is true>\n    <loop>\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"现在，如果我们考虑相同的1-10的加法例子，那么代码将如下所示:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"s, n = 0, 10;\nwhile n > 0\n    s = s + n\n    n = n - 1\nend\ns","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"与for循环类似，可以分别通过continue和break来跳过或终止执行。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"while循环重复计算起始处的条件，如果结果为true，则执行循环。在某些情况下，存在不管条件如何，都需要至少执行一次的循环，并在循环结束时计算新的条件来判断是否继续执行循环。这相当于其他语言中的do...while循环。Julia目前没有这个构造。但实现这个语义逻辑却很简单。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"julia> println(\"press q <enter> to end loop\")\npress q <enter> to end loop\n\njulia> while true\n           ch = readline()\n           ch == \"q\" && break\n       end\na\nq","category":"page"},{"location":"ch03controlflows/#异常处理","page":"控制流","title":"异常处理","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"当程序出现异常时，执行的函数可能无法返回一个有效值或使程序处于可恢复状态。有些程序可能会报告错误并终止执行。然而，在报告异常情况的同时，使程序恢复状态是非常有益的。其次，恢复的状态一定在函数调用的多个深度的调用堆栈中。因此，异常可能导致控制流移动到调用堆栈中的另一个函数，而不仅仅是调用方的地址空间。","category":"page"},{"location":"ch03controlflows/#try...catch","page":"控制流","title":"try...catch","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"将预期具有异常条件的代码放置在try之后。异常处理代码添加到catch之后的部分。end表达式结束try块。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"try\n    sqrt(-1)\ncatch e\n    println(e)\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"没有try...catch块的代码将在REPL中报告以下内容:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"sqrt(-1)","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"可以看到，REPL提供了默认的try...catch实现，它接受DomainError异常并打印一个带有堆栈跟踪的错误。Julia有相当多的标准异常，如ErrorException、DomainError、ArgumentError、BoundsError等。所有错误都派生自抽象类型Exception。","category":"page"},{"location":"ch03controlflows/#throw/rethrow","page":"控制流","title":"throw/rethrow","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"虽然catch提供了捕获异常并对异常采取操作的选项，但人们可以利用rethrow函数使异常进一步传播，而不是处理它。打印的错误信息是REPL默认的错误处理方法。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"try\n    sqrt(-1)\ncatch e\n    rethrow()\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"当出现一些意外的条件时，还可以抛出自定义异常。抛出的对象不一定总是Exception类型。它可以是任何对象。下面给出了一个抛出整数的例子:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"try\n    throw(1)\ncatch e\n    println((e,typeof(e)))\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"异常用于管理异常条件。如果行为只是代码流中的常规条件的表示，应使用其他控制流如if...else。其次，异常会增加大量的执行开销。因此，只有在需要时才有选择地使用它们。","category":"page"},{"location":"ch03controlflows/#finally","page":"控制流","title":"finally","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"当资源正在使用时，异常情况可能会迫使函数突然退出执行，这种情况下的资源无法回收。finally子句代码在正常和异常条件下都会被执行，确保资源被回收。在下面的示例中，即使出现异常，文件句柄f也会关闭。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"f = open(\"/etc/hosts\")\nisopen(f)\ntry\n    b = write(f,\"abc\")\ncatch e\n    println(e)\nfinally\n    close(f)\nend\nisopen(f)","category":"page"},{"location":"ch03controlflows/#异常的信息","page":"控制流","title":"异常的信息","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"因为每次堆栈展开时都需要验证异常对象，因此它们会影响执行速度。那么，如此复杂架构的异常对象为程序添加了什么价值？它们提供的主要优势之一是能够跟踪异常发生的堆栈。因此，可以得到错误的传播轨迹。其次，异常对象的形式提供了关于了解错误足够信息的能力。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"julia> sqrt(-1)\nERROR: DomainError with -1.0:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n [1] sqrt\n   @ ./math.jl:582 [inlined]\n [2] sqrt(x::Int64)\n   @ Base.Math ./math.jl:608\n [3] top-level scope\n   @ REPL[73]:1","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"DomainError有两个属性。val属性表示导致错误的值，msg属性详细描述消息细节。你可以通过创建Exception抽象类型的子类型来定义自己的异常。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"struct MyException <: Exception\n    params1\n    params2\n    # ...\n    paramsn\nend","category":"page"},{"location":"ch03controlflows/#堆栈跟踪","page":"控制流","title":"堆栈跟踪","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"堆栈跟踪是从异常处理中获得的一组非常重要的信息。函数catch_backtrace()在抛出异常时报告堆栈跟踪，而stacktrace()函数提供了对前面函数返回结果的解释。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"julia> try\n           sqrt(-1)\n       catch e\n           stacktrace(catch_backtrace())\n       end\n3-element Vector{Base.StackTraces.StackFrame}:\n sqrt at math.jl:582 [inlined]\n sqrt(x::Int64) at math.jl:608\n top-level scope at REPL[76]:2","category":"page"},{"location":"ch06datacollection/#数据集","page":"数据集","title":"数据集","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"每种编程语言都提供了一定的最小数量的数据结构集来将多个数据元素表示为容器。即数组、字典、集合和元组，等等。","category":"page"},{"location":"ch06datacollection/#预定义数据结构","page":"数据集","title":"预定义数据结构","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"1975年，Niklaus Wirth，一个著名的计算机专家和编程语言PASCAL的作者写了一本书：算法+数据结构=程序。明确强调了数据结构和算法在编程中的重要性。几乎没有任何现代编程语言不提供对数据结构的内建支持，Julia也不例外。许多数据结构是在Julia核心语言中定义的，而更广泛的数据结构是在像DataStrctures.jl这样的包中定义的。在本章中，我们重点介绍该语言在不需要使用任何附加包的情况下定义的数据结构，如：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"元组\n数组\n字典\n集合","category":"page"},{"location":"ch06datacollection/#元组","page":"数据集","title":"元组","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"元组在Julia中非常常见，以至于我们经常不把它们作为一种专门的数据结构来看待。在前面，我们介绍了元组的一些属性，下面将进行更详细的介绍。以下是它的功能概要：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"不变性\n异构性\n可在模式匹配中使用\n可通过索引访问元素","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"下面是一些例子：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"a = (1, \"string\", 1.0)\ntypeof(a)                   # 异构性\na[1]                        # 通过索引访问\na[1] = 6                    # 不变性\nb, c = a                    # 模型匹配\nb\nc","category":"page"},{"location":"ch06datacollection/#NTuple","page":"数据集","title":"NTuple","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"NTuple{N, T}是具有N个类型为T的元组的参数定义。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"NTuple{3, Int}","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"你可以像这样创建一个接受元组参数的方法：写成f(::NTuple{3, Int})而不要写成f(::Tuple{Int64, Int64, Int64})。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"当你希望创建一个包含特定模式的N个参数的元组时，可以使用函数ntuple。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"a = ntuple(x->4, 10)\ntypeof(a)\na = ntuple(i->i*1.0, 10)\ntypeof(a)","category":"page"},{"location":"ch06datacollection/#作为集的元组","page":"数据集","title":"作为集的元组","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Tuple可以作为元素集使用。这意味着它们可以被迭代，拥有集的典型函数，如length。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"length(a)\nfor i = 1:length(a)\n    println(a[i])\nend","category":"page"},{"location":"ch06datacollection/#作为类型参数的整数","page":"数据集","title":"作为类型参数的整数","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"观察NTuple类型的一个发现是，它有一个作为类型的整数参数。这同样适用于任何可变或不可变类型。让我们创建一个Point类型，它可以被用于2或3维情况。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"struct Point{N}\n    data::NTuple{N, Float32}\n    Point(d...)=new{length(d)}(d)\nend\nconst Point2D = Point{2}\nconst Point3D = Point{3}\nfunction dist(p1::Point2D, p2::Point2D)\n    dx, dy = (p1.data[1] - p2.data[1], p1.data[2] - p2.data[2])\n    return sqrt(dx*dx+dy*dy)\nend\nfunction dist(p1::Point3D, p2::Point3D)\n    dx, dy, dz = (p1.data[1] - p2.data[1],\n                  p1.data[2] - p2.data[2],\n                  p1.data[3] - p2.data[3])\n    return sqrt(dx*dx+dy*dy+dz*dz)\nend\ndist(Point(1, 2), Point(3, 4))\ndist(Point(1, 2, 3), Point(3, 4, 5))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"在前面的例子中，我们定义了Point{N}的别名Point2D和Point3D，为这两种类型定义了两个dist函数，并确保可以基于整数值2或3进行分派。Point{2}和Point{3}是两种不同的类型。由于NTuple是集类型，我们可以使用dist方法来处理Point{N}。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"struct Point{N}\n    data::NTuple{N, Float32}\n    Point(d...)=new{length(d)}(d)\nend\nfunction dist(p1::Point{N}, p2::Point{N}) where N\n    sumval = 0f0\n    for i=1:N\n        d = p1.data[i] - p2.data[i]\n        sumval += d*d\n    end\n    return sqrt(sumval)\nend\ndist(Point(1, 2), Point(3, 4))\ndist(Point(1, 2, 3), Point(3, 4, 5))\ndist(Point(1f0, 2f0, 3f0), Point(1, 2))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"如果我们不使用参数形式的Point{N}，而是使用Point，会是错误的吗？Point{2}和Point{3}是两种不同的类型。dist函数会为两种不同的类型分别编译吗？我们可以试一下。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"struct Point{N}\n    data::NTuple{N, Float32}\n    Point(d...)=new{length(d)}(d)\nend\nfunction dist(p1::Point, p2::Point)\n    N = length(p1.data)\n    sumval = 0f0\n    for i = 1:N\n        d = p1.data[i] - p2.data[i]\n        sumval += d*d\n    end\n    return sqrt(sumval)\nend\ndist(Point(1, 2),Point(3, 4))\ndist(Point(1, 2, 3), Point(3, 4, 5))\ndist(Point(1f0, 2f0, 3f0), Point(1, 2))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"现在，我们可以将Point{2}和Point{3}参数传递给同一个函数。这说明只创建了一个方法，没有为Point{2}和Point{3}版本编译两个方法。那个方式是正确的？这是一个设计决策，而不是编程语言的概念。Point2D和Point3D是可混合使用的吗？我们需要支持Point{N1}和Point{N2}的混合dist`方法吗？如果是，则下面是一种可能的实现方法。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"struct Point{N}\n    data::NTuple{N, Float32}\n    Point(d...)=new{length(d)}(d)\nend\nfunction dist(p1::Point{N}, p2::Point{N}) where N\n    sumval = 0f0\n    for i=1:N\n        d = p1.data[i] - p2.data[i]\n        sumval += d*d\n    end\n    return sqrt(sumval)\nend\nfunction dist(p1::Point{N1}, p2::Point{N2}) where {N1, N2}\n    N1 > N2 && return dist(p2, p1)\n    tp = Point(p1.data..., ntuple(i->0f0, N2-N1)...)\n    return dist(tp, p2)\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"我们为具有相同维数N的Point{N}创建了一个方法。\n然后我们创建了一个方法，可以输入不同维度的点。\n这里，我们假设第一个参数的维度小于第二个参数。\n如果第一个参数不小于第二个参数，我们通过翻转参数来调用方法。从而确保第一个参数的维数小于第二个(N1 < N2)。\n我们创建一个与p2维度相同的临时点(tp)，方法是向更高维度填充零，并调用dist(tp, p2)。","category":"page"},{"location":"ch06datacollection/#值参数","page":"数据集","title":"值参数","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"让我们看看下面的代码控制流：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"if val == 1\n    f1()\nelseif val == 2\n    f2()\nelseif val == 3\n    f3()\nelse\n    f4()\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"这些函数是否可以使用多分派而不是使用if...elseif...else？","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"struct MyVal{N}\n    MyVal(N)=new{N}()\nend\nf(::MyVal{N}) where N = N\nfunction f(::MyVal{1})\n    println(\"Called from 1\")\nend\nf(MyVal(2))\nf(MyVal(1))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"MyVal{N}基于N的值定义类型。\n方法f适用于MyVal{N}的所有值。\n仅为MyVal{1}定义了一个专用方法f。\n现在f(MyVal(2))调用一般方法，f(MyVal(1))调用特定方法。","category":"page"},{"location":"ch06datacollection/#单例","page":"数据集","title":"单例","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"当类型中没有属性时，只会为它创建一个对象。这样的对象称为单例。上面创建的值类型也是一个单例，因为该类型没有属性。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"MyVal(1) === MyVal(1)\nMyVal(1) === MyVal(2)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"MyVal{1}与MyVal{2}是不同的类型。因此，由初始化创建的对象是两个不同的对象。Julia虽然可以使用值参数，但它可能不是性能最优的方法。Julia内置提供了符合以上所有原则的Val{N}类型，我们将在Julia的性能管理一章中进一步讨论这个问题。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"note: Note\n不仅整数类型，即使符号也可以用作值类型参数。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"MyVal(:a)","category":"page"},{"location":"ch06datacollection/#范围","page":"数据集","title":"范围","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"有时我们需要增加或减少的具有连续或固定步长的数字。这称为范围。下面是一些例子：","category":"page"},{"location":"ch06datacollection/#UnitRange","page":"数据集","title":"UnitRange","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"a=1:5\ntypeof(a)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"a是一个UnitRange，这意味着它包含从1到5的所有数字。UnitRange的增量步长总是1。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"for i=a\n    println(i)\nend","category":"page"},{"location":"ch06datacollection/#StepRange","page":"数据集","title":"StepRange","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"b=1:2:5\ntypeof(b)\nfor i=b\n    println(i)\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"b是一个间隔为2的StepRange。","category":"page"},{"location":"ch06datacollection/#降序范围","page":"数据集","title":"降序范围","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"c=5:-1:1\ntypeof(c)\nfor i=c\n    println(i)\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"c是步长为-1的StepRange。所以在迭代时，我们按5到1的递减顺序输出。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"范围用于迭代、索引和初始化集。它们可以有更复杂的参数，也可以将浮点数用于初始值、步长和最终值。下面给出一个浮点值范围的例子。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"d=1:2.1:6.0\ntypeof(d)","category":"page"},{"location":"ch06datacollection/#数组","page":"数据集","title":"数组","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"数组可以被看作是将对象作为容器保存的具有特定类型的连续内存地址。它们可以通过索引和迭代访问。与元组不同，数组是可变的。可以添加、删除或修改数组中的元素。甚至其他数据结构(如队列和堆栈)也可以将数组作为容器来实现。本节将介绍数组的基础知识。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"数组表示为Array{T, N}，其中T为类型，N为维数。Array{T, 1}或一维数组的别名为Vector，Array{T, 2}的别名为Matrix。这两者在科学计算中都有特殊的意义。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"v = [1, 2, 3]\nm = [1 2 3]","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"v是一个Vector{Int64}或Array{Int64,1}。类似地，m是一个Matrix{Int64}或Array{Int64, 2}。多维数组可以由方括号([])内的空格()和分号(;)组合而成。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"m1 = [1 2 3; 4 5 6]\nm2 = [1 2; 3 4; 5 6]","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"可以看出，分号(;)在定义中充当行分隔符。","category":"page"},{"location":"ch06datacollection/#内存布局和索引","page":"数据集","title":"内存布局和索引","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"数组成员可以通过索引访问。下面是使用前面定义的矩阵m1和m2的一些例子：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"m1[1, 2]\nm1[2, 2]\nm2[1, 2]\nm2[2, 2]","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"因此，数组成员的访问方式为：array[row_index, column_index]。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"数组中的数据存储为分配给某个位置的连续内存块。索引根据索引值指向数组的特定位置。下图显示了m1和m2的内存布局：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"(Image: arraylayout)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"与C/C++中数据在这两种情况下都存储为1、2、3、4、5和6不同，Julia中的顺序与FORTRAN一样，以行为主顺序存储数据。这本质上意味着数据的存储方式是将一列中各行的所有元素都挨在一起，然后是下一列。这对于经常使用C/C++或Python编程的人来说，可能会有点不习惯。其次，Julia中的索引与FORTRAN一样从1开始，而不是0。","category":"page"},{"location":"ch06datacollection/#分页的效果","page":"数据集","title":"分页的效果","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"在行上运行内部循环，在列上运行外部循环这种内存分页，对于小数组可能无关紧要，但对于大到非常大的数组会带来很大的好处。在多维数组中，右边的维度必然构成外部循环，左边的维度必然指定为内部循环。推荐的伪码如下：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"for col=1:100000\n    for row=1:1000\n        do_something(m[row, col])\n    end\nend","category":"page"},{"location":"ch06datacollection/#构造函数","page":"数据集","title":"构造函数","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"下面是一些构造函数的示例：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Array{Int}(undef, 1, 2)\nArray{Int}(undef, 2)\nArray{Int, 2}(undef, (2, 3))\nArray{Float32}(undef, (2, 3))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"undef是一种特殊类型的对象，用于定义包含未定义值的数组。Julia通常是在实例化对象时对它们进行初始化的。数组是一种容器类型，有时需要在内部值还未知时就定义它们。数组的一般构造函数是Array{T,N}(undef, dims)，其中dims是一个大小为N的元组或一个有N个值的可变参数。在模板参数中指定N是可选的，人们也可以调用函数Array{T} (undef, dims)。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"对于Array{T,N}，当T是isbits类型时，数组被完全分配为未初始化的位模式。因此打印的值是不可预测的。例如：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"struct A\n    i::Int\n    f::Float64\nend\na = A(1, 1); isbits(a)\naar = Array{A}(undef,(2, 2))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"现在让我们看看以下非位类型数组的场景：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"struct T\n    a::A\n    b\nend\nb = T(A(1, 1), 1); isbits(b)\nbar = Array{T}(undef, (2, 2))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"当isbits为false时，虽然Array被分配为容器，但实际的对象还没被初始化。实际的对象需要在对数组进行适当的初始化时分配。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"bar[1, 1] = bar[2, 1] = bar[1, 2] = bar[2, 2] = b\nbar","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"你还可以发现数组的可变特性，元素在数组使用undef值初始化之后可以被赋值。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"就像N维的泛型Array{T,N}一样，Vector{T}和Matrix{T}也可以有类似的构造函数。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Vector{Int}(undef, 3)\nMatrix{Int}(undef, 3, 3)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"虽然构造函数是初始化Array的一种方法，但还有其他方便的方法，我们将在下面介绍。","category":"page"},{"location":"ch06datacollection/#zeros和ones","page":"数据集","title":"zeros和ones","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"zeros(Float32, (2, 3))\nones(Float32, (2, 3))\nones(UInt8, (2, 3))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"给定类型和维数，该函数创建一个数组，以指定的类型填充0或1。","category":"page"},{"location":"ch06datacollection/#trues和falses","page":"数据集","title":"trues和falses","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"让我们看看下面的两段代码：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"zb = zeros(Bool, (8, 8))\nsizeof(zb)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"可以看到，Bool变量占用一个字节的存储空间，而这个数组需要64个字节的数据。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"z = falses(8, 8)\nsizeof(z)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"因为所有的元素都用一个位表示，z的大小只有8个字节(64位)，它创建了一个BitArray，而不是Array。因为使用一个位来存储一个字节的信息，当元素为布尔值时，BitArray是一种高效的数组存储方式。与falses类似，trues(dims)用true位值初始化BitArray。","category":"page"},{"location":"ch06datacollection/#fill和similar","page":"数据集","title":"fill和similar","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"fill(val, dims)创建一个val值数组。数组的类型取决于val值的类型。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"a = fill(5.0, (2, 2))\na = fill(5, (2, 2))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"similar(a, elem_type, dims)通过使用数组a的元素默认类型和/或dims尺寸，创建一个未初始化的elem_type数组。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"b = similar(a, Int)","category":"page"},{"location":"ch06datacollection/#collect","page":"数据集","title":"collect","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"collect(elem_type, collection)是一个从数据集创建数组的实用方法。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"collect(1:3)\ncollect(Float64, 1:2:3)","category":"page"},{"location":"ch06datacollection/#reshape","page":"数据集","title":"reshape","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"数组在内存中是线性连续分配的，索引以行为主的格式指向它们。reshape是创建数组的另一种方便的方法。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"a = collect(1:16)\nb = reshape(a, (4, 4))\nc = reshape(b, (2, 8))\nd = reshape(c, (8, 2))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"虽然数组的形状改变了，但以行为主的数据排序仍然保持。","category":"page"},{"location":"ch06datacollection/#hcat,-vcat,-hvcat","page":"数据集","title":"hcat, vcat, hvcat","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"这些方法将输入数组组合起来创建一个新的数组对象。vcat创建一个数组，其中输入数组沿着维度1放置。在一组矩阵上，其效果是数组一个接一个地向下放置。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"vcat([1 2; 3 4], [5 6; 7 8], [9 10; 11 12])","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"hcat创建一个数组，其中输入数组沿着维度2放置。在一组矩阵上，其效果是数组一个接一个地向右放置。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"hcat([1 2; 3 4], [5 6; 7 8], [9 10; 11 12])","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"hvcat(rows::Tuple{Int}, arrays...)通过使用在第一个参数中给出的rows元组数据来指定每行中连接的参数个数，这样形成的行一个接一个地堆叠起来，形成最终的数组。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"hvcat((2, 2, 2), [1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12])","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"在前面的例子中，向量以2个为一组并排放置。这样就产生了3个中间矩阵。它们是：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"beginbmatrix\n1  3 \n2  4\nendbmatrix \nbeginbmatrix\n5  7 \n6  8\nendbmatrix和\nbeginbmatrix\n9  11 \n10  12\nendbmatrix","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"现在，把它们一个叠一个，就得到了最终的输出。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"hvcat(6, [1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12])","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"同样，在上面的例子中，将6个向量相邻放置，形成一个矩阵。","category":"page"},{"location":"ch06datacollection/#关联集","page":"数据集","title":"关联集","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"在关联集中，集的元素以键/值对的形式存储。可以通过索引键或对键进行高效搜索来访问这些值。常用的有字典、多维字典、集合(尽管集合只保留键而忽略值)。大多数关联集都派生自抽象类型AbstractDict{K, V}。","category":"page"},{"location":"ch06datacollection/#字典","page":"数据集","title":"字典","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Dict{K,V}是Julia中使用的一个简单的关联集。参数类型K用作键，类型V用作值。唯一的要求是必须为类型K定义一个哈希函数。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"d = Dict(\"a\"=>1, \"c\"=>2, \"b\"=>3)\nd[\"b\"]\nd[\"a\"]\nprintln(d)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Dict{K,V}不能为同一个键保存多个值。定义中重复的键将覆盖先前定义的值。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"d = Dict(\"a\"=>1, \"c\"=>2, \"b\"=>3, \"a\"=>4)","category":"page"},{"location":"ch06datacollection/#get方法","page":"数据集","title":"get方法","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"get(dict, key, defval)方法用于从字典对象中提取信息。下面是一些例子：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"get(d, \"a\", 3)\nget(d, \"e\", 0)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"当该键是字典的一部分时，将返回与该键相关的值。然而，当该键不存在时，将返回函数中指定的默认值。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"大多数情况下，Dict{K,V}对象被像数组一样使用，只不过索引是键。使用getindex或它的别名([])从字典中获取值。与get方法不同的是，当在字典中找不到键时，getindex会抛出一个错误异常。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"getindex(d, \"e\")\ngetindex(d, \"a\")\nd[\"e\"]","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"get!(dict, key, value)方法类似于get(dict, key, defval)方法，但是会在字典中键不可用的位置插入键值对。在前面的例子中：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"get!(d, \"a\", 0)\nget!(d, \"e\", 0)\nd","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"note: Note\n在Julia中，通常的惯例是在函数名的末尾添加一个叹号(!)字符来表示要改变函数的参数值。由于get!(dict, key, value)方法更改对象字典, 叹号字符被添加到末尾。","category":"page"},{"location":"ch06datacollection/#setindex!方法","page":"数据集","title":"setindex!方法","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"就像get方法类似，setindex!方法或其别名([])用作给左侧赋值。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"d[\"e\"] = 10","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"或比较不常用的用法：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"setindex!(d, 11, \"e\")","category":"page"},{"location":"ch06datacollection/#哈希化","page":"数据集","title":"哈希化","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"要使Dict{K,V}正常工作，需要实现hash(k::K, h::Int)。对于k的每个实例，函数返回一个唯一的整数。这种唯一性确保在Dict{k,V}中只存储一个键。","category":"page"},{"location":"ch06datacollection/#集合","page":"数据集","title":"集合","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Set是一个集，其中每个元素只能保留一个实例。集合中元素的顺序不重要。下面的示例给出了一些集合方法。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"s = Set([2 3 4 5 1 2 3])\n6 in s\n5 in s\nt = Set([4 5 7 8 9])","category":"page"},{"location":"ch06datacollection/#并和交","page":"数据集","title":"并和交","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"union(s, t)\nintersect(s, t)\nunion!(s, t)\ns","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"union!类似于union，但会更新第一个参数。类似于union，symdiff和setdiff方法被定义为对称差和集合差。issubset方法提供判断一个集合与另一个集合的子集关系。","category":"page"},{"location":"ch06datacollection/#迭代","page":"数据集","title":"迭代","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"迭代是集的基本操作之一。我们将介绍如何在集中使用各种迭代操作。","category":"page"},{"location":"ch06datacollection/#for循环","page":"数据集","title":"for循环","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Julia中经典的for循环是将一个索引变量映射到一个范围对象并遍历它。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"for i=5:-2:1\n    println(i)\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"循环不仅仅局限于范围对象。也可以使用其他类型的集。下面是一些例子：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"b = [1.0 2 3; 4 5 6; 7 8 9];\nfor i=b\n    println(i)\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"除了for...=以外，for...in也可以被使用。for循环的这种表示与前面类似，只是语法看起来更适合于集。让我们看看它在字典对象上的用法。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"for p in d\n    println(p)\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Dict{K,V}元素存储为Pair{K,V}，并默认打印为：K => V。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"for (k, v) in d\n    println(\"Key: \", k, \" Value: \", v)\nend","category":"page"},{"location":"ch06datacollection/#function...do","page":"数据集","title":"function...do","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"让我们来看一个函数，它以数组作为输入，并以数组的形式返回所有值的平方。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"function collect_square(v)\n    a = similar(v)\n    for i=1:length(v)\n        a[i] = v[i]*v[i]\n    end\n    return a\nend\ncollect_square(1:4)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"如果我们要扩展这个函数，使其在计算任意函数而不仅仅是平方后返回值，我们可以按以下方式扩展它：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"function collect_function(f::Function, v)\n    a = similar(v)\n    for i=1:length(v)\n        a[i] = f(v[i])\n    end\n    return a\nend\ncollect_function(x->x^3, 1:4)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"另一种调用相同方法的方式是使用function...do符号。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"collect_function(1:4) do x\n    return x^3\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"map是一个具有类似符号的函数。它将集元素的每个值映射给函数，并将函数求值的结果作为集返回。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"map(1:4) do x\n    return x^3\nend","category":"page"},{"location":"ch06datacollection/#迭代框架","page":"数据集","title":"迭代框架","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"我们看到了几个使用for循环遍历序列和集的例子。这实际上是通过完成迭代框架实现的。如果要编写自定义的迭代器，就需要实现这个框架。下面介绍了一些基本的思想。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"v = collect(3:2:10);\nfor i=v\n    println(i)\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"同样的可以写成以下形式：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"next = iterate(v)\nwhile next !== nothing\n    value, state = next\n    println(value)\n    next = iterate(v, state)\nend","category":"page"},{"location":"ch06datacollection/#迭代方法","page":"数据集","title":"迭代方法","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"iterate(collection)返回第一个元素和初始状态，如果不存在值则返回nothing。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"在前面示例的返回值(3,2)中，3是第一个元素的值，2是表示状态的内部参数。尽管它看起来像是下一个值的索引，但我们不应该有这种假设，因为它完全是由特定的实现来定义的。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"iterate(collection，state)返回下一个元素和状态，如果不存在额外的元素则返回nothing。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"必须为所有的迭代器类型实现迭代方法。","category":"page"},{"location":"ch06datacollection/#可选方法","page":"数据集","title":"可选方法","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"这些方法需要由迭代器作者选择性地定义。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"IteratorSize(IterType)是一个辅助方法，它表明迭代器是否具有长度或形状。基于此确定必须为集迭代器定义尺寸或/和长度方法。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Base.IteratorSize(Vector{Int})","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"IteratorEltype(IterType)是一个辅助方法，它决定迭代器是否具有特定的元素类型。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Base.IteratorEltype(Vector{Int})","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"eltype(IterType)返回迭代方法第一个参数的类型。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"eltype(Vector{Int})","category":"page"},{"location":"ch06datacollection/#实例","page":"数据集","title":"实例","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"我们创建一个Squares类型，它将提供一组直到类型中存储值为止的数字的平方序列。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"struct Squares\n    value::Int\nend\nBase.iterate(s::Squares) = s.value <= 0 ? nothing : (1, 2)\nBase.iterate(s::Squares, state) = s.value < state ? nothing : (state*state, state+1)\nfor i=Squares(3)\n    println(i)\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"上面的例子只适用于简单的for循环。使用collect方法创建数组还无法工作。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"collect(Squares(3))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"所以我们添加一个length方法来实现这个目的。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Base.length(s::Squares)=s.value\ncollect(Squares(3))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"数组可以被正确填充时，但类型是Any。定义eltype(IteratorType)方法将确保创建正确的数组类型。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Base.eltype(::Type{Squares}) = Int\neltype(Squares)\ncollect(Squares(3))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"note: Note\nType{Squares}是一种特殊类型，它的唯一实例对象是Squares。这是必需的，因为eltype是该类型本身而不是该类型实例的函数。","category":"page"},{"location":"ch06datacollection/#生成器和推导","page":"数据集","title":"生成器和推导","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"在Julia中，数组和集在科学计算中被广泛使用。语言必须提供创建和操作数组的方便途径。推导表示为创建这样的数组提供了便利。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"[i*i for i=1:3]\n[i*j for i=1:3, j=1:3]","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"在前面的示例中，推导式用于创建单维和多维数组。下面是一个索引可能依赖于另一个索引的示例。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"[i*j for i=1:3 for j=i:3]","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"推导式计算完整的数组，使用延迟执行迭代器(在需要时计算值，而不是所有元素)也会有所帮助。这被称为生成器。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"gen=(i*j for i=1:3 for j=i:3)\nfor v=gen\n    println(v)\nend","category":"page"},{"location":"ch10file/#文件","page":"文件","title":"文件","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"本章介绍将数据保存到永久存储设备中的概念，并展示如何使用诸如文件和数据库等不同种类的永久存储设备。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"","category":"page"},{"location":"ch10file/#持久化","page":"文件","title":"持久化","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"目前我们见到的大部分程序在某种程度上都是临时的，因为它们只运行一小段时间，产生一些输出，当程序结束时，数据也随之消失。如果再次运行程序，它将以全新的状态开始。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"另一类程序是持久的：它们长时间运行（或者一直运行）；它们至少将部分数据保存到永久设备（例如硬盘）中；如果关机后再次重启，它们会从上次结束的地方继续运行。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"持久程序的例子是各种操作系统，当计算机启动时它们就会一直运行；网络服务程序也是一个实例，它们持续运行，等待来自于互联网的各种请求。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"程序维护数据的一个最简单的方法是读写文本文件。我们已经见过程序读取文本文件；本章我们会看到程序写入文本文件。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"另外一个选择是将程序状态保存到数据库中，本章我也会演示如何使用一个简单的数据库。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"","category":"page"},{"location":"ch10file/#读和写","page":"文件","title":"读和写","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"文本文件是储存在诸如硬盘、闪存这类永久介质中的一系列字符。我们在9.1节中见过如何打开和读取一个文件。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"要写入一个文件，你必须以模式 \"w\" 作为第二个参数来打开它：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> fout = open(\"output.txt\", \"w\")\nIOStream(<file output.txt>)","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"如果文件已经存在，以写入模式打开文件会清除所有原始数据来形成一个空文档，因此要特别小心！如果文件不存在，则会新建一个。open 返回一个文件对象，write 函数将数据写入文件。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> line1 = \"This here's the wattle,\\n\";\njulia> write(fout, line1)\n24","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"返回值是写入文件的字符数。文件对象持续跟踪当前位置，因此当你再次调用 write 时，它在文件的末尾添加新数据。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> line2 = \"the emblem of our land.\\n\";\njulia> write(fout, line2)\n24","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"当写入结束后，你应该将文件关闭。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> close(fout)","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"如果你没有关闭文件，它只有在程序结束时才会自动关闭。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"","category":"page"},{"location":"ch10file/#格式","page":"文件","title":"格式","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"写入的参数必须是一个字符串，因此如果我们想在文件中放入其他值，必须将它们转换成字符串。最简单的方法是使用 string 或字符串插入：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> fout = open(\"output.txt\", \"w\");\njulia> write(fout, string(150))\n3","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"另一个选择是使用 print(ln) 函数家族。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> camels = 42;\njulia> println(fout, \"I have spotted $camels camels.\")","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"一个更强大的选项是使用 @printf 宏，它使用C语言风格来格式化字符串，详细可参考相关文档。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"","category":"page"},{"location":"ch10file/#文件名和路径","page":"文件","title":"文件名和路径","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"文件被组织到目录（也叫做“文件夹”）内。每个运行着的程序都有一个“当前目录”，它是大部分操作的默认目录。例如，当你打开一个文件用于读取时，Julia在当前目录中查找它。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"函数 pwd 返回当前目录的名字：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> cwd = pwd()\n\"C:\\\\Users\\\\UNAME\\\\AppData\\\\Local\\\\Programs\\\\Julia\\\\Julia-1.6.0\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"pwd 代表“打印当前工作目录”（print working directory）。本示例的结果展示了Windows平台下Julia的默认当前目录是其安装目录，这里 UNAME 代表你登录Windows的用户名。像 \"C:\\\\Users\\\\UNAME\\\\AppData\\\\Local\\\\Programs\\\\Julia\\\\Julia-1.6.0\" 这样标识一个文件或目录的字符串叫做路径。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"一个简单的文件名如 memo.txt 也被认为是一个路径，但由于是相对于当前目录而言的，因此它是一个相对路径。如果当前目录是 C:\\\\Users\\\\UNAME\\\\AppData\\\\Local\\\\Programs\\\\Julia\\\\Julia-1.6.0，文件名 memo.txt 将会指向 C:\\\\Users\\\\UNAME\\\\AppData\\\\Local\\\\Programs\\\\Julia\\\\Julia-1.6.0\\\\memo.txt。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"以盘符（Windows系统）或 /（Linux系统）开始的路径不依赖于当前目录；它叫做一个绝对路径。要返回一个文件的绝对路径，你可以使用 abspath：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> abspath(\"memo.txt\")\n\"C:\\\\Users\\\\UNAME\\\\AppData\\\\Local\\\\Programs\\\\Julia\\\\Julia-1.6.0\\\\memo.txt\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"Julia也提供了其他作用于文件名和路径的函数。例如，ispath 检验是否存在一个文件或目录：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> ispath(\"memo.txt\")\ntrue","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"如果存在，isdir 检验它是否为目录：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> isdir(\"memo.txt\")\nfalse\njulia> isdir(\"../Julia-1.6.0\")\ntrue","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"相似地，isfile 检验它是否为文件。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"readdir 返回一个由给定目录中的文件（和其他目录）组成的数组：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> readdir(cwd)\n3-element Array{String,1}:\n \"memo.txt\"\n \"music\"\n \"photos\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"为了展示这些函数，下面的例子“遍历”一个目录，打印所有文件的名字，然后对所有目录递归地调用自己。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"function walk(dirname)\n    for name in readdir(dirname)\n        path = joinpath(dirname, name)\n        if isfile(path)\n            println(path)\n        else\n            walk(path)\n        end\n    end\nend","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"joinpath 接受一个目录和一个文件名，并将它们连接成一个完整的路径。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"Julia提供了一个名为 walkdir 的函数（见帮助文档），它与该函数相似但功能更多。作为练习，阅读帮助文档并使用它打印给定目录和它的子目录中的文件。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"","category":"page"},{"location":"ch10file/#捕捉异常","page":"文件","title":"捕捉异常","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"当你试图读写文件时，很多地方可能发生错误。如果试图打开一个不存在的文件，你会得到一个系统错误 SystemError：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> fin = open(\"bad_file\")\nERROR: SystemError: opening file \"bad_file\": 没有那个文件或目录","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"如果你没有访问一个文件的权限：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> fout = open(\"/etc/passwd\", \"w\")\nERROR: SystemError: opening file \"/etc/passwd\": 权限不够","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"为了避免这些错误，你可以使用诸如 ispath 和 isfile 这类函数，但它会花费大量时间和代码来检查所有的可能。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"更好的办法是在问题出现的时候才去处理，而这正是 try 语句做的事情。它的语法与 if 语句相似：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"try\n    fin = open(\"bad_file.txt\")\ncatch exc\n    println(\"Something went wrong: $exc\")\nend","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"Julia开始执行 try 分支。如果一切正常，它会跳过 catch 分支并继续运行。如果发生异常，它会跳出 try 分支转而运行 catch 分支。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"使用 try 语句处理异常叫做捕获一个异常。在这个例子中，异常分支只是打印一条出错信息，这显然没有什么用处。一般来说，捕获到一条异常就给了你一个修补问题的机会：或者尝试重新运行，或者至少可以优雅地结束程序。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"在执行状态改变或者使用如文件一类资源的代码中，通常在代码结束时要进行清理工作（例如关闭文件）。异常可能会使这项工作变得复杂，因为它们有可能使一组代码在正常结束前退出。finally 关键字提供了不管给定代码块如何退出都会执行一些代码的方法：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"f = open(\"output.txt\")\ntry \n    line = readline(f)\n    println(line)\nfinally\n    close(f)\nend","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"函数 close 总会被执行。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"","category":"page"},{"location":"ch10file/#带分隔符的文件","page":"文件","title":"带分隔符的文件","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"如果需要读写一个矩阵，可使用带分割符的文件，下面给出一些例子：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> using DelimitedFiles\n\njulia> x = [1;2;3;4];\n\njulia> y = [5;6;7;8];\n\njulia> open(\"delim_file.txt\",\"w\") do io\n           writedlm(io, [x y])\n       end\n\njulia> readdlm(\"delim_file.txt\",'\\t', Int, '\\n')\n4×2 Matrix{Int64}:\n 1  5\n 2  6\n 3  7\n 4  8\n\njulia> rm(\"delim_file.txt\")","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"readdlm中第一个参数为要读入的文件；第二个参数为矩阵的分隔符，如果省略则表示分隔符是一个或多个空格；第三个参数是矩阵元素的类型，如果省略，则当所有数据都是数字时，结果将是一个数字数组，如果某些元素不能被解析为数字，则返回由数字和字符串组成的异构数组；第四个参数标识一行结束的分隔符，如果省略则表示为\\n。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"下面给出一个省略第二到第四各参数的例子：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> x = [1;2;3;4];\n\njulia> y = [\"a\";\"b\";\"c\";\"d\"];\n\njulia> open(\"delim_file.txt\",\"w\") do io\n           writedlm(io, [x y])\n       end\n\njulia> readdlm(\"delim_file.txt\")\n4×2 Matrix{Any}:\n 1  \"a\"\n 2  \"b\"\n 3  \"c\"\n 4  \"d\"\n\njulia> rm(\"delim_file.txt\")","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"上面两个例子同时给出了使用writedlm向文件中写一个矩阵的例子。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"","category":"page"},{"location":"ch10file/#TOML","page":"文件","title":"TOML","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"TOML的目标是采用明显的语义使其成为一种易于阅读的最小配置文件格式，其文件后缀为.toml。TOML被设计成无歧义地映射到哈希表。TOML很容易被解析为各种语言中的数据结构。Julia内置了对该数据结构的支持。下面将对该文件的编写规范进行介绍。","category":"page"},{"location":"ch10file/#一般规定","page":"文件","title":"一般规定","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"TOML是区分大小写的\nTOML文件必须是有效的UTF-8编码的Unicode文档\n空白的含义是制表符（0x09）或空格（0x20）\n新一行的含义是换行（0x0A）或回车换行（0x0D 0x0A）","category":"page"},{"location":"ch10file/#注释","page":"文件","title":"注释","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"一行中井号以后的部分被标记为注释，但井号在字符串中的情况除外。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# This is a full-line comment\nkey = \"value\"  # This is a comment at the end of a line\nanother = \"# This is not a comment\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"注释中不允许出现制表符以外的控制字符（U+0000到U+0008, U+000A到U+001F, U+007F）。","category":"page"},{"location":"ch10file/#键/值对","page":"文件","title":"键/值对","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"TOML文档的主要构建块是键/值对。键在等号的左侧，值在右侧。键名和值周围的空白被忽略。键、等号和值必须在同一行上(尽管有些值可以在多行上分开)。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"key = \"value\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"值必须是以下类型中的一种：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"String\nInteger\nFloat\nBoolean\nOffset Date-Time\nLocal Date-Time\nLocal Date\nLocal Time\nArray\nInline Table","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"值必须被给出。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"key = # INVALID","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"每个键/值对都要新起一行(或EOF)。(例外情况参见内联表)","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"first = \"Tom\" last = \"Preston-Werner\" # INVALID","category":"page"},{"location":"ch10file/#键","page":"文件","title":"键","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"键可以不使用引号，也可以使用引号，或点号。不带引号的键只能是ASCII字母、ASCII数字、下划线和破折号(A-Za-z0-9_-)。注意，不使用引号的键允许只由ASCII数字组成，例如1234，但总是被解释为字符串。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"key = \"value\"\nbare_key = \"value\"\nbare-key = \"value\"\n1234 = \"value\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"带引号的键与基本字符串或字面字符串遵循完全相同的规则，并允许你使用更广泛的键名集。除非绝对必要，最好使用不带引号的键。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"\"127.0.0.1\" = \"value\"\n\"character encoding\" = \"value\"\n\"ʎǝʞ\" = \"value\"\n'key2' = \"value\"\n'quoted \"value\"' = \"value\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"不带引号的键必须是非空的，带引号的键可以是空的(但不鼓励这样使用)。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"= \"no key name\"  # INVALID\n\"\" = \"blank\"     # VALID but discouraged\n'' = 'blank'     # VALID but discouraged","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"点号键是用点连接的不带引号键或带引号键的序列。这样可以将相似的属性分组在一起:","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"name = \"Orange\"\nphysical.color = \"orange\"\nphysical.shape = \"round\"\nsite.\"google.com\" = true","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"有关点号键定义的表的详细信息，请参阅下面的表部分。点分隔部分周围的空白将被忽略。但是，最好不要使用任何多余的空白。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"fruit.name = \"banana\"     # this is best practice\nfruit. color = \"yellow\"    # same as fruit.color\nfruit . flavor = \"banana\"   # same as fruit.flavor","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"缩进被视为空白并忽略。多次定义一个键是无效的。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# DO NOT DO THIS\nname = \"Tom\"\nname = \"Pradyun\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"注意，不带引号的键和带引号的键是等价的:","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# THIS WILL NOT WORK\nspelling = \"favorite\"\n\"spelling\" = \"favourite\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"只要键还没有被直接定义，你就仍然可以对它和其中的名称进行写入。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# This makes the key \"fruit\" into a table.\nfruit.apple.smooth = true\n\n# So then you can add to the table \"fruit\" like so:\nfruit.orange = 2\n\n# THE FOLLOWING IS INVALID\n\n# This defines the value of fruit.apple to be an integer.\nfruit.apple = 1\n\n# But then this treats fruit.apple like it's a table.\n# You can't turn an integer into a table.\nfruit.apple.smooth = true","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"不建议无序地定义点号键。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# VALID BUT DISCOURAGED\n\napple.type = \"fruit\"\norange.type = \"fruit\"\n\napple.skin = \"thin\"\norange.skin = \"thick\"\n\napple.color = \"red\"\norange.color = \"orange\"\n\n# RECOMMENDED\n\napple.type = \"fruit\"\napple.skin = \"thin\"\napple.color = \"red\"\n\norange.type = \"fruit\"\norange.skin = \"thick\"\norange.color = \"orange\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"由于不带引号的键只能由ASCII整数组成，因此可以编写看起来像浮点数但实际上是由2部分组成的点号键。除非你有很好的理由(你可能没有)，否则不要这样做。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"3.14159 = \"pi\"","category":"page"},{"location":"ch10file/#字符串","page":"文件","title":"字符串","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"有四种表达字符串的方法:基本、多行基本、字面和多行字面。所有字符串只能包含有效的UTF-8字符。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"基本字符串由引号(\")包围。可以使用任何Unicode字符，但必须转义的字符除外:引号、反斜杠和制表符以外的控制字符(U+0000到U+0008、U+000A到U+001F、U+007F)。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"str = \"I'm a string. \\\"You can quote me\\\". Name\\tJos\\u00E9\\nLocation\\tSF.\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"为方便起见，一些常用字符具有紧凑的转义序列。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"\\b         - backspace       (U+0008)\n\\t         - tab             (U+0009)\n\\n         - linefeed        (U+000A)\n\\f         - form feed       (U+000C)\n\\r         - carriage return (U+000D)\n\\\"         - quote           (U+0022)\n\\\\         - backslash       (U+005C)\n\\uXXXX     - unicode         (U+XXXX)\n\\UXXXXXXXX - unicode         (U+XXXXXXXX)","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"任何Unicode字符都可以用\\uXXXX或\\UXXXXXXXX形式转义。转义码必须是有效的Unicode标量值。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"没有在上面列出的所有其他转义序列都是保留的，如果使用它们，TOML会产生一个错误。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"有时你需要表达文本段落(例如翻译文件)或想要将一个很长的字符串分成多行。这在TOML里很简单。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"多行基本字符串每边被三个引号包围，并允许换行。紧跟在开始分隔符后面的换行符将被裁剪。所有其他空格和换行符保持不变。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"str1 = \"\"\"\nRoses are red\nViolets are blue\"\"\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"TOML解析器可以自由地将换行符规范化为对其平台有意义的内容。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# On a Unix system, the above multi-line string will most likely be the same as:\nstr2 = \"Roses are red\\nViolets are blue\"\n\n# On a Windows system, it will most likely be equivalent to:\nstr3 = \"Roses are red\\r\\nViolets are blue\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"如果要写长字符串而不引入额外的空格，请使用“行结束反斜杠”。当一行中最后一个非空白字符是未转义的\\时，它将直到下一个非空白字符或结束分隔符的所有空白字符(包括换行符)一起裁剪掉。对基本字符串有效的所有转义序列对多行基本字符串也有效。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# The following strings are byte-for-byte equivalent:\nstr1 = \"The quick brown fox jumps over the lazy dog.\"\n\nstr2 = \"\"\"\nThe quick brown \\\n\n\n  fox jumps over \\\n    the lazy dog.\"\"\"\n\nstr3 = \"\"\"\\\n       The quick brown \\\n       fox jumps over \\\n       the lazy dog.\\\n       \"\"\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"可以使用任何Unicode字符，但必须转义的字符除外:反斜杠和制表符、换行符和回车符以外的控制字符(U+0000到U+0008、U+000B、U+000C、U+000E到U+001F、U+007F)。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"你可以在多行基本字符串的任何位置写入一个引号或两个相邻的引号。它们也可以直接写在分隔符内。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"str4 = \"\"\"Here are two quotation marks: \"\". Simple enough.\"\"\"\n# str5 = \"\"\"Here are three quotation marks: \"\"\".\"\"\"  # INVALID\nstr5 = \"\"\"Here are three quotation marks: \"\"\\\".\"\"\"\nstr6 = \"\"\"Here are fifteen quotation marks: \"\"\\\"\"\"\\\"\"\"\\\"\"\"\\\"\"\"\\\".\"\"\"\n\n# \"This,\" she said, \"is just a pointless statement.\"\nstr7 = \"\"\"\"This,\" she said, \"is just a pointless statement.\"\"\"\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"如果你经常使用Windows路径或正则表达式的说明符，那么必须每次都转义反斜杠会很乏味且容易出错。为了方便，TOML支持完全不允许转义的字面值字符串。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"字面值字符串由单引号包围。像基本字符串一样，它们必须在同一行中:","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# What you see is what you get.\nwinpath  = 'C:\\Users\\nodejs\\templates'\nwinpath2 = '\\\\ServerX\\admin$\\system32\\'\nquoted   = 'Tom \"Dubs\" Preston-Werner'\nregex    = '<\\i\\c*\\s*>'","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"因为没有转义，所以没有办法在由单引号括起来的字面值字符串中写单引号。幸运的是，TOML提供的字面值字符串多行版本解决了这个问题。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"多行字面值字符串在每边由三个单引号包围，并允许换行。就像字面值字符串一样，没有转义。紧跟在开始分隔符后面的换行符将被裁剪。分隔符之间的所有其他内容都按原样解释，无需修改。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"regex2 = '''I [dw]on't need \\d{2} apples'''\nlines  = '''\nThe first newline is\ntrimmed in raw strings.\n   All other whitespace\n   is preserved.\n'''","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"你可以在多行字面值字符串的任何地方写入1或2个单引号，但三个或更多单引号序列是不允许的。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"quot15 = '''Here are fifteen quotation marks: \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"'''\n\n# apos15 = '''Here are fifteen apostrophes: ''''''''''''''''''  # INVALID\napos15 = \"Here are fifteen apostrophes: '''''''''''''''\"\n\n# 'That,' she said, 'is still pointless.'\nstr = ''''That,' she said, 'is still pointless.''''","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"字面值字符串中不允许使用制表符以外的控制字符。因此，对于二进制数据，建议使用Base64或其他合适的ASCII或UTF-8编码。该编码的处理将是特定于应用程序的。","category":"page"},{"location":"ch10file/#整数","page":"文件","title":"整数","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"正数可以用加号作为前缀。负数前面有一个减号。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"int1 = +99\nint2 = 42\nint3 = 0\nint4 = -17","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"对于较大的数字，可以在数字之间使用下划线以增强可读性。每个下划线两边必须至少有一位数字包围。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"int5 = 1_000\nint6 = 5_349_221\nint7 = 53_49_221  # Indian number system grouping\nint8 = 1_2_3_4_5  # VALID but discouraged","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"前导零是不允许的。整数值-0和+0是有效的并与不带前缀的零相同。非负整数值也可以用十六进制、八进制或二进制表示。在这些格式中，前导+是不允许的，前导零是允许的(在前缀之后)。十六进制值不区分大小写。数字之间允许有下划线(但前缀和值之间不允许有下划线)。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# hexadecimal with prefix `0x`\nhex1 = 0xDEADBEEF\nhex2 = 0xdeadbeef\nhex3 = 0xdead_beef\n\n# octal with prefix `0o`\noct1 = 0o01234567\noct2 = 0o755 # useful for Unix file permissions\n\n# binary with prefix `0b`\nbin1 = 0b11010110","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"任意的64位带符号整数(从−2⁶³到2⁶³ − 1)都可以被接受并无损地处理。如果一个整数不能无损地表示，则会抛出一个错误。","category":"page"},{"location":"ch10file/#浮点数","page":"文件","title":"浮点数","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"浮点数被表示为IEEE 754 64位二进制值。浮点数由整数部分(遵循与十进制整数值相同的规则)和小数部分和（或）指数部分组成。如果同时存在小数部分和指数部分，小数部分必须在指数部分之前。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# fractional\nflt1 = +1.0\nflt2 = 3.1415\nflt3 = -0.01\n\n# exponent\nflt4 = 5e+22\nflt5 = 1e06\nflt6 = -2E-2\n\n# both\nflt7 = 6.626e-34","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"小数部分是指小数点后面跟着一个或多个的数字。指数部分是一个E(大写或小写)后跟一个整数部分(它遵循与十进制整数值相同的规则，但可以包含前导零)。如果使用小数点，在每边至少有一个数字包围它。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# INVALID FLOATS\ninvalid_float_1 = .7\ninvalid_float_2 = 7.\ninvalid_float_3 = 3.e+20","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"与整数类似，你可以使用下划线来增强可读性。每个下划线必须至少被一位数字包围。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"flt8 = 224_617.445_991_228","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"浮点值-0.0和+0.0是有效的，并根据IEEE 754进行映射。还可以表示特殊的浮点值。它们总是小写的。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# infinity\nsf1 = inf  # positive infinity\nsf2 = +inf # positive infinity\nsf3 = -inf # negative infinity\n\n# not a number\nsf4 = nan  # actual sNaN/qNaN encoding is implementation-specific\nsf5 = +nan # same as `nan`\nsf6 = -nan # valid, actual encoding is implementation-specific","category":"page"},{"location":"ch10file/#布尔值","page":"文件","title":"布尔值","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"布尔值就是你习惯使用的符号并总是小写。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"bool1 = true\nbool2 = false","category":"page"},{"location":"ch10file/#带偏移量的日期时间","page":"文件","title":"带偏移量的日期时间","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"要明确地表示一个特定的时间点，可以使用带有偏移量的RFC 3339格式的日期时间。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"odt1 = 1979-05-27T07:32:00Z\nodt2 = 1979-05-27T00:32:00-07:00\nodt3 = 1979-05-27T00:32:00.999999-07:00","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"为了可读性起见，可以用空格字符替换日期和时间之间的T分隔符(RFC 3339第5.6节允许这样做)。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"odt4 = 1979-05-27 07:32:00Z","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"精度可以达到毫秒。小数秒的进一步精度是特定于实现的。如果值包含的精度大于实现所支持的精度，则必须截断额外的精度，而不是舍入。","category":"page"},{"location":"ch10file/#当地日期时间","page":"文件","title":"当地日期时间","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"如果省略RFC 3339格式的日期-时间的偏移量，它将表示给定的日期-时间，与偏移量或时区没有任何关系。如果没有额外的信息，它就不能转换为时间中的一个即时。转换到即时(如果需要的话)是特定于实现的。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"ldt1 = 1979-05-27T07:32:00\nldt2 = 1979-05-27T00:32:00.999999","category":"page"},{"location":"ch10file/#当地日期","page":"文件","title":"当地日期","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"如果只包含RFC 3339格式化日期-时间的日期部分，那么它将表示一个整天，与偏移量或时区没有任何关系。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"ld1 = 1979-05-27","category":"page"},{"location":"ch10file/#当地时间","page":"文件","title":"当地时间","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"如果只包含RFC 3339格式化日期-时间的时间部分，它将表示一天中的时间，与特定的日期或任何偏移量或时区没有任何关系。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"lt1 = 07:32:00\nlt2 = 00:32:00.999999","category":"page"},{"location":"ch10file/#数组","page":"文件","title":"数组","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"数组是方括号，里面有值。空格将被忽略。元素之间用逗号分隔。数组可以包含键/值对中允许的相同数据类型的值。不同类型的值也可以混合使用。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"integers = [ 1, 2, 3 ]\ncolors = [ \"red\", \"yellow\", \"green\" ]\nnested_arrays_of_ints = [ [ 1, 2 ], [3, 4, 5] ]\nnested_mixed_array = [ [ 1, 2 ], [\"a\", \"b\", \"c\"] ]\nstring_array = [ \"all\", 'strings', \"\"\"are the same\"\"\", '''type''' ]\n\n# Mixed-type arrays are allowed\nnumbers = [ 0.1, 0.2, 0.5, 1, 2, 5 ]\ncontributors = [\n  \"Foo Bar <foo@example.com>\",\n  { name = \"Baz Qux\", email = \"bazqux@example.com\", url = \"https://example.com/bazqux\" }\n]","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"数组可以跨多行。允许在数组的最后一个值后面使用结束逗号(也称为尾随逗号)。任意数量的换行符和注释可以出现在值、逗号和右括号之后。数组值和逗号之间的缩进被视为空白并被忽略。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"integers2 = [\n  1, 2, 3\n]\n\nintegers3 = [\n  1,\n  2, # this is ok\n]","category":"page"},{"location":"ch10file/#表","page":"文件","title":"表","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"表(也称为哈希表或字典)是键/值对的集合。它们由一行中使用方括号包围的头文件定义。你可以很容易地区分头文件和数组，因为数组永远都是值。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"[table]","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"在下一个头文件或EOF之前，都是该表的键/值。表中的键/值对不能保证以任何特定的顺序排列。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"[table-1]\nkey1 = \"some string\"\nkey2 = 123\n\n[table-2]\nkey1 = \"another string\"\nkey2 = 456","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"表的命名规则与键的命名规则相同(参见上面的键的定义)。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"[dog.\"tater.man\"]\ntype.name = \"pug\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"键周围的空格将被忽略。但是，最佳实践是不要使用任何多余的空格。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"[a.b.c]            # this is best practice\n[ d.e.f ]          # same as [d.e.f]\n[ g .  h  . i ]    # same as [g.h.i]\n[ j . \"ʞ\" . 'l' ]  # same as [j.\"ʞ\".'l']","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"缩进被视为空白并被忽略。如果你不想逐一指定所有的上级表，则不需要指定。TOML知道如何为你做到这一点。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# [x] you\n# [x.y] don't\n# [x.y.z] need these\n[x.y.z.w] # for this to work\n\n[x] # defining a super-table afterward is ok","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"没有键/值对的空表是允许的。与键一样，你不能对表进行多次定义。这样做是无效的。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# DO NOT DO THIS\n\n[fruit]\napple = \"red\"\n\n[fruit]\norange = \"orange\"\n\n# DO NOT DO THIS EITHER\n\n[fruit]\napple = \"red\"\n\n[fruit.apple]\ntexture = \"smooth\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"不鼓励无序定义表。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# VALID BUT DISCOURAGED\n[fruit.apple]\n[animal]\n[fruit.orange]\n\n# RECOMMENDED\n[fruit.apple]\n[fruit.orange]\n[animal]","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"最上一级的表，也称为根表，是从文档的开头开始，在第一个表头(或EOF)之前结束。与其他表不同，它是匿名的，不能被重新定位。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# Top-level table begins.\nname = \"Fido\"\nbreed = \"pug\"\n\n# Top-level table ends.\n[owner]\nname = \"Regina Dogman\"\nmember_since = 1999-08-04","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"点号键为最后一个键之前的每个键创建并定义一个表，前提是这些表以前没有创建过。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"fruit.apple.color = \"red\"\n# Defines a table named fruit\n# Defines a table named fruit.apple\n\nfruit.apple.taste.sweet = true\n# Defines a table named fruit.apple.taste\n# fruit and fruit.apple were already created","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"由于表不能重复定义，所以不允许使用[table]头重新定义这样的表。同样，不允许使用点号键重新定义已经以[table]形式定义的表。然而，[table]形式可以用来在点号键定义的表中定义子表。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"[fruit]\napple.color = \"red\"\napple.taste.sweet = true\n\n# [fruit.apple]  # INVALID\n# [fruit.apple.taste]  # INVALID\n\n[fruit.apple.texture]  # you can add sub-tables\nsmooth = true","category":"page"},{"location":"ch10file/#内联表","page":"文件","title":"内联表","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"内联表为表示表提供了更紧凑的语法。它们对于分组数据特别有用，否则这些数据很快就会变得冗长。内联表完全在大括号{和}中定义。在大括号内，可能出现零个或多个以逗号分隔的键/值对。键/值对的形式与标准表中的键/值对相同。允许所有值类型，包括内联表。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"内联表应该出现在单行上。在内联表的最后一个键/值对之后不允许使用终止逗号(也称为尾随逗号)。在大括号之间不允许换行，除非换行在值内有效。尽管如此，还是强烈建议不要将内联表拆分为多行。如果你发现的确需要这样做，这意味着你应该使用标准表了。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"name = { first = \"Tom\", last = \"Preston-Werner\" }\npoint = { x = 1, y = 2 }\nanimal = { type.name = \"pug\" }","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"上面的内联表与下面的标准表定义相同:","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"[name]\nfirst = \"Tom\"\nlast = \"Preston-Werner\"\n\n[point]\nx = 1\ny = 2\n\n[animal]\ntype.name = \"pug\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"内联表是完全自包含的，并在其中定义所有键和子表。不能再在大括号之外添加键和子表。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"[product]\ntype = { name = \"Nail\" }\n# type.edible = false  # INVALID","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"类似地，内联表也不能用于向已经定义的表添加键或子表。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"[product]\ntype.name = \"Nail\"\n# type = { edible = false }  # INVALID","category":"page"},{"location":"ch10file/#表数组","page":"文件","title":"表数组","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"还没有介绍的最后一种语法允许写表数组。这些可以通过使用双括号中带有名称的头来表示。该头文件的第一个实例定义数组及其第一个表元素，每个后续实例在该数组中创建并定义一个新的表元素。表按出现的顺序插入到数组中。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"[[products]]\nname = \"Hammer\"\nsku = 738594937\n\n[[products]]  # empty table within the array\n\n[[products]]\nname = \"Nail\"\nsku = 284758393\n\ncolor = \"gray\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"任何对表数组的引用都指向该数组中最近定义的表元素。这允许你在最近的表中定义子表，甚至是子表数组。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"[[fruits]]\nname = \"apple\"\n\n[fruits.physical]  # subtable\ncolor = \"red\"\nshape = \"round\"\n\n[[fruits.varieties]]  # nested array of tables\nname = \"red delicious\"\n\n[[fruits.varieties]]\nname = \"granny smith\"\n\n\n[[fruits]]\nname = \"banana\"\n\n[[fruits.varieties]]\nname = \"plantain\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"如果表或表数组的父元素是数组元素，则必须在定义子元素之前已经定义了该元素。试图颠倒这种顺序会在解析时产生错误。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# INVALID TOML DOC\n[fruit.physical]  # subtable, but to which parent element should it belong?\ncolor = \"red\"\nshape = \"round\"\n\n[[fruit]]  # parser must throw an error upon discovering that \"fruit\" is\n           # an array rather than a table\nname = \"apple\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"试图添加到静态定义的数组中，即使该数组是空的，也必须在解析时产生错误。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# INVALID TOML DOC\nfruits = []\n\n[[fruits]] # Not allowed","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"试图定义一个与已经建立的数组同名的普通表，在解析时必然产生错误。试图将普通表重定义为数组同样会产生解析时错误。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"# INVALID TOML DOC\n[[fruits]]\nname = \"apple\"\n\n[[fruits.varieties]]\nname = \"red delicious\"\n\n# INVALID: This table conflicts with the previous array of tables\n[fruits.varieties]\nname = \"granny smith\"\n\n[fruits.physical]\ncolor = \"red\"\nshape = \"round\"\n\n# INVALID: This array of tables conflicts with the previous table\n[[fruits.physical]]\ncolor = \"green\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"你也可以在适当的地方使用内联表:","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"points = [ { x = 1, y = 2, z = 3 },\n           { x = 7, y = 8, z = 9 },\n           { x = 2, y = 4, z = 8 } ]","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"在Julia中使用TOML.parsefile解析输入文件，TOML.print将数据打印成TOML格式。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> using TOML\n\njulia> data = Dict(\n           \"names\" => [\"Julia\", \"Julio\"],\n           \"age\" => [10, 20]\n       );\n\njulia> fname = tempname();\n\njulia> open(fname, \"w\") do io\n           TOML.print(io, data)\n       end\n\njulia> TOML.parsefile(fname)\nDict{String, Any} with 2 entries:\n  \"names\" => [\"Julia\", \"Julio\"]\n  \"age\"   => [10, 20]","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"","category":"page"},{"location":"ch10file/#数据库","page":"文件","title":"数据库","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"数据库是“按照数据结构来组织、存储和管理数据的仓库（文件）”。Julia为多种数据库提供了接口，方便我们使用和开发。本节以最简单的SQLite数据库为例来介绍在Julia环境下数据库的简单用法。在使用SQLite数据库前，我们要先在电脑中安装它，一般Linux系统都自带了该库，Windows系统需要自己安装，由于安装过程比较简单，请读者参照官方网站自行安装。有了数据库后，我们还要在Julia中安装相应的模块：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"(@v1.6) pkg> add DataFrames, SQLite","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"接下来我们就可以使用相关函数对数据库进行操作了：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> using DataFrames, SQLite\njulia> db = SQLite.DB(\"test.db\")\nSQLite.DB(\"test.db\")","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"SQLite.DB 函数用于创建或打开一个sqlite数据库文件，当文件存在时就打开它，否则就创建一个新的数据库文件。变量 db 存储函数返回的数据库对象，我们可以使用该变量对数据库进行各种操作：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> DBInterface.execute(db, \"create table test (id integer primary key, value text)\");\njulia> DBInterface.execute(db, \"insert into test (id, value) values (101,'eenie')\");\njulia> DBInterface.execute(db, \"insert into test (id, value) values (102,'meenie')\");\njulia> DBInterface.execute(db, \"insert into test (id, value) values (103,'miny')\");\njulia> DBInterface.execute(db, \"insert into test (id, value) values (104,'mo')\");\njulia> DBInterface.execute(db, \"select * from test\") |> DataFrame\n4×2 DataFrame\n│ Row │ id    │ value  │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 101   │ eenie  │\n│ 2   │ 102   │ meenie │\n│ 3   │ 103   │ miny   │\n│ 4   │ 104   │ mo     │","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"这里使用 DBInterface.execute 函数对表格进行了创建、增加条目和查询等操作。由于函数的第二个参数涉及到的SQL语句超出了本书的范围，故不进行深入介绍。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"","category":"page"},{"location":"ch10file/#序列化","page":"文件","title":"序列化","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"可以想象，我们向数据库中存储字符、数字还是比较容易的，但如果要存储图片或者音、视频，该如果操作？这里我们就要用到序列化的方法。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"函数 serialize 可以将几乎任何类型的对象转换成一个适合于数据库存储的字节数组（一个读写缓存），而 deserialize 可以将字节数组转换回对象：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> using Serialization\njulia> io = IOBuffer();\njulia> t = [1, 2, 3];\njulia> serialize(io, t)\n24\njulia> print(take!(io))\nUInt8[0x37, 0x4a, 0x4c, 0x09, 0x04, 0x00, 0x00, 0x00, 0x15, 0x00, 0x08, 0xe2, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"这种结构不适合人们阅读，但对Julia来说却更易于解读。deserialize 重新构建对象：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> io = IOBuffer();\njulia> t1 = [1, 2, 3];\njulia> serialize(io, t1)\n24\njulia> s = take!(io);\njulia> t2 = deserialize(IOBuffer(s));\njulia> print(t2)\n[1, 2, 3]","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"上例，serialize 和 deserialize 对代表内存中读写流的一个读写缓存对象进行了写入和读取操作。函数 take! 取出读写缓存中的内容——字节数组并将读写缓存重置为它的初始状态。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"尽管新对象与老对象的值相同，但它们不是（一般来说）同一个对象：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> t1 == t2\ntrue\njulia> t1 === t2\nfalse","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"换句话说，序列化然后再解序列化的效果与复制对象相同。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"你可以使用这种方法在数据库中存储非字节对象。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"实际上，在数据库中存储非字节对象是一个很普遍的现象，Julia将这种功能封装成一个名为 JLD2 的库包。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"JLD2是使用HDF5格式保存和提取Julia数据结构的一种文件格式，其作用类似于Matlab中的 .mat 文件。操作JLD2文件最简单的方法是使用宏 @save 和 @load。宏 @save 向文件中写入变量：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> using JLD2\njulia> hello = \"world\";\njulia> arr = [1, 2, 3];\njulia> @save \"file.jld2\" hello arr","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"@save 创建一个新文件 file.jld2 并将变量 hello 和 arr 写入到该文件中。 宏 @load 可以从JLD2文件中将这些变量提取出来：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"@load \"file.jld2\" hello arr","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"这条语句将存储在文件中的变量 hello 和 arr 的内容提取出来并赋给当前作用域内的同名变量。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"","category":"page"},{"location":"ch10file/#命令对象","page":"文件","title":"命令对象","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"大多数操作系统提供了一个命令行接口，也被称为壳（Windows系统提供了壳和Dos系统下的命令行接口）。壳通常提供用于浏览文件系统和启动应用程序的命令。例如，在Unix系统中可以使用 cd 来改变目录，ls 显示目录中的内容， firefox（只是举例）启动一个网页浏览器。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"在壳中可以启动的任何程序都可以使用命令对象在Julia中启动（本书以Dos命令窗口为例）：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> a = `cmd /c echo hello`\n`cmd /c echo hello`","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"在Windows系统中， echo 不是一个可执行程序，它只是可执行程序 cmd 中的一项功能，因此在Windows中调用 echo 命令实际上要调用 cmd 命令中的 echo 功能。 ","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"所包围的内容是一条系统命令，函数 run 用来执行命令：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> run(a);\nhello","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"hello 是echo命令的输出结果，被发送到 STDOUT。run 函数本身返回一个进程对象，如果外部命令执行失败则抛出一个 ErrorException 异常。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"如果你想读入外部命令的输出结果，可以使用 read 函数：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> b = read(a, String)\n\"hello\\r\\n\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"举一个例子，大多数Unix系统都提供了一个 md5sum 或 md5 命令用来读取一个文件中的内容并计算出一个“校验和”。Windows默认不具有这个程序，需要从网站下载，本书也提供了该文件。将可执行文件 md5.exe 放入到 %SystemRoot%\\system32\\ 就可以。这条命令为检验两个文件是否有相同的内容提供了一个高效的方法。内容不同而取得相同校验和的概率非常小。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"你可以在Julia中使用命令对象执行 md5 并得到结果：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> filename = \"emma.txt\";\njulia> a = `md5 $filename`\n`md5 emma.txt`\njulia> res = read(a, String)\n\"670533E523E86AC303F2CF6980A0AF7E  emma.txt\\r\\n\"","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"","category":"page"},{"location":"ch10file/#模块","page":"文件","title":"模块","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"假设一个名为 \"wc.jl\" 的文件中有如下代码：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"function linecount(filename)\n    count = 0\n    for line in eachline(filename)\n        count += 1\n    end\n    count\nend\n\nprint(linecount(\"wc.jl\"))","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"如果你运行这个程序，它读入自己并打印文件的行数，结果是9。你也可以在REPL使用 include 函数：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> include(\"wc.jl\")\n9","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"Julia引入模块来创建一个单独的变量工作空间，也即一个新的全局作用域。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"模块以关键字 module 开始，end 结束。这样可以避免你自己的顶层定义和别人代码中的名字发生冲突。import 允许控制来自于其他模块的哪些名字是可见的；export 指明你使用的名字中哪些是公有的，即在模块外不需要使用模块名作为前缀就可以使用的。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"module LineCount\nexport linecount\n\nfunction linecount(filename)\n    count = 0\n    for line in eachline(filename)\n        count += 1\n    end\n    count\nend\nend","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"模块 LineCount 对象提供了 linecount：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> using LineCount\nERROR: ArgumentError: Package LineCount not found in current path:","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"从报错信息可以看到，模块 LineCount 没有在当前搜索路径上。using 使用 LOAD_PATH 内保存的路径进行搜索，因此我们只需将 LineCount 模块所在的目录添加到 LOAD_PATH 内即可：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"push!(LOAD_PATH, \"path to LineCount\" )","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"再次使用模块：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> using LineCount\njulia> linecount(\"LineCount.jl\")\n11","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"同样，新增路径只在当前场景内有效，下次启动Julia后如果还要用到该路径，你需要再次手动添加。你也可以将这条语句加到1.3节介绍的 startup.jl 文件中实现自动化。","category":"page"},{"location":"ch10file/#习题14-1","page":"文件","title":"习题14-1","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"自己动手实现一下上面介绍的例子。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"参考答案","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"如果你输入一个已经输入过的模块，Julia什么都不做。即使文件内容有变动，它也不重新读入文件。 如果想重载一个模块，你必须重新启动REPL。软件包 Revise 可解决这个问题，具体使用方法可参考相关文档。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"","category":"page"},{"location":"ch10file/#调试","page":"文件","title":"调试","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"当读写文件时，你可能会遇到空格问题。由于空格、制表符和换行符一般是不可见的，因此这类错误很难调试：","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia> s = \"1 2\\t 3\\n 4\";\njulia> println(s)\n1 2      3\n 4\n````\n\n内置函数 `repr` 和 `dump` 可以帮助解决这个问题。它们接受任何对象作为参数，返回一个代表对象的字符串。\n","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"julia {.numberLines} julia> repr(s) \"\\\"1 2\\t 3\\n 4\\\"\" julia> dump(s) String \"1 2\\t 3\\n 4\" ```","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"这在调试过程中会有所帮助。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"另一个问题是不同操作系统可能使用不同的字符来表示一行的结束。有些系统使用新行符：\\n。有些系统使用回车符：\\r。有些系统同时使用这两个。如果你在不同的系统中传递文件，这种不一致性会产生问题。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"对于大多数系统，都带有格式转换软件，当然你也可以自己写一个。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"","category":"page"},{"location":"ch10file/#术语","page":"文件","title":"术语","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"持久 : 指程序持续运行，并且至少将部分数据保存到永久存储设备中。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"文本文件 : 存储在诸如硬盘一类的永久存储设备中的字符串序列。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"目录 : 一个命名的文件集合，也叫做文件夹。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"路径 : 指定一个文件的字符串。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"相对路径 : 从当前目录开始的路径。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"绝对路径 : 从文件系统中的根目录开始的路径。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"catch : 使用 try ... catch ... finally 语句防止异常导致程序结束。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"数据库 : 用于存储数据的一种文件。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"壳 : 一个应用程序，允许用户在里面输入命令，然后启动其他程序来执行它们。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"命令对象 : 代表壳命令的一个对象，允许Julia程序执行命令并读取结果。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"","category":"page"},{"location":"ch10file/#习题","page":"文件","title":"习题","text":"","category":"section"},{"location":"ch10file/#习题14-2","page":"文件","title":"习题14-2","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"编写一个名为 sed 的函数，它接受一个模式字符串，一个替换字符串和两个文件作为输入参数；它应该读取第一个文件并将内容写入第二个文件（如果需要就创建一个）。如果在文件中的任何地方出现了模式字符串，则使用替换字符串替换它。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"如果在打开、读取、写入或关闭文件的过程中出现错误，程序应该捕捉到异常，打印一条出错信息并退出。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"参考答案","category":"page"},{"location":"ch10file/#习题14-3","page":"文件","title":"习题14-3","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"如果你已经完成了习题12-3，你会看到创建了一个从排了序的字母字符串映射到可以由这些字母拼写成的单词数组。例如，\"opst\" 映射到矩阵 [\"opts\", \"post\", \"pots\", \"spot\", \"stop\", \"tops\"]。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"写一个模块输入 allanagrams，编写两个新函数：storeanagrams 使用 JLD2 保存变体字典；readanagrams 返回一个单词的变体数组。","category":"page"},{"location":"ch10file/#习题14-4","page":"文件","title":"习题14-4","text":"","category":"section"},{"location":"ch10file/","page":"文件","title":"文件","text":"在一个大的MP3文件集合中，同一首歌可能有多个拷贝，它们可能存储在不同的目录内或使用不同的文件名。这个练习的目的是找出所有的副本。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"写一个程序，递归地搜索一个目录和所有子目录，返回一个给定后缀（如.mp3)所有文件绝对路径的数组。\n为了识别出副本，你可以使用 md5sum 或 md5 来计算每个文件的“校验和”。如果两个文件的校验和相同，它们的内容很有可能相同。\n你可以使用Unix命令 diff 进行再次确认，Windows用户需要安装该程序，可到相关网站下载，本书也提供了该软件的安装文件，安装后，记得将可执行文件目录添加到环境变量Path中。","category":"page"},{"location":"ch10file/","page":"文件","title":"文件","text":"参考答案","category":"page"},{"location":"ch02dadatypes/#数据类型","page":"数据类型","title":"数据类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"类型是Julia语言的核心。尽管在语法上不需要显式地定义数据的类型，但Julia在编译过程中会对类型进行推断。Julia语言有预定义的类型。用户也可以定义自己的类型。有些类型可以通过参数进行修改。","category":"page"},{"location":"ch02dadatypes/#数据的表现形式","page":"数据类型","title":"数据的表现形式","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"通常，动态类型编程语言没有开发良好的类型系统，如Python中的数据类型就是非强制的。Julia类型系统是动态的，但总是在对象实例化时进行推断。这样，Julia在执行代码段或对代码进行即时(JIT)编译之前，数据类型就是已知的了。简而言之，Julia原生支持在使用前定义或推断任意对象或字面量的数据类型。在深入介绍数据类型之前，让我们先了解一下数据在Julia中的表现形式：变量、常量和字面量。","category":"page"},{"location":"ch02dadatypes/#变量","page":"数据类型","title":"变量","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia中的变量将名称与值关联起来。名称通常以字母开头的字母数字表示。下面给出了一些在Julia中变量名的例子。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"abc = 1\nπi = 30\na1 = 1\n1abc = 2\nsin = 1.0\ncos(0.0)\ncos = 0.0","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"从上面的结果可以看出，变量名可以包含Unicode字符；可以包含数字，但不能以数字开头；以函数名做为变量名时要特别慎重。变量名的另外一个限制是不能使用特殊字符和Julia的关键字，如下面的例程所示。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"julia> a@ = 1\nERROR: syntax: extra token \"@\" after end of expression\n\njulia> struct = 10\nERROR: syntax: unexpected \"=\"","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia的关键字很少。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"baremodule  begin   break       catch   const   continue\ndo          else    elseif      end     export  false \nfinally     for     function    global  if      import \nlet         local   macro       module  quote   return\nstruct      true    try         using   while ","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia还具有两字关键字(mutable struct、abstract type等)和中缀操作符(in、isa等)关键字。","category":"page"},{"location":"ch02dadatypes/#定义与初始化","page":"数据类型","title":"定义与初始化","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"大部分静态语言，如C，变量的定义和初始化是独立的。定义声明变量的类型，其底层操作是向内存申请一块相应类型的地址空间并命名（变量名）。初始化则在地址空间中存入规定类型的具体值。变量和值的关系是：变量是主体，值是变量的附属。如下面C代码片段所示。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"int i;  /* 将i定义为整数类型 */\ni = 10; /* 初始化i */\nint j = 20; /* 在一条语句中定义并初始化变量 */","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia则将变量和值的关系翻转过来：值是主体，变量是值的附属。大多数Julia变量是在对类型进行初始化时定义的。事实上，类型是作为初始化过程的一部分赋给变量的。也可以显式地声明变量将要绑定的值的类型，Julia会尝试将值转换成相应的类型，不成功则会报错。对于REPL中的全局变量，不允许声明变量的类型。例程如下所示。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a = 1\ntypeof(a)\na = 1.0\ntypeof(a)\nlet a::Int = 1.0\n    println(typeof(a))\nend\nlet a::Int = 1.1\n    println(typeof(a))\nend\na::Int = 1","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"从上面的介绍可以判断，Julia中的一般变量是没有固定地址的，事实也是如此。Julia甚至没有为我们开放变量地址的查询功能（后面会介绍可查询地址的变量类型），这一切都交给了底层程序自动处理。在Julia中，没有初始化的变量是无效的（后面会介绍例外的情况）:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"i","category":"page"},{"location":"ch02dadatypes/#常量","page":"数据类型","title":"常量","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"常量可以看作是不能修改的变量。然而，Julia并没有严格地遵循常量不变的条件。在类型不变的情况下修改常量的值，它会发出警告，但改变常量类型的情况是不允许的。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"const ICONSTANT = 1\nICONSTANT = 5\nICONSTANT = 5.0","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在使用中，尽管常量的值是可以修改的，但我们应该严格遵守常量不变的特性，以避免程序在执行中产生不可预见的错误。","category":"page"},{"location":"ch02dadatypes/#字面量","page":"数据类型","title":"字面量","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"字面量是表示一个值的常表达式。因为它们出现在变量定义的右边，因此常被称为右首值。它们也是一个值的本质表示形式。下面是一些不同类型的字面表达式。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"2           # Integer\n2.0         # Double precision Float (Float64)\n2f0         # Single precision Float (Float32)\n'a'         # Char\n\"string\"    # String","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"当我们深入研究类型时，我们将根据特定类型的上下文含义更详细地回顾字面量。通常，变量初始化为var = <literals>。","category":"page"},{"location":"ch02dadatypes/#内置数据类型","page":"数据类型","title":"内置数据类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia语言自身定义了许多内置类型。而更多的类型则是在Julia库中定义的。Julia语言提供了扩展这些功能的灵活性。此外，定义的类型不作为保留的关键字存在。下面是该语言中一些常用的类型。","category":"page"},{"location":"ch02dadatypes/#Nothing","page":"数据类型","title":"Nothing","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Nothing是值nothing的类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(nothing)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof函数可用于查询值所属类型的信息。当代码中确实需要未初始化的变量条件时，可以使用nothing来初始化这个变量。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a = nothing\ni = 6\nif i < 5\n    a = 5\nend\ntypeof(a)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"这里，如果i小于5 a就被赋值为5。否则，它仍保持未初始化。Nothing和nothing在函数参数和返回类型中也被广泛使用。","category":"page"},{"location":"ch02dadatypes/#数值类型","page":"数据类型","title":"数值类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"下面是在Julia中定义为数值数据类型的一些数据类型。","category":"page"},{"location":"ch02dadatypes/#Bool","page":"数据类型","title":"Bool","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"true和false在Julia中属于Bool类型。数值上，true的值为1,false的值为0。","category":"page"},{"location":"ch02dadatypes/#整数","page":"数据类型","title":"整数","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"整型数字类型分为具有不同字节大小的无符号和有符号类型。有符号数字类型有:Int8、Int16、Int32、Int64和Int128。对应的无符号数字类型分别为:UInt8、UInt16、UInt32、UInt64和UInt128。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(1)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"数字字面量的默认数值类型是Int，根据机器的体系结构，它映射到Int32或Int64。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"对于无符号数字，字面量由0<表示说明符><数字>指定。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(0b1), typeof(0o7), typeof(0xff)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"这些由二进制、八进制和十六进制表示的数字都被映射到UInt8。数字的尺寸由满足字面量所需的最小字节大小决定。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(0xf), typeof(0xfff),typeof(0xfffff), typeof(0xfffffffff), typeof(0xfffffffffffffffff)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"无符号整数的前面也是可以加+/-号的，但加-号的含义不是得到一个负的整数，而是得到该整数的二进制补码（后续将介绍相关知识）。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"-0x2\nInt(ans)","category":"page"},{"location":"ch02dadatypes/#浮点数","page":"数据类型","title":"浮点数","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"根据IEEE 754规范，Julia使用Float16、Float32和Float64来表示半精度、单精度和双精度浮点数。使用字面量f和e作为Float32和Float64的指数分隔符。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(1.0), typeof(1e0),typeof(1.e4)\ntypeof(1.0f0), typeof(1f-6), typeof(1.f4)","category":"page"},{"location":"ch02dadatypes/#抽象类型","page":"数据类型","title":"抽象类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia中的类型可以从抽象类型派生出来。大多数面向对象语言将这种关系视为在类层次结构中描述对象的一种方法。在Julia中，抽象类型仅仅是像接口一样的概念性表示，内部没有数据元素。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"abstract type MyAbstractType end\nstruct MyConcreteType <: MyAbstractType\n    member\nend\na = MyConcreteType(5)\na isa MyAbstractType","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"虽然我们将在后面详细讨论这个概念，但类型只能从一个抽象类型派生出来。中缀运算符isa用于判断特定对象是否属于特定类型。这里类型可以是具体类型也可以是抽象类型。下面是Julia中数字类型的类型层次结构。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: numerictypes)","category":"page"},{"location":"ch02dadatypes/#基本类型","page":"数据类型","title":"基本类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"基本类型是使用固定字节数表示数据的一种具体类型。基本类型的经典例子是整数和浮点数。与大多数语言不同，除了一组固定的内置类型外，Julia允许声明自己的基本类型。实际上，Julia的基本类型都是在语言本身中定义的:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"primitive type Float16 <: AbstractFloat 16 end\nprimitive type Float32 <: AbstractFloat 32 end\nprimitive type Float64 <: AbstractFloat 64 end\n\nprimitive type Bool <: Integer 8 end\nprimitive type Char <: AbstractChar 32 end\n\nprimitive type Int8    <: Signed   8 end\nprimitive type UInt8   <: Unsigned 8 end\nprimitive type Int16   <: Signed   16 end\nprimitive type UInt16  <: Unsigned 16 end\nprimitive type Int32   <: Signed   32 end\nprimitive type UInt32  <: Unsigned 32 end\nprimitive type Int64   <: Signed   64 end\nprimitive type UInt64  <: Unsigned 64 end\nprimitive type Int128  <: Signed   128 end\nprimitive type UInt128 <: Unsigned 128 end","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"声明基本类型的一般语法是:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"primitive type «name» «bits» end\nprimitive type «name» <: «supertype» «bits» end","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"虽然用户可以定义自己的基本类型，但建议只有在现有的基本类型不能满足要求时再定义新的基本类型。相同位值的基本类型本质上是不可互换的，也不能无缝转换。类型层次结构在这类类型的行为中扮演着重要的角色。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"UInt32(3f-1)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"尽管它们都是32位实体，但单精度浮点数不能在每种情况下都表示为无符号整数。不能创建任意大小位的基本类型，目前仅支持8位倍数的位大小。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"primitive type MyType1 40 end\nprimitive type MyType2 4 end","category":"page"},{"location":"ch02dadatypes/#位类型","page":"数据类型","title":"位类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia可以在二进制接口层面上与编译完成的语言，如C/C++、FORTRAN等进行无缝地交互，得益于Julia中定义的某些数据类型同这些本地编译语言所使用的类型在二进制布局中是一致的。这种类型被称为位类型。Julia中的基本类型都是位类型的数据类型。某些复合数据类型也是位类型。我们将在遇到他们时进一步讨论。位类型可以通过在实例上调用isbits函数或在类型上调用isbitstype函数进行查询。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a = 10\nisbits(a)\nisbitstype(Int)","category":"page"},{"location":"ch02dadatypes/#有理数和复数","page":"数据类型","title":"有理数和复数","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"虽然有理数和复数是数字类型，但它们不是基本类型。它们是使用复合数据类型创建的，我们将把复合数据类型作为用户定义类型的一部分来介绍。","category":"page"},{"location":"ch02dadatypes/#字符","page":"数据类型","title":"字符","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Char是由32位值表示的字符。它是Unicode字符的一个有效UCS-4表示。我们将在String一章详细讨论Char及其与String的关系。AbstractChar抽象类型可方便用户开发自己的类Char数据类型。","category":"page"},{"location":"ch02dadatypes/#字符串","page":"数据类型","title":"字符串","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"字符串是字符的集合。虽然大多数字符串是由Unicode字符编码组成的，但它们也可以存储其他类型的二进制数据。AbstractString抽象类型方便用户定义自己的字符串类型。","category":"page"},{"location":"ch02dadatypes/#用户定义类型","page":"数据类型","title":"用户定义类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"虽然Julia提供了相当多的内置类型，但仍需要将各种属性组合在一起的数据类型。","category":"page"},{"location":"ch02dadatypes/#结构","page":"数据类型","title":"结构","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia用struct表示一旦被初始化，其内部属性就不能被修改的自定义复合类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"struct Rectangle\n    h::Float64\n    w::Float64\nend\nr = Rectangle(10.0, 20.0)\nr.h = 15","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Rectangle是一个struct，初始化值为10.0和20.0。属性值不能被修改。函数Rectangle(10.0, 20.0)用来执行初始化。它是一个特殊的函数。当我们讨论函数和方法时，将进行深入介绍。","category":"page"},{"location":"ch02dadatypes/#可变结构","page":"数据类型","title":"可变结构","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"假设我们需要Rectangle是可修改的，则可以创建一个可变结构，如下所示:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"mutable struct MRectangle\n    h::Float64\n    w::Float64\nend\nmr = MRectangle(10.0, 20.0)\nmr.h = 15.0\nmr","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"可以看到，属性值在实例化对象之后是可以被修改的。Julia中的复合数据类型也可以从抽象类型派生出来。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"abstract type Shape end\nstruct Rectangle <: Shape\n    w::Float64\n    h::Float64\nend\nstruct Square <: Shape\n    l::Float64\nend","category":"page"},{"location":"ch02dadatypes/#成员","page":"数据类型","title":"成员","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia中的复合类型具有成员属性，但没有成员函数或方法。Julia的多分派体系结构使函数的行为类似于特定类型的方法，但它们与面向对象语言中的方法不同。有一类特殊的函数，它可以是类型的成员。这些函数被称为构造函数。我们将在讨论函数时详细讨论构造函数。成员的类型信息并不总是在复合类型中被指定。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"mutable struct A\n    member\nend\na = A(5)\ntypeof(a.member)\na1 = A(\"string\")\ntypeof(a1.member)","category":"page"},{"location":"ch02dadatypes/#Any","page":"数据类型","title":"Any","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"虽然在前面的例子中，模糊性问题在对对象进行实例化时得到了解决，但我们永远不能确定动态成员属性未来将被赋予哪种数据类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a.member = \"julia\"\ntypeof(a.member)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a.member之前的类型是Int64，现在是String。Julia假定这种未指明的类型为Any。在不能确定类型的情况下，Julia将假定类型为Any。从性能的角度来看，使用Any是不可取的。每次访问Any类型的对象时，它都会重定向到另一个实际的对象。我们不可能事先知道Any对象的大小。实际上，它是一个指向内存中实际对象所在的另一个位置的指针:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: anytype)","category":"page"},{"location":"ch02dadatypes/#参数数据类型","page":"数据类型","title":"参数数据类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Any作为类型会引入不必要的跳转，因此效率很低。有时，类型不一定会影响算法，但会引入不同的数据位大小。例如，前面介绍的Rational数据类型，分子和分母可以是任何整数类型，如Int8、Int16、Int32、Int64或Int128。Rational数据类型的定义如下:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"struct Rational{T<:Integer} <: Real\n    num::T\n    den::T\nend","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"两个属性num和den的类型为T，其中T是Integer的子类型。Rational是Real的一个子类型。以下是参数数据类型的一些特性。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Rational{Any}\nRational{Int32} <: Rational\nRational{Int32} <: Rational{Integer}","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"理解这种行为尤其重要。尽管Int32是Integer的子类型，但参数表示Rational{Int32}不是Rational{Integer}的子类型。然而，Rational{Int32}是Rational的子类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a = Rational{Int32}(1,UInt32(2))\ntypeof(a.num), typeof(a.den)\nb = Rational{Integer}(1,UInt32(2))\ntypeof(b.num), typeof(b.den)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"与具体数据类型一样，抽象数据类型也可以参数化。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"abstract type Shape{T<:AbstractFloat} end\nstruct Rectangle{T<:AbstractFloat} <: Shape{T}\n    w::T\n    h::T\nend\nstruct Square{T<:AbstractFloat} <: Shape{T}\n    s::T\nend","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"根据上面的方案，针对T可以开发不同的功能，如将T设为Float32或Float64，构建的Rectangle{Float32}类型与Rectangle{Float64}类型完全不同，它们是在编译过程中实例化具体类型时生成的。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"类型的参数化是Julia语言一个非常有用的特性，除此以外，也可以对整数值进行参数化。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"struct Point{T<:AbstractFloat,N}\n    x::Vector{T}\nend\nnum_coor(::Point{T,N}) where {T<:AbstractFloat,N} = N\np2 = Point{Float32,2}([1f0,2f0])\np3 = Point{Float32,3}([1f0,2f0,3f0])\nnum_coor(p2)\nnum_coor(p3)\npush!(p2.x,3)\np2\nnum_coor(p2)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"可以看出，类型中使用的N是用作类型参数的整数。","category":"page"},{"location":"ch02dadatypes/#类型上的运算","page":"数据类型","title":"类型上的运算","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"某些操作适用于类型。在前面，我们已经看到了一些，本节将详细介绍它们。","category":"page"},{"location":"ch02dadatypes/#typeof","page":"数据类型","title":"typeof","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"此函数提供与类型的实例相关联的具体类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a = 1 // 2\ntypeof(a)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"类型本身也有类型，它们都是DataType类型的实例。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(Int)\ntypeof(Any)\ntypeof(DataType)","category":"page"},{"location":"ch02dadatypes/#别名","page":"数据类型","title":"别名","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"与任何其他实例对象一样，类型可以进行比较和赋值。下面是来自base/boot.jl的代码片段。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"if Int === Int64\n    const UInt = UInt64\nelse\n    const UInt = UInt32\nend","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Int对象与Int64对象进行比较，如果相同则UInt初始化为UInt64，否则初始化为UInt32。因此根据机器架构，UInt成为UInt64或UInt32的别名。","category":"page"},{"location":"ch02dadatypes/#isa","page":"数据类型","title":"isa","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"判断实例是否属于特定类型。isa也可以用作中缀运算符。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"isa(1,Number)\nisa(1,Matrix)\nisa(1,Int)\n\"julia\" isa String","category":"page"},{"location":"ch02dadatypes/#supertype","page":"数据类型","title":"supertype","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"这个函数返回一个类型的直接超类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"supertype(Int32)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":">:用于指定（在结构或函数定义阶段）或判断一个类是否是另一个类的超类。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Integer >: UInt8\nFloat64 >: Float16","category":"page"},{"location":"ch02dadatypes/#:","page":"数据类型","title":"<:","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"此操作符用于表示一个类型是否是另一个类型的子类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Int32 <: Integer\nInt32 <: AbstractFloat\nInt32 <: Real\nInt32 <: Signed","category":"page"},{"location":"ch02dadatypes/#打印数据类型","page":"数据类型","title":"打印数据类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在定义了复杂的数据类型后，常需要以有意义的方式表示数据。默认情况下，所有成员都将作为元组打印。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"struct A \n    a1::Int32\n    a2::Float64\nend\na = A(1,2)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"其次，数据经常打印在REPL上。要禁止在REPL上打印数据，可以用分号(;)结束语句。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a;\na","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"默认情况下，Nothing不会标记输出。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"nothing","category":"page"},{"location":"ch02dadatypes/#show","page":"数据类型","title":"show","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"默认情况下，为了在REPL上显示输出，会在数据类型上调用相关的show方法。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"struct A\n    a1::Int32\n    a2::Float64\nend\na = A(1, 2)\nfunction Base.show(io::IO, a::A)\n    println(io, \"a1: \", a.a1, \" a2: \", a.a2)\nend\na","category":"page"},{"location":"ch02dadatypes/#print","page":"数据类型","title":"print","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"show用于在任何类型的输出设备上显示数据，而print只能用于输出文本信息。如果没有引入特定的打印例程，则在调用print时在内部使用show。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"print(a)","category":"page"},{"location":"ch02dadatypes/#string","page":"数据类型","title":"string","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"此函数可用于将任何类型转换为其字符串表示形式。当没有提供适当的转换方法时，将在内部调用print函数以获取数据类型的文本表示。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"string(a)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在前面的代码中可以清楚地看到print或底层show的用法。而字符串中额外的行尾则归因于println的使用，它向语句添加了一个EOL。如果想去掉它，只需要将show中的println换为print即可。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"function Base.show(io::IO, a::A)\n    print(io, \"a1: \", a.a1, \" a2: \", a.a2)\nend\nstring(a)","category":"page"},{"location":"ch02dadatypes/#数字在计算机中的存储与运算","page":"数据类型","title":"数字在计算机中的存储与运算","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在Julia中，如果你输入(sqrt3)^2，结果将是2.9....96，其中9重复了15次。相比与传统的数学运算，计算机的运算方式有两个明显且本质的区别:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"计算机只能表示有限数量的数字;\n计算机中表示的数字只能有有限多个有效数字。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"因此，能够在计算机中精确表示的数字只是有理数的一个子集。每当计算机执行一个运算，当结果不是一个可以在计算机中精确表示的数字时，就会用一个近似值来代替这个数字。这被称为舍入误差：用计算机进行实数计算时产生的错误。","category":"page"},{"location":"ch02dadatypes/#实数的浮点表示方法","page":"数据类型","title":"实数的浮点表示方法","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"下面是在计算机中表示实数的一般模型：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"x=s(a_1a_2a_t)_betatimesbeta^e tag1","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"其中","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"beginalign*\ns   x=1 的符号 2ex \ne   指数范围为LeU 2ex \n(a_1 a_t)_beta  = dfraca_1beta+dfraca_2beta^2+cdots+dfraca_tbeta^t尾数 2ex\nβ   基数 2ex\nt   有效数字个数精度 \nendalign*","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在浮点表示法(1)中，如果我们以这样一种方式指定e，即a_1 0，那么表示将是唯一的。这称为规格化的浮点表示法。例如，如果β = 10，在规格化的浮点数中，我们将把0012写成012  10^1，而不是0012  10^0或00012  10^1。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在当今大多数计算机中，基数是β = 2。过去老式的IBM大型机中曾使用过基数8和16。一些手持计算器使用基数10。莫斯科国立大学开发的Setun计算机，使用的基数是3，但并没有得到广泛推广。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"对于s，β，t，e的值，在一般浮点模型(1)中有多种选择。IEEE 64位浮点表示是当今大多数计算机中使用的特定模型：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"x=(-1)^s(1a_2a_3 a_53)_2 2^e-1023 tag2","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"注意在方程(1)和(2)中s的不同表现形式。在(2)中，s为0或1。s = 0，x是正的；s = 1, x是负的。\n由于β = 2，在x的规格化浮点表示中，小数点后的第一个(非零)位必然是1。因此我们不需要存储这个数字。这就是为什么在(2)中我们把x写成从1开始的小数。即使精度是t = 52，我们也能够访问到第53位有效数字a_53。\n指数的范围是:0e2047。稍后会讨论2047的来源。但首先，我们讨论一下为什么在(2)表示法中我们用e - 1023作为指数，而不是简单地用e(在(1)表示法中)作为指数。如果最小的可能指数是e = 0，那么计算机能生成的最小正数将是(1000)_2 = 1：当然，我们需要计算机来表示小于1的数字！这就是为什么我们在表示(2)中使用称为有偏指数的移位表达式e - 1023。注意，有偏指数的范围是- 1023e - 10231024。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"下图说明了计算机的物理位如何与上面的表示相对应。下表中编号为1到64的每个单元对应于计算机内存中的物理位。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: Physical bits)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"第一位是符号位：它存储s的值，0或1。\n蓝色的2到12位存储指数e(不是e1023)。使用11位，可以生成从0到2^111 = 2047的整数。下面是如何得到e的最小值和最大值：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"e=(000)_2=0 1ex \ne=(111)_2 =2^0+2^1++2^10=dfrac2^11-12-1=2047","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"红色的52位，存储有效数字a_2到a_53。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"例1：求10.375的浮点表示形式。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"解： 通过计算 10=0times2^0+textcolorblue1 2^1 + textcolorgreen0times2^2+textcolorred1times2^3 和 0375=0times2^-1+textcolorblue1times2^-2+textcolorgreen1times2^-3 可以得到 10=(textcolorred1textcolorgreen0textcolorblue10)_2 和 0375=(0textcolorblue1textcolorgreen1)_2。最终得到：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"10375=(1010011)_2=(1010011)_2times2^3","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"式中(1010011)_2  2^3为该数字的规格化的浮点表示。现在我们将其改写为式(2)的表示形式：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"10375=(-1)^0(1010011)_2times2^1026-1023","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"由于1026 =(10000000010)_2，按位表示的最终结果为：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: 基于10的数)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"注意因为数字是正数，第一个符号位是0。接下来的11位(蓝色)代表指数e = 1026，下一组红色的位是尾数，尾数的最末一位有效数字以后用0填充。在Julia中，我们可以通过输入bitstring(10.375)来逐位表示：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"bitstring(10.375)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"特殊情况：0，无穷，非数","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在浮点算术中有两个零：+00和00，它们有特殊的表示。在表示0时，所有的指数位和尾数位都设置为0。符号位是0的代表+00，1的代表00：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: zeros)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"当指数位设置为0时，我们有e = 0，因此e1023 =1023。这种将所有指数位设置为零的情况，是为00和非规格化数字保留的。非规格化数用来表示靠近0的数或0。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"下面是计算机中正负无穷数的表示方法：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: 正负无穷数)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"当指数位全设置为1时，我们有e = 2047，因此e1023 = 1024。这种安排是专门为以及其他特殊值，如NaN(非数)保留的；当尾数等于0时表示无穷大，尾数不等于0时表示非数。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"综上所述，尽管(2)中的1023e10231024，但在表示非零实数时，我们只能访问1022e10231023的指数范围。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"因此，计算机可以表示的最小正实数（非规格化）为：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"x=(-1)^0(0001)_2times2^-1022=2^-52times2^-1022=50times10^-324","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"最大正实数（规格化）为：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"x=(-1)^0(1111)_2times2^1023=left(1+dfrac12+dfrac12^2++dfrac12^52 right)times2^1023=(2-2^-52)times2^1023018times10^309","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在计算过程中，如果得到一个小于最小浮点数的数字，则会产生下溢错误。大于最大值的数字会产生上溢错误。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia中上溢和下溢错误分别是正负无穷：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"nextfloat((2.0-2^(-52))*2.0^1023)\nprevfloat(-(2.0-2^(-52))*2.0^1023)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"其运算方式与水银式温度计类似。","category":"page"},{"location":"ch02dadatypes/#整数的表示方法","page":"数据类型","title":"整数的表示方法","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在前一节中，我们讨论了计算机中实数的表示方法。这里我们将简要讨论整数的表示方法。计算机如何表示整数n？与实数类似，我们以2为基数开始写n。我们有64位来表示它的有效数字和符号。与浮点数一样，我们为符号分配一位，将其余的63位用于有效数字。当对整数进行加法运算时，这种方法有一些缺点。另一种方法被称为二进制补码，它更常用，包括在Julia中。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"举个例子，假设我们的计算机是8位的。要用二进制补码表示12(或任何正整数)，只需将它写成以2为基数展开的形式：(00001100)_2。为了表示−12，我们做如下操作：翻转所有数位，用0替换1，用1替换0，然后在结果上加1。翻转数字12，我们得到(11110011)_2，加上1（二进制）得到(11110100)_2。因此，−12在二进制补码法中被表示为(11110100)_2。为了表示-12，费了那么大的功夫，感觉有点奇怪，但当把12和-12二进制表示相加时，这种表示方法的优势立刻显现：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(00001100)_2+(11110100)_2=(textcolorred100000000)_2","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"这个和的前8位(从右到左)，也就是计算机能表示的(忽略红色数字1)，是(00000000)_2。所以就像以10为基数的12 +(- 12)= 0一样，这些数的表示形式的和也是0。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"我们可以用Julia实现64位的计算。函数bitstring输出一个整数的数位，对于负数使用二进制补码：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"bitstring(12)\nbitstring(-12)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"你可以验证当截断到64位时，这些表示的和为0。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"下面是另一个说明二进制补码优点的例子。考虑−3和5的表现，","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"-3=(11111101)_2 和 5 =(00000101)_2","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"−3和5的和是2；那么它们表示形式的二进制和呢？我们有：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(11111101)_2+(00000101)_2=(textcolorred100000010)_2","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"如果我们忽略红色的第9位，结果是(10)_2，结果也确实是2。注意，如果我们遵循浮点表示中使用的相同方法，并将最左边的位分配给整数的符号，就不会有这个属性。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"还记得对无符号整数取负的例子吧，它实际上返回的就是原整数的二进制补码。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"0xc\n-0xc","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在二进制补码中，使用64位，可以表示2^63 =9223372036854775808和2^631 =9223372036854775807之间的整数。小于或大于这个范围的任何整数都会产生下溢或上溢错误。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"整数的溢出与浮点数有所不同，如下所示：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typemax(Int64)\ntypemin(Int64)\ntypemax(Int64) + 1\ntypemin(Int64) - 1","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"当获得一个超过最大（或最小）可能值的整数时，Julia绕到最小（或最大）的整数，并继续计算。其运算方法与指针式钟表完全一样。","category":"page"},{"location":"ch09metaprograme/#元编程","page":"元编程","title":"元编程","text":"","category":"section"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"Julia深受Lisp的影响，并且为一些内部解析提供了Lisp变体解释器(FemtoLisp)。因此，它很自然地包含了元编程，这是Lisp衍生函数中最灵活的特性之一。本章，我们将介绍Julia是如何实现元编程的。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"“元”这个词，是来自希腊语中表示“在……之间、在……之后、超过……”的前缀词 meta，具有超越、高阶等意思。从这个意思引申出来，在单词前面加上 meta，表示对自身的描述。例如，描述数据所具有的结构的数据，也就是关于数据本身的数据，被称为元数据(Metadata)。再举个比较特别的例子，小说中的角色如果知道自己所身处的故事是虚构的，这样的小说就被称为元小说(Metafiction)；再比如，如果参与者知道自己所处的空间（或宇宙）是虚拟的，则这样的场景就被称为元宇宙（Metaverse）。不知各位有没有过这种体验，就是在做梦的时候知道自己在做梦？如果有过这种体验，相信你会对“元”这个概念有深刻的体会。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"综上所述，我们可以推论，所谓元编程，就是“用程序来编写程序”的意思。","category":"page"},{"location":"ch09metaprograme/#背景知识","page":"元编程","title":"背景知识","text":"","category":"section"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"元编程本质上是利用数据生成可以在应用程序自身内执行的代码。有些语言会在编译过程中执行这种代码生成；有些则将其视为执行的一部分。虽然代码生成和注入到执行单元的阶段可能会有所不同（这取决于语言的内部架构），但所有语言都会在对其进行后期处理之前以基语言生成代码。下面是一个来自C/C++的例子：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"#define twice(x) 2*(x)\n\nint main()\n{\n    int y = twice(2);\n}","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"通过C/C++预处理器运行它，你将得到这样的输出。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"int main()\n{\n    int y = 2*(2);\n}","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"可以看到，预处理器将twice宏替换为代码中的值。一旦预处理器运行，新生成的代码将在c编译器中进行编译。让我们看看c++语言中实现相同功能的模板元编程。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"template <typename T>\nT twice(T x){\n    return 2*x\n}\n\nint main()\n{\n    int y = twice(2);\n}","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"运行预处理器不会实质上改变代码。因此，有人可能会认为这不是元编程。但是，它也是元编程的一种形式。在编译过程中，twice<T>函数的模板类型将被解析，并生成twice<int>()函数。Julia支持基于模板的元编程，我们已经在关于函数和方法的章节中看到了这一点。Julia能够转换任何文本字符串，并限定其为可以在程序中执行的代码。虽然对一些人来说，这听起来可能令人兴奋，但它也会引发对安全后果的担忧。这个概念与执行宏的类Lisp语言非常相似。","category":"page"},{"location":"ch09metaprograme/#抽象语法树（AST）","page":"元编程","title":"抽象语法树（AST）","text":"","category":"section"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"抽象语法树(AST)是计算机科学中代码表达式的一种语法结构。这种结构形式使机器更容易理解代码，并消除了操作符优先级或使用括号修改优先级的情况。在Julia中，AST代码片段是一个有效的对象。因此，你可以灵活地使用一段代码生成它的AST，并将AST作为Julia对象进行操作，以创建可以执行的有趣的派生AST。这是Julia的元编程体系结构的基础。简单地说，你可以生成任何有效的代码字符串，并通过有效地操作在程序中执行它。让我们在下面的例子中看看其中的一些操作：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"s = \"1+2\"\nex = Meta.parse(s)\ntypeof(ex)\ndump(ex)","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"我们获取了一个可以是Julia表达式的有效字符串。我们使用Julia解析器对其进行解析，并以一个限定字符串格式返回输出。限定字符串是一种特殊的字符串，它确保了具有相同字面值的对象在内存中只保存一个副本，如下例所示：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"a = \"abc\"\nb = \"abc\"\nc = :abc\nd = :abc\npointer_from_objref(a)\npointer_from_objref(b)\npointer_from_objref(c)\npointer_from_objref(d)","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"Julia元编程的限定字符串格式为Expr类型。dump方法给出表达式的AST。从AST中可以识别出以下内容：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"ex的类型为Expr。\nex.head是调用符号。\nex.args有三个元素。\nargs[1]是符号+，通过调用触发。\nargs[2]和args[3]是函数调用的参数。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"我们来计算这个表达式，其结果应该是3。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"eval(ex)","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"让我们修改限定表达式ex，将ex.args[1]从+改为-。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"ex.args[1] = :(-);\ndump(ex)\neval(ex)","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"对调用序列中参数的简单修改可以更改要求值的调用函数。","category":"page"},{"location":"ch09metaprograme/#符号和限定字符串","page":"元编程","title":"符号和限定字符串","text":"","category":"section"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"在Julia AST中，符号对象被用作函数名和终结符。可以在标记的前面输入字符:来快速定义符号。符号构造函数也是可用的。它将把所有的参数连接起来形成一个符号。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"Symbol(\"A\")\nSymbol(\"A\", \"_\", 5, \"32\")\n:A_123\n:(==)","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"当使用冒号定义符号时，一些字母可能需要消除歧义，比如在这种情况下的==操作符。与使用Expr构造函数或像前一节中那样使用Meta.parse解析字符串相比，你可以使用冒号字符(:)来定义表达式或限定字符串。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"ex = :(z = 1 + 2)\ntypeof(ex)","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"这里生成的Expr有两个部分的AST。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"第一部分为变量赋值。\n调用运算符+，其结果是赋值的右值。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"dump(ex)\neval(ex)\nz","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"赋值表达式向程序状态引入一个新的赋值变量z。因此，对表达式和求值的操作可以修改程序状态。在对它们进行操作时，必须注意变量的范围。","category":"page"},{"location":"ch09metaprograme/#行内计算","page":"元编程","title":"行内计算","text":"","category":"section"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"虽然可以任意设计表达式，但除非包含预求值表达式，否则它并不是很有用。例如：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"x = 5;\nex = :($x + 1)","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"你也可以在行内求值中引入计算表达式。例如：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"ex = :($(x*x)+1)\ny = eval(ex)","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"这种技术在Julia编程中也被称为插值。","category":"page"},{"location":"ch09metaprograme/#多行表达式","page":"元编程","title":"多行表达式","text":"","category":"section"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"到目前为止，我们已经看到了作为限定字符串的简单表达式的AST。然而，现实生活中的函数和表达可能非常复杂。人们自然会产生对于通过编程操作表达式是否存在一些特定限制的疑问。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"ex = quote\n    x = 1\n    y = 2\n    x + y\nend\ndump(ex)","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"多行表达式包含在quote...end之间。正如你所看到的，为了行调试目的，添加了行号表达式来跟踪行号。该表达式的转储会显示AST的更详细的视图。它有以下特性：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"它以head属性的类型块开始。\nargs数组包含行节点和后续表达式部分。\n行包含一个行号部分和一个设置表达式内容的文件部分。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"让我们修改第2行中的赋值，从x = 1变为z = 1。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"ex.args[2].args[1] = :z\nex\neval(ex)\nz","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"新变量z的值为1,x的值是从上一节中获得的，为5。因此，ex表达式的计算结果为7。","category":"page"},{"location":"ch09metaprograme/#嵌套引用和插值","page":"元编程","title":"嵌套引用和插值","text":"","category":"section"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"让我们看看一些更复杂的引用表达式，其中一个quote...end包含在另一个引用表达式中。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"e = :(1 + 1);\neval(:e)\neval(e)","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"在前面的例子中，对符号:e进行eval运算，计算的结果是变量e的内容。而对变量e进行eval运算的结果实际上是对表达式求值，注意这两者间的差异。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"我们将在嵌套引用中重新研究的类似概念。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"e = :(1+2)\nex = quote\n    quote\n        $e\n    end\nend\neval(ex)","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"在前面的例子中，$e被绑定到内引用，等价于eval(:e)。因此，表达式1+2出现在quote...end之间。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"ex = quote\n    quote\n        $$e\n    end\nend\neval(ex)","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"当使用$$e时，计算eval(eval(:e))，因此计算出来的值3被放在quote...end之间。","category":"page"},{"location":"ch09metaprograme/#函数","page":"元编程","title":"函数","text":"","category":"section"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"下面的函数可以从输入参数生成并返回一个限制表达式。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"function math_exp(op, p1, p2)\n    p1f, p2f = map(x->x isa Number ? 2x : error(\"Parameters have to be numbers\"), (p1, p2))\n    return Expr(:call, op, p1f, p2f)\nend\nex = math_exp(:+, 2, 3)\neval(ex)","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"该函数返回一个Julia表达式。你需要一个额外的eval调用来求值。","category":"page"},{"location":"ch09metaprograme/#宏","page":"元编程","title":"宏","text":"","category":"section"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"函数可以返回一个表达式，但必须显式地调用eval来计算表达式的值。宏返回的表达式会自动计算，如下所示：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"macro sayhello()\n    return :(println(\"Hello, World!\"))\nend\n@sayhello()\nmacro sayhello(name)\n    return :(println(\"Hello, \", $name, \"!\" ))\nend\n@sayhello(\"John\")","category":"page"},{"location":"ch09metaprograme/#调用约定","page":"元编程","title":"调用约定","text":"","category":"section"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"宏可以采用下面任意一种调用形式：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"@mymacro(param1, param2, ..., paramN)\n@mymacro param1 param2 ... paramN","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"因此，这两个@sayhello宏可以用如下方式调用：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"@sayhello\n@sayhello \"John\"","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"让我们添加一个更复杂的表达式。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"@sayhello begin\n    1 + 3\nend","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"与方法类似，宏同样遵循多分派架构。引入一个新宏@sayhello(x::Int)可以通过下面的方式影响行为：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"macro sayhello(x::Int)\n    println(\"Calling Int \", x)\n    return :(println(\"Hello Int, \", $x))\nend\n@sayhello 21\nx = 21;\n@sayhello x","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"当使用Int字面值作为形参时，会调用宏@sayhello(::Int)。但是，当变量x作为参数时，会调用@sayhello(x)。宏将AST对象作为输入参数。因此，调用@sayhello x将被解释为sayhello连同符号x作为参数，而不是21作为参数被调用。下面的例子将进一步阐明这个论述：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"macro intype(x)\n    println(typeof(x))\nend\n @intype begin\n    x = 5\nend\n@intype x\n@intype 21\n@intype \"John\"","category":"page"},{"location":"ch09metaprograme/#自定义字符串字面值","page":"元编程","title":"自定义字符串字面值","text":"","category":"section"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"自定义字符串字面值本质上是用来代替构造函数的便捷宏。我们已经在字符串那一章的正则表达式中看到过这些宏的例子。Julia中正则表达式宏定义如下所示：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"macro r_str(p)\n    Regex(p)\nend","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"可以调用如下所示的正则表达式匹配表达式。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"m = match(r\"a.a\", \"abracadabra\")","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"表达式r\"...\"相当于调用宏@r_str()。让我们为大写字符串创建一个自定义表达式。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"struct CapsString\n    s::String\n    CapsString(s::String)=new(uppercase(s))\nend\nmacro C_str(s)\n    CapsString(s)\nend\nC\"This is upper case string\"","category":"page"},{"location":"ch09metaprograme/#生成函数","page":"元编程","title":"生成函数","text":"","category":"section"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"Julia使用多分派体系结构调用函数和方法。然而，有时人们可能希望创建比该语言支持的更为复杂的分派模型并自行编译。生成函数在这些场景中很有帮助。让我们考虑一个简单的分派场景。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"f(x::Integer) = x^2;\nf(x) = x;\nf(4)\nf(\"John\")","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"在前面的例子中，使用标准分派规则，f(4)应该调用f(::Integer)，f(“John”)调用f(x)。如果必须建立一个自定义的分派规则，你可以使用@generated宏来创建一个函数，如下所示：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"@generated function genf(x)\n    if x <: Integer\n        return :(x^2)\n    else\n        return :x\n    end\nend","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"在前面的函数中，生成函数只使用x的类型，x的值被忽略。该函数根据自定义分派过程返回函数所期望的表达式。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"genf(4)\ngenf(\"John\")","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"当这些方法被调用时，带有整形参数的函数将被编译和缓存。后续调用如genf(3)会触发编译后的表达式，这样可以更高效。关于生成宏的更详细示例，建议参考Julia文档。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"note: Note\n函数的缓存生成是不确定的。因此，与生成器一起使用的函数必须没有副作用。它们也不应该修改全局变量。\n生成函数只用于难以消除歧义的复杂分派规则。对于标准场景，使用语言默认的分派规则总是更高效。","category":"page"},{"location":"ch09metaprograme/#常用宏","page":"元编程","title":"常用宏","text":"","category":"section"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"Julia有许多内置宏，用于简化某些任务。在前几章中，我们已经介绍过@view、@goto、@label等。我们将在本节介绍另外一些。","category":"page"},{"location":"ch09metaprograme/#源位置","page":"元编程","title":"源位置","text":"","category":"section"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"每个宏都可以访问变量__source__（该变量可以访问文件名、行号）和__module__（给出宏定义所在模块的名称）。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"macro test()\n    println(__module__)\n    println(__source__)\nend\n@test","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"它们被用来开发一些实用的位置宏，如@__FILE__，@__LINE__和@__DIR__。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"function macro_usage()\n    println(\"Dir: \", @__DIR__, \" file: \", @__FILE__, \" Line No.: \", @__LINE__)\nend\nmacro_usage()","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"note: Note\n当代码在REPL或IJulia中使用时，@__FILE__宏不会返回一个文件名，它返回命令标识符。","category":"page"},{"location":"ch09metaprograme/#eval","page":"元编程","title":"eval","text":"","category":"section"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"当要生成大量样板代码时，可以高效地使用@eval。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"struct MyNumber\n    v::Float64\nend","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"假设我们要在这个数字上定义所有的数学方法，比如sin，cos，tan。代码可能像这样：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"Base.sin(m::MyNumber) = Base.sin(m.v)\nBase.cos(m::MyNumber) = Base.cos(m.v)\nBase.tan(m::MyNumber) = Base.tan(m.v)","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"下面的表达式可以避免重复代码：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"for op in [:sin, :cos, :tan]\n    eval(quote\n        Base.$op(m::MyNumber)=Base.$op(m.v)\n    end)\nend","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"eval(quote...end)是许多Julia应用程序中常用的表达式。宏@eval实现相同的功能，表达式如下所示：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"for op in [:sin, :cos, :tan]\n    @eval Base.$op(m::MyNumber)=Base.$op(m.v)\nend","category":"page"},{"location":"ch09metaprograme/#assert","page":"元编程","title":"assert","text":"","category":"section"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"@assert是一个宏，它验证表达式的真值，如果表达式的计算结果为false，则抛出AssertionError。其他语言如C/C++也有这样的宏。在某些语言中，断言验证仅是代码在调试模式下执行，而在优化发布模式时忽略。Julia也建议只在调试操作中使用assert宏。因此，它不应该被用作程序逻辑。assert最简单的形式如下所示：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"macro myassert(ex, msg)\n    return :($(ex) ? nothing : throw(AssertionError($msg)))\nend\n@myassert 1 == 0 \"1 is not same as 0\"","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"实际的assert宏没有限制可以传递给它的参数的数量，但是只利用第一个消息作为有效消息。如果没有消息，则利用ex作为消息。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"macro myassert(ex, msgs...)\n    msg = isempty(msgs) ? ex : msgs[1]\n    msg = msg isa AbstractString ? String(msg) : string(msg)\n    return :($(ex) ? nothing : throw(AssertionError($msg)))\nend\n@myassert 1 == 0","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"最后的代码与前面的稍有不同，因为它解决了一些简单示例代码没有解决的错误条件。assert被定义为宏是合适的，因为在Julia中ex参数可以是任何表达式。","category":"page"},{"location":"ch09metaprograme/#time","page":"元编程","title":"time","text":"","category":"section"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"@time宏用于计算执行代码块的运行时间和分配。","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"@time begin\n    sleep(0.3)\n    1+1\nend","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"@time宏的一部分实现如下代码：","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"macro mytime(ex)\n    return quote\n        local elapsedtime = time_ns()\n        local val = $(ex)\n        elapsedtime = time_ns() - elapsedtime\n        println(\"Elapsed time: \", elapsedtime/1e9)\n        val\n    end\nend","category":"page"},{"location":"ch09metaprograme/","page":"元编程","title":"元编程","text":"val在elapsedtime之前计算。因此，两者都需要存储在一个局部变量中。由于返回值是用引号括起来的表达式，如果变量val和elapsedtime没有显式地定义为局部变量，那么如果有全局作用域的变量val和elapsedtime，它们将被覆盖。它只对从宏返回的Expr起作用，不会影响宏中使用的变量，如前面例子中的msg。","category":"page"},{"location":"ch11guidelines/#编程风格","page":"编程风格","title":"编程风格","text":"","category":"section"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"相较于科学，编程更是一门艺术。大多数程序员都以自己的手艺为傲。他们会在一段时间内掌握一种艺术，并在职业生涯的相当长的一段时间内获得一种编程风格的专业知识。习惯于命令式编程或面向对象编程的人可能会对Julia感到困惑。本章将使我们熟悉这些差别。","category":"page"},{"location":"ch11guidelines/#背景知识","page":"编程风格","title":"背景知识","text":"","category":"section"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"Julia有很多类似于Lisp的特性。同时，它也有足够的结构用于命令式编程风格。虽然计算机程序员更喜欢命令式的编码风格，但数学家和研究人员更喜欢函数式编程，因为它可以轻松地将程序表示为数学函数。我们将在后面深入研究其中的差异。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"形成代码编写的一般指南和风格，有助于维护代码库。一个可能的例子是编码标准、函数约定和变量命名。与Python等语言不同，Julia在语法上不依赖于空格位置。这意味着一个人可以很容易地写出其他程序员很难读懂的代码。Julia社区在将代码签入到Julia GitHub库时遵循严格的建议或实践。大多数Julia程序员倾向于在他们的代码中接受并遵循它。我们将在介绍为可维护性编写代码时讨论其中的一些方面。","category":"page"},{"location":"ch11guidelines/#可维护性指南","page":"编程风格","title":"可维护性指南","text":"","category":"section"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"软件行业的经典需求分类之一是FURPS：","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"功能（Functionality）\n实用（Uasbility）\n可靠（Reliability）\n性能（Performance）\n支持（Supportability）","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"支持在这里尤其重要，因为良好的支持要求代码可读。编码约定为大规模的开发人员搭建桥梁。Julia文档给出了样式指南。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"使用函数：基于REPL的语言很容易被误认为是脚本语言。动态类型，所有代码都在一个全局作用域(Main模块)中编写，使该语言具有脚本语言的味道。然而，使用适当的函数可以使代码具有可维护性；此外，由于函数可以以类型安全的方式编写，因此可以更好地优化它们。\n代码必须是泛化的，而不是类型特定的：这个概念可以很容易地用下面的代码来解释：","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"addone(x) = x + one(x);\naddone(5), addone(5.0), addone(5f0)","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"Julia有许多类似one()和zero()的方法，它们使用运算数的类型，并明智地提供不需要在计算中显式提升类型的值。同样的原则也可以应用到你的代码中，使其易于扩展。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"如果必要则保持函数范围狭窄：当函数参数需要特定类型时，必须指定该类型。这确保运行时错误不会进一步传播，并且不需要额外的断言。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"calc1() = 2, 1\ncalc2() = 1.1, 1.2\nmyvalidate(x::Int, y::Int) = x == y\nmyvalidate(calc1()...)\nmyvalidate(calc2()...)","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"calc1()是正确的类型，calc2()是错误的，myvalidate()确保错误是本地化的。其次，如果需要，任何显式的类型转换都必须由调用方而不是被调用方执行。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"function myvalidate2(x, y)\n    xi, yi = Int(x), Int(y)\n    return xi == yi\nend\nmyvalidate2(2, 3.0) # Not good style\nmyvalidate(2, Int(3.0)) # Better style","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"在修改参数的函数后面附加感叹号(!)：当参数值被修改时，函数名应该有一个明确的感叹号指示符。这一点将在后面几节中进一步阐明。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"function double!(v::Vector)\n    for i=firstindex(v):lastindex(v)\n        v[i] *= 2\n    end\n    return v\nend\ndouble!([1,2,3])","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"避免复杂的数据类型：特别是与集一起使用的数据类型必须保持简单。Vector{Union{Int, Float, Function, MyType}}最好指定为Vector{Any}。对于编译器来说，拥有更简单的类型可能会更高效。类似地，Union{Function, AbstractString}在代码中可能不是适合的设计选择。\n命名约定：Julia编码人员习惯某些命名约定。下面是一些例子：\n类型以大写字母开头，可以是驼峰形式：MyType，AbstractArray{T}，等等。\n模块名称遵循与常规类型相同的约定。\n函数必须全部小写。\n带有合并单词的简单谓词：beginwith，isequal，haskey等。\n较长的名称，特别是多用途函数，用下划线(_)分隔：remotecall_fetch()。\n全局常数或环境变量全部大写：ENV。\n使用与Base匹配的函数参数：下面是一些常用的实践。\n当函数或匿名函数用作实参时，最好将它们放到形参的开头，这样就可以实用function...do语法。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"mymap(f, arr) = f.(arr)\nmymap([1, 2, 3]) do x\n    2x\nend","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"类似地，Vararg形参出现在函数实参的末尾。IO参数通常是函数的第一个参数。::Type{T}形参构成函数的第一个实参。\n明智地使用静态参数：只有在实际需要时才推荐使用静态参数。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"double(x::T) where {T<:Real} = 2x\ndouble(x::Real) = 2x","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"两种方法是等价的。只创建了一个方法，第二个方法覆盖了第一个方法。methods()调用将只列出一个方法。尽管声明了形参T，但在函数体中没有使用，因此被认为是多余的并被优化掉了。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"methods(double)","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"但是，下面的方法是一个非常相关的方法。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"myeltype(v::Vector{T}) where {T<:Real} = T\nmyeltype([1.0, 2, 3])","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"仅在需要时使用匿名函数：当你需要一个函数而不污染名称空间时，匿名函数非常有用。其次，它们是function...do语法一个非常干净的接口。然而，当函数已经有一个定义的名称时，则不必将函数包装在匿名函数中。例如，map(f, array)优于map(x->f(x), array)。\n不要为定义良好的数据类型重载Base方法：下面的代码将说明这一思想。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"module MyModule\nBase.:(*)(x::Symbol, y::Symbol) = Symbol(string(x)*string(y))\nend\n:a*:b","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"上述代码并不仅限于MyModule。它可以在MyModule加载后从任何地方访问。这可能是有风险的，因为别人可能无意中改变你没有定义的类型的行为。与经典的面向对象语言不同，Julia在数据隐藏、私有和公共区别方面相对灵活。因此，这些指南对于更好的系统设计是必要的。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"仅在绝对需要时才使用try...catch：异常是一个有用的特性，但异常处理也意味着必须跟踪堆栈，必须明确标识异常，并采取所需的操作。理想的编程实践应该确保异常只会少量发生，而分支时由于输入或条件检查而导致的正常故障则作为常规工作流的一部分处理。这确保了限制异常处理的性能开销。","category":"page"},{"location":"ch11guidelines/#代码风格","page":"编程风格","title":"代码风格","text":"","category":"section"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"在前一节中，我们看到了一些可能影响性能或一般编程范例约束的风格问题，但还有一些与代码可读性、表示和社区对代码的整体接受度有关的风格问题。下面是一个C/C++的例子，你的风格是什么？","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"int main(int argc, char** argv){\n    ...\n    return 0;\n    ...\n}","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"或者","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"int main(int argc, char** argv)\n{\n    ...\n    return 0;\n    ...\n}","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"两种风格都是对的。然而，有一群程序员在讨论C/C++编程的正确方式时，他们更喜欢其中的一种。Julia也是如此。有些包喜欢一种样式而不是另一种。他们都有自己的理由支持他们的偏好。一般的指导原则是遵循社区所坚持的风格。我们会在这里看到一些，但我们会建议首选Julia GitHub存储库风格，因为大多数开发人员都习惯了这一点。然而，如果你偏爱另一种风格，请确保你始终遵循它。没有什么比代码风格不一致更糟糕的了。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"缩进：空格是比制表符更好的缩进方式。人们可以将制表符设置为不同的移位位置，这可能会影响缩进。最好的方法是在签入代码时将制表符转换为空格，以避免这些制表符不一致。许多编辑器会自动为你做这些。Julia语言GitHub库使用四个空格。有些包也喜欢两个空格的缩进。由于分支中的短路运算，经常不需要大深度的缩进。下面是一个例子：","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"for i = 1:200\n    if a != 0\n        if b != 0\n            # Do something\n        end\n    end\nend\n\n# vs.\n\nfor i = 1:200\n    (a == 0 || b == 0) && continue\n    # Do something\nend","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"如你所见，短路计算节省了大量的缩进深度以允许更宽的缩进空间。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"括号的使用：在Julia中，除非确实需要打破常规操作符的优先级，否则不常用括号。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"if a == 0 && b == 0\n    # Do something\nend\n\n# is preferred over:\n\nif (a == 0) && (b == 0)\n    # Do something\nend","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"因此，建议只在绝对需要的时候使用最小数量的括号。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"操作符周围的空格：Julia在大多数情况下语法不依赖于空格。但是，在某些地方，空格是强制的。例如，在三元分支i > 0 ? 1 : -1，问号(?)和冒号(:)周围需要空格。elseif是一个词，else if是一个语法错误。通常，建议在所有操作符周围使用空格。\nx = x + 1优于x=x+1。\n但是，在函数参数中可能不建议这样的空格。f(arg1, key=v+1)优于f(arg1, key = v + 1)。\n用冗长的语法定义多行函数：下面的代码也是函数的定义，但显然可读性不强。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"f(x) = begin\n    if iseven(x)\n        2x\n    else\n        3x\n    end\nend","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"首选的样式如下：","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"function f(x)\n    if iseven(x)\n        return 2x\n    else\n        return 3x\n    end\nend\n\n# or\n\nf(x) = iseven(x) ? 2x : 3x","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"短形式用于单行数学结构，长形式用于函数体中的多行情况。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"一行的字符长度限制：这因项目而异。Julia GitHub存储库更喜欢将字符限制设置为92个字符。有些项目还建议120个字符，有些甚至没有限制。然而，限制有助于保持代码的一致性和可读性。作者更喜欢80个字符，因为如果你在1080p显示器上使用像emacs这样的编辑器，你可以同时编辑两个文件。无论决定了什么值，所有的贡献者都必须遵守它。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"为了更好地理解其他一些与格式相关的建议，请参阅Julia语言的代码格式化指南。其他一些组织和个人也提出了他们自己的风格，这些风格在社区中也很受欢迎。","category":"page"},{"location":"ch11guidelines/#函数式编程的原则","page":"编程风格","title":"函数式编程的原则","text":"","category":"section"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"函数式编程并不新鲜。事实上，它是由于Alonzo Church对Lambda微积分的研究而出现的最古老的编程形式。甚至在冯·诺伊曼的计算机概念成为主流之前，计算机就有内存，并且根据所采取的每一步行动，有一个状态机来改变它。内存在代码执行的每一步都被跟踪。这种顺序编程的风格被称为命令式编程。","category":"page"},{"location":"ch11guidelines/#声明式编程","page":"编程风格","title":"声明式编程","text":"","category":"section"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"让我们遍历一个列表并打印所有的值。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"a = [1, 2, 3];\nfor i=firstindex(a):lastindex(a)\n    println(a[i])\nend","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"在命令式编程中，对遍历列表的声明性语句进行了相当详细的逐步解释。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"从数组的第一个索引开始初始化计数器(i)。\n如果计数器(i)小于或等于数组的最后一个下标。\na) 获取存储在数组(a)的计数器(i)位置的值。\nb) 将值打印到标准输出。\nc) 将计数器(i)增加1。\n转到2。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"将其与下面的代码进行对比：","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"foreach(println, a)","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"解释代码的最接近的英文语句是遍历数组并将所有值打印到标准输出。这是一种声明式编程风格。Julia提供了命令式编程的所有构造，同时也提供了声明式编程的灵活性。虽然声明式编程风格是函数式编程的核心，但还有一些其他属性。","category":"page"},{"location":"ch11guidelines/#函数无副作用","page":"编程风格","title":"函数无副作用","text":"","category":"section"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"函数的数学定义是映射。你从函数的域中输入一个参数，得到的输出是一个映射到函数范围内的值：","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"(Image: Function Map)","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"这个映射是严格的，例如y1 = f(x1)。f永远不会改变x1的值。这本质上意味着函数不能改变输入的状态，并且输入数据是不变的。你可以将它与将不变类型定义为结构的能力相关联。Julia中可以更改输入参数的函数，建议使用以感叹号(!)结尾的名称，这些函数会产生副作用。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"a = [1, 2, 3];\npop!(a)\na","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"前面的pop!()方法改变了数组状态并引入了一个副作用。当函数依赖于全局变量(这些变量的状态可以改变，因此函数不再对相同的输入返回相同的输出)时，副作用就更难跟踪了。","category":"page"},{"location":"ch11guidelines/#高阶函数","page":"编程风格","title":"高阶函数","text":"","category":"section"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"高阶函数就像其他函数的函数。它们本质上可以被认为是一个函数的函数：","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"(Image: High order function)","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"在前面的例子中，h = g ∘ f是一个函数组合。Julia也支持这样的定义。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"f(x) = 2x;\ng(x) = x*x;\nh = g ∘ f\nh(3)","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"h是以f为参数的函数吗？这些函数类型在数学中很常见。函数的导数就是这样的关系。map()函数也接受一个函数作为参数，这个我们之前已经见过多次了。这些本质上是高阶函数。它们有助于声明式编程。","category":"page"},{"location":"ch11guidelines/#不变性","page":"编程风格","title":"不变性","text":"","category":"section"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"在“无副作用的函数”一节中，我们讨论了不变性。字符串和结构类型是不变的。因此，没有副作用的函数在操作字符串或结构数据类型集时分配额外的临时内存。大量的小分配可能会造成性能损失。使用map、reduce或mapreduce可以帮助最小化临时空间分配，并使不变函数更高效。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"我们讨论了函数式编程的几个方面。如果你对使用多种编程语言对函数式编程的概念有兴趣，可以参考《函数式思维》。读者很自然地会想，他们应该遵循命令式风格还是函数式风格。在这方面，Julia语言相当灵活。尽管在许多地方你会发现声明式程序、递归函数、理解式或类似的特性，但Julia并没有规定任何特定的编程风格。该语言提供了同样有用的结构来进行命令式编程。有时候，不变性可能会导致中间变量分配的增加，从而影响代码的性能。在这种情况下，使用具有副作用的函数可能是理想的。","category":"page"},{"location":"ch11guidelines/#常用模式","page":"编程风格","title":"常用模式","text":"","category":"section"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"在前一节中，我们介绍了函数式编程的基础知识，并研究了它们与Julia编程的关系。然而，函数式编程原则在任何语言中的应用都会因语言能力的不同而不同。在本节中，我们将介绍一些常用的模式，以及如何在Julia中实现它们。","category":"page"},{"location":"ch11guidelines/#接口","page":"编程风格","title":"接口","text":"","category":"section"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"Julia中的所有函数定义都可以充当接口。假设我们想要创建一个二维几何体的模块，并实现二维形状必须有面积和边界框的方法。界面看起来如下。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"module geom\n# All shape objects must have implementation for the following methods.\n# area(x): shall return the area of a 2-D shape\nfunction area end\n# bbox(x): shall return the bounding box of a 2-D shape\nfunction bbox end\nend","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"接口仅仅是指令。但是，可以通过强制一个抛出错误的默认实现来使它们成为硬接口。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"module geom\narea(x) = throw(Base.MethodError(area, (x,)))\nbbox(x) = throw(Base.MethodError(bbox, (x,)))\nstruct Rectangle\n    x; y; w; h\nend\nexport Rectangle, area, bbox\nend\nusing .geom\nr = Rectangle(0, 0, 10, 20)\narea(r)","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"默认的实现可以是一个返回输入的单位函数，从而使接口成为一个软接口。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"module geom1\narea(x) = identity(x)\nbbox(x) = identity(x)\nstruct Rectangle\n    x; y; w; h\nend\nexport Rectangle, area, bbox\nend\nr = geom1.Rectangle(0, 0, 10, 20)\ngeom1.area(r)","category":"page"},{"location":"ch11guidelines/#超类","page":"编程风格","title":"超类","text":"","category":"section"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"函数area和bbox对于类型Any没有任何意义。在Rectangle、Triangle或Circle类型上执行接口的一种方法是从超类Shape派生它们。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"module geom2\nabstract type Shape end\narea(x::Shape) = nothing\nbbox(x::Shape) = nothing\n\nstruct Rectangle <: Shape\n    x; y; w; h\nend\nend\nr = geom2.Rectangle(0, 0, 10, 20)\ngeom2.area(r)","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"我们可以将多边形引入模块中。多边形是由直线连接的多个点组成的封闭形状。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"module geom2\n...\nsturct Polygon <: Shape\n    pts::Vector{Tuple{Any, Any}}\nend\n...\nend","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"假设形状的直线不是封闭的，我们将得到一个PolyLine类型。对于一个开放的形状，没有面积的概念。因此，函数area()应该抛出一个错误。一般来说，一个好的面向对象设计，isa关系必须在各个方面都是完整的。Polygon和PolyLine都必须体现Shape的所有属性。如果area(::PolyLine)抛出错误，则PolyLine isa Shape的关系将被损害。因此，有人建议引入OpenShape和ClosedShape作为抽象类型。area()函数将只存在于ClosedShape。下面是一个可能的实现。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"module geom3\nabstract type Shape end\nbbox(x::Shape) = nothing\n\nabstract type OpenShape <: Shape end\nstruct PolyLine <: OpenShape\n    pts::Vector{Tuple{Any, Any}}\nend\n\nabstract type ClosedShape <: Shape end\narea(x::ClosedShape) = nothing\n\nstruct Rectangle <: ClosedShape\n    x; y; w; h\nend\n\nstruct Polygon <: ClosedShape\n    pts::Vector{Tuple{Any, Any}}\nend\n\nend","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"如果我们想在模块中引入Circle和Arc，它们都是非直线形状。如果我们引入更多的分类，如LinearShape和NonLinearShape作为新的抽象类型，我们真的不能很好地扩展它，因为Julia没有多重继承。我们将创建新的类型，如为Circle创建NonLinearClosedShape和为Arc创建NonLinearOpenShape。虽然从抽象类型继承是执行接口的好方法，但由于单一继承限制，将其概念化用于大量的分类是不切实际的。在这种情况下可行的解决方案是特征。","category":"page"},{"location":"ch11guidelines/#Holy特征","page":"编程风格","title":"Holy特征","text":"","category":"section"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"特征是由Julia的贡献者Tim Holy确定的，他提出了一种模型哲学，通过isa关系来区分功能差异。这些功能差异被称为Holy特征或简称特征。如果我们着眼于geom模块，我们可以通过以下概念来简化设计：","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"所有的几何形状都派生自抽象类型Shape。\n所有形状都有一个边界框，可以通过调用bbox(::Shape)获得。\n有些形状具有有效封闭区域的特征。对于那些形状，需要实现area()函数。它不会为其他形状实现。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"根据前面的描述，所有的几何形状都只能由Shape派生。所有的形状都有一个bbox()方法。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"abstract type Shape end\nbbox(x::Shape) = nothing\n\nstruct PolyLine <: Shape\n    pts::Vector{Tuple{Any, Any}}\nend\n\nstruct Rectangle <: Shape\n    x; y; w; h\nend\n\nstruct Polygon <: Shape\n    pts::Vector{Tuple{Any, Any}}\nend\n\n### Here, we will add the traits code ###\n","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"但是只有一些形状具有area()方法。这些将插在突出显示的区域。特征本质上有两种无属性类型：一个是特征存在，另一个是特征不存在。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"abstract type HasAreaTrait end\nstruct HasArea <: HasAreaTrait end\nstruct HasNoArea <: HasAreaTrait end","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"我们还将指定哪个形状具有特征，哪个形状没有。默认情况下，形状没有面积。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"HasAreaTrait(::Type) = HasNoArea()\nHasAreaTrait(::Type{Polygon}) = HasArea()\nHasAreaTrait(::Type{Rectangle}) = HasArea()","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"最后，我们必须确保面积函数正确地利用了特征。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"area(x::T) where {T<:Shape} = area(HasAreaTrait(T), x)\narea(::HasArea, x::T) where {T<:Shape} = error(\"area(::HasArea, $T) method must be implemented\")\narea(::HasArea, r::Rectangle) = r.w*r.h","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"结果如下：","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"area(Rectangle(0, 0, 10, 20))","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"area(::Rectangle)通过实现的特征框架被分配到area(::HasArea, ::Rectangle)后返回200。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"area(Polygon([(0, 0), (10, 0), (10, 20), (0, 20)]))","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"area(::Polygon)被分派到area(::HasArea，::Polygon)，它是请求特定实现的通用参数化方法。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"area(PolyLine([(0, 0), (10, 0), (10, 20), (0, 20)]))","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"area(::PolyLine)被分派到area(::HasNoArea, ::PolyLine)，它没有实现，所以返回了一般的MethodError。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"Julia经常使用特征模式。集具有多种功能，在它们的实现中可以看到几种这样的模式。例如，大多数集都支持迭代器框架。迭代器的行为被区分为特征。","category":"page"},{"location":"ch11guidelines/#委托","page":"编程风格","title":"委托","text":"","category":"section"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"有时，我们需要为一个类型引入一些功能，但这些功能中的绝大部分已经在其他类型中存在，也就是说我们只需对这个类型增加某些额外的功能。Julia的类型不能从具体类型中继承属性。因此，扩展对象的唯一方法是组合已有对象并将其委托给组合进来的类型。下面的例子会使这个概念变得更加清楚。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"假设我们引入一个Square类型，它的函数与已定义的Rectangle类型相同，由于正方形的宽度和高度是相同的，它的构造函数只有3个参数。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"module geom4\nabstract type Shape end\nbbox(x::Shape) = nothing\n\nstruct Rectangle <: Shape\n    x; y; w; h\nend\n\nbbox(x::Rectangle) = x\n\n\n### Square has Rectangle as an attribute ###\n\nstruct Square <: Shape\n    r::Rectangle\n    Square(x, y, w) = new(Rectangle(x, y, w, w))\nend\n\nabstract type HasAreaTrait end\nstruct HasArea <: HasAreaTrait end\nstruct HasNoArea <: HasAreaTrait end\n\nHasAreaTrait(::Type) = HasNoArea()\nHasAreaTrait(::Type{Rectangle}) = HasArea()\n\narea(x::T) where {T<:Shape} = area(HasAreaTrait(T), x)\n\narea(::HasArea, x::T) where {T<:Shape} = error(\"area(::HasArea, $T) method must be implemented\")\narea(::HasArea, r::Rectangle) = r.w*r.h\n\n### Code for delegation ###\n\nfor op in [:bbox, :area]\n    @eval $op(s::Square) = ($op)(s.r)\nend\n\nend\n\nusing .geom4\ngeom4.area(geom4.Rectangle(0,0,10,20))\ngeom4.area(geom4.Square(0,0,10))","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"Square对象将Rectangle实例作为它的属性。因此，Square对象将使用已经为Rectangle对象定义的bbox和area。Lazy.jl包中定义了一些宏比如@forward来帮助实现委托。","category":"page"},{"location":"ch11guidelines/#访问方法","page":"编程风格","title":"访问方法","text":"","category":"section"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"Julia中的类型属性是公开和透明的，它几乎没有任何数据封装。然而，有时可能需要数据隐藏和访问方法(获取和设置)来访问这些变量。一个可能的原因是在设置值之前需要进行数据验证。","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"module geom\nmutable struct Rectangle\n    _x; _y; _w; _h\n    function Rectangle(x, y, w, h)\n        (w <= 0 || h <= 0) && error(\"width and height must be positive\")\n        new(x, y, w, h)\n    end\nend\nw(r::Rectangle) = r._w\nfunction w!(r::Rectangle, tw)\n    tw <= 0 && error(\"width cannot be negative\")\n    r._w = tw\nend\nend","category":"page"},{"location":"ch11guidelines/","page":"编程风格","title":"编程风格","text":"w()和w!()分别为访问和设置方法，_w是一个以下划线(_)开头的属性，它提示不应该直接访问这样的属性。","category":"page"},{"location":"ch05scope/#变量的作用域","page":"变量的作用域","title":"变量的作用域","text":"","category":"section"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"变量的作用域是变量在代码中可见的范围。变量作用域有助于避免变量命名冲突。这个概念很直观:两个函数都可以有称为x的参数，但这两个x所指的不是同一件事。类似地，在许多其他情况下，不同的代码块可以使用相同的名称而不引用相同的东西。当相同的变量名指向或不指向同一事物时，这种规则称为作用域规则。本章将对它们进行详细说明。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"语言中的某些构造引入了范围块，在这些范围块内，规定了某些变量集的作用域。变量的作用域不能是源代码的任意一组集合，相反，它将总是与这些块中的一个相关。在Julia中有两种主要类型的作用域，全局作用域和局部作用域。后者可以嵌套。在Julia中，构造的“硬作用域”和“软作用域”之间也有区别，它们会影响是否允许使用同名变量隐藏一个全局变量。","category":"page"},{"location":"ch05scope/#作用域构造","page":"变量的作用域","title":"作用域构造","text":"","category":"section"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"引入作用域块的构造有：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"构造 作用域类型 允许的位置\nmodule，baremodue 全局 全局\nstruct 局部（软） 全局\nfor，while，try 局部（软） 全局，局部\nmacro 局部（硬） 全局\n函数，do块，let块，推导，生成器 局部（硬） 全局，局部","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"值得注意的是，这个表中没有begin块和if块，它们没有引入新的作用域。这三种类型的作用域遵循不同的规则，下面将对此进行解释。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"Julia使用词法作用域，这意味着函数的作用域不是继承自调用者的作用域，而是继承自定义函数的作用域。例如，在以下代码中，foo中的x引用了其模块Bar的全局作用域中的x：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"module Bar\n    x = 1\n    foo() = x\nend;","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"而不是使用foo的作用域中的x：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"import .Bar\nx = -1;\nBar.foo()","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"因此，词法作用域意味着特定代码段中的变量所引用的内容可以单独从其出现的代码中推断出来，而不依赖于程序的执行方式。嵌套在另一个作用域中的作用域可以“看到”包含它的所有外部作用域中的变量。但是，外部作用域不能看到内部作用域中的变量。","category":"page"},{"location":"ch05scope/#全局作用域","page":"变量的作用域","title":"全局作用域","text":"","category":"section"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"每个模块都引入一个新的全局作用域，它与所有其他模块的全局作用域分开——不存在包含所有全局作用域的全局作用域。模块可以通过using或import语句，或通过使用点表示法的授权访问，将其他模块的变量引入其作用域，即每个模块都是一个所谓的命名空间，也是一个将名称与值关联起来的一级数据结构。注意，虽然可以在外部读取变量绑定的值，但只能在它们所属的模块内更改它们。作为一个安全门，你总是可以在模块内执行代码来修改一个变量。这避免了模块绑定在外部不通过调用eval而直接对代码进行修改。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"module A\n    a = 1 # a global in A's scope\nend;\nmodule B\n    module C\n        c = 2\n    end\n    b = C.c    # can access the namespace of a nested global scope \n               # through a qualified access\n    import ..A # makes module A available\n    d = A.a\nend;\nmodule D\n    b = a  # errors as D's global scope is separate from A's\nend;\nmodule E\n    import ..A  # make module A available\n    A.a = 2     # throws an error\nend;","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"注意，交互提示符(又名REPL)位于模块Main的全局作用域内。","category":"page"},{"location":"ch05scope/#局部作用域","page":"变量的作用域","title":"局部作用域","text":"","category":"section"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"大多数代码块都会引入一个新的局部作用域(完整列表见上表)。一些编程语言要求在使用新变量之前会显式地声明它们。在Julia中也可以使用显式声明：在任何局部作用域中，不管外部作用域中是否已经存在名为x的变量，写入local x就在该作用域中声明了一个新的局部变量。然而，像这样声明每个新的局部变量有点冗长和乏味，因此，与许多其他语言一样，Julia通过在局部作用域中对新变量赋值，从而隐式地将该变量声明为一个新的局部变量。大多数情况下，这是相当直观的，但与许多凭直觉行事的事情一样，细节要比从表面看起来的要微妙得多。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"当x = <value>发生在局部作用域中时，Julia应用以下规则，根据赋值表达式发生的位置和x在该位置已经引用的内容来决定表达式的含义：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"现有的局部变量：如果x已经是一个局部变量，则对现有的局部变量x赋值。\n硬作用域：如果x还不是一个局部变量，并且赋值发生在硬作用域构造中(例如，在let块、函数或宏体、推导或生成器中)，则在赋值的作用域中创建一个名为x的新局部变量。\n软作用域：如果x还不是一个局部变量，并且所有包含赋值的作用域结构都是软作用域(循环、try/catch块或struct块)，则行为取决于是否定义了全局变量x：\n如果全局x未定义，则在赋值范围内创建一个名为x的新局部变量。\n如果定义了全局x，赋值被认为是歧义的：\n在非交互式环境中(文件，eval)，会打印一个歧义警告，并创建一个新的局部变量。\n在交互式环境中(REPL, notebook)，全局变量x被赋值。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"你可能会注意到，在非交互式环境中，硬作用域和软作用域的行为是相同的，只不过在软作用域中，当一个隐式局部变量(即没有使用local x声明)对全局变量造成屏蔽时，会打印一个警告。在交互式环境中，为了方便起见，规则遵循更复杂的启发式。下面的示例将深入讨论这一点。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"既然已经知道了规则，让我们看一些例子。假设每个示例都是在一个全新的REPL会话中计算的，这样每个代码段中的惟一全局变量就是在该代码块中分配的全局变量。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"我们将从一个优雅而明确的情况开始——在硬作用域内赋值，在本例中是一个函数体，此时不存在同名的局部变量：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"function greet()\n    x = \"hello\"  # new local\n    println(x)\nend\ngreet()\nx  # global","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"在greet函数内部，赋值x = \"hello\"使x成为函数作用域中的一个新的局部变量。有两个相关的事实：赋值发生在局部作用域中，并且没有现有的局部x变量。因为x是局部的，所以是否存在一个全局变量x并不重要。例如，在定义和调用greet之前，我们先定义了x = 123：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"x = 123  # global\nfunction greet()\n    x = \"hello\"  # new local\n    println(x)\nend\ngreet()\nx  #global","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"由于greet中的x是局部的，全局x的值(或不存在这样的值)不受调用greet的影响。硬作用域规则并不关心名为x的全局变量是否存在：在硬作用域中对x的赋值是局部的(除非x在其中被显示地声明为全局的)。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"我们要考虑的下一个明确的情况是，已经有一个名为x的局部变量，在这种情况下，x = <value>总是赋值给这个已经存在的局部变量x。下面的函数sum_to计算从1到n的数字之和：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"function sum_to(n)\n    s = 0  # new local\n    for i = 1:n\n        s = s + i  # assign existing local\n    end\n    return s    # same local\nend","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"与前面的示例一样，在sum_to的顶部对s的第一次赋值将导致s成为函数体中的一个新的局部变量。for循环在函数作用域中有自己的内部局部作用域。当s = s + i出现时，s已经是一个局部变量，因此赋值更新了现有的s，而不是创建一个新的局部变量。我们可以通过调用REPL中的sum_to来测试：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"sum_to(10)\ns","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"因为s是sum_to的本地函数,调用函数对全局变量s没有影响。我们也可以看到在for循环中更新s = s + i必定更新了由初始化s = 0创建的s，因为我们得到了从整数1到10的正确的和55。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"让我们先深入了解一下for循环体有它自己的作用域这一事实，我们可以写一个稍微更复杂的变体sum_to_def，在更新s之前将和s + i保存在变量t中：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"function sum_to_def(n)\n    s = 0   # new local\n    for i = 1:n\n        t = s + i   # new local `t`\n        s = t       # assign existing local `s`\n    end\n    return s, @isdefined(t)\nend\nsum_to_def(10)","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"这个版本像以前一样返回s，但它也使用@isdefined宏返回一个布尔值，显示函数的最外层局部作用域中是否定义了一个名为t的局部变量。如你所见，在for循环体之外没有定义t。这还是因为硬作用域规则：由于对t的赋值发生在函数内部，这引入了硬作用域，赋值导致t在它出现的局部作用域内成为一个新的局部变量，即在循环体内部。即使有一个名为t的全局变量，也不会有什么区别——硬作用域规则不会受到全局作用域中情况的影响。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"让我们来看看软作用域规则所涵盖的一些更模糊的情况。我们将通过将greet和sum_to_def函数的主体提取到软作用域环境中来研究这个问题。首先，让我们把greet的主体放到for循环中——它是软的，而不是硬的——然后在REPL中计算它：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"for i = 1:3\n    x = \"hello\" # new local\n    println(x)\nend\nx","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"由于在执行for循环时没有定义全局x，因此软作用域规则的第一种情况将被应用，x将被创建为for循环的局部变量，因此在循环执行后全局x仍未定义。接下来，让我们考虑将sum_to_def的主体提取到全局作用域，将其参数固定为n = 10：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"s = 0\nfor i = 1:10\n    t = s + i\n    s = t\nend\ns\n@isdefined(t)","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"这段代码做了什么的？这是个棘手的问题。答案是“视情况而定”。如果以交互方式输入此代码，则其行为与在函数体中相同。但是，如果代码出现在文件中，它会打印一个歧义警告，并抛出一个未定义变量的错误。让我们先看看它在REPL中的工作情况：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"s = 0   # global\nfor i = 1:10\n    t = s + i   # new local `t`\n    s = t       # assign global `s`\nend\ns   # global\n@isdefined(t)   # global","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"REPL通过判断是否定义了同名的全局变量来确定循环内的赋值是赋值给全局变量还是创建新的局部变量，这种行为近似于函数体内的行为。如果存在同名的全局变量，则赋值操作会更新它。如果不存在全局变量，则赋值将创建一个新的局部变量。在这个例子中，我们看到了这两种情况：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"没有全局变量t，所以t = s + i创建一个新的t，它是for循环的局部变量。\n有一个全局变量s，所以s = t赋值给它。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"第二条解释了为什么循环的执行会改变s的全局值，第一条解释了为什么在循环执行后t仍然是未定义的。现在，让我们对相同的代码进行改造，模拟代码在文件中的情况，然后执行：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"code = \"\"\"\ns = 0   # global\nfor i = 1:10\n    t = s + i   # new local `t`\n    s = t   # new local `s` with warning\nend\ns,  # global\n@isdefined(t)   # global\n\"\"\";\ninclude_string(Main, code)","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"这里我们使用include_string来执行代码，就好像它是文件的内容一样。我们也可以将代码保存到文件中，然后在该文件上调用include——结果将是相同的。如你所见，这与在REPL中的结果有很大的不同。让我们来分析一下这里发生了什么：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"在执行循环之前，全局变量s被定义为值0。\n赋值s = t发生在软作用域中——任何函数体或其他硬作用域构造之外的for循环中。\n因此，适用于软作用域规则的第二种情况，并且赋值是不明确的，因此会发出警告。\n继续执行，使s成为for循环体的局部变量。\n由于s是for循环的局部变量，当t = s + i被求值时，它是未定义的，从而导致错误。\n计算到此结束，但如果到达s和@isdefined(t)，它将返回0和false。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"这演示了作用域的一些重要方面：在作用域中，每个变量只能有一种含义，并且该含义与表达式的顺序无关。在循环中表达式s = t的存在导致s是循环的局部变量，这意味着当它出现在t = s + i的右边时，它也是局部变量，即使该表达式首先出现并首先执行。你或许会认为循环第一行的s可以是全局的，循环第二行的s可以是本地的，但实际上是不可能的，因为这两行在同一个作用域块，在给定的作用域，每个变量只能有一种含义。","category":"page"},{"location":"ch05scope/#关于软作用域","page":"变量的作用域","title":"关于软作用域","text":"","category":"section"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"现在，我们已经介绍了所有的局部作用域规则，但是在结束本节之前，应该说明一下为什么在交互和非交互环境中处理模糊的软作用域情况是不同的。人们可能会问两个明显的问题：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"为何不在所有地方都像在REPL中那样的工作呢？\n为和不在所有地方都像在文件中那样工作并去掉警告呢？","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"在Julia≤0.6,所有全局作用域的工作方式都如同当前的REPL一样：当x = <value>发生在一个循环(或try/catch，或struct体)内，但在函数体(或let块或推导)以外，x在循环内是否为局部的取决于是否定义了全局变量x。这种行为具有直观和方便的优点，因为它尽可能接近函数体内部的行为。特别地，当调试函数的行为时，它使得在函数体和REPL之间来回移动代码变得很容易。然而，它也有一些缺点。首先，这是一种相当复杂的行为：多年来，许多人对这种行为感到困惑，并抱怨它既复杂又难以解释和理解。其次，可以说更糟糕的是，它不利于“大规模”编程。当你在一个地方看到像这样的一小段代码时，很清楚会发生什么：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"s = 0\nfor i = 1:10\n    s += i\nend","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"显然，其目的是修改现有的全局变量s，不然会是什么呢？然而，并非所有现实世界的代码都是如此简短或清晰。我们发现像下面这样的代码经常大量的出现：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"x = 123\n\n# much later\n# maybe in a different file\n\nfor i = 1:10\n    x = \"hello\"\n    prinntln(x)\nend\n\n# much later\n# maybe in yet another file\n# or maybe back in the first one where `x = 123`\n\ny = x + 234","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"现在就不是很明确应该发生什么。因为x + \"hello\"是一个方法错误，它的意图似乎是让x在for循环中是局部的。但是运行时的值和当时存在的方法不能用来确定变量的作用域。在Julia≤0.6的行为方式下，会存在有人先写了for循环，它可以很好的工作，但后来当别人在远处（可能在不同的文件中）添加了一个新的全局变量，代码突然改变了含义，它可能会显式地终止，更糟的是，有可能默默地做错误的事情。这种“幽灵般的远距离行动”是优秀的程序语言设计应该避免的。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"因此，在Julia 1.0中，简化了作用域规则：在任何局部作用域中，对一个不属于局部变量的名称赋值将创建一个新的局部变量。这完全消除了软作用域的概念，并消除了幽灵行动的可能性。软作用域的删除使大量的bug得到了暴露和修复，这也证明了选择删除它是正确的。但也存在一些不便，如下面的代码所示：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"s = 0\nfor i = 1:10\n    global s += i\nend","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"看到全局注释了吗？显然，这种情况是不能容忍的。但严格地说，这种需要global的顶层代码存在两个主要问题：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"不方便将函数体中的代码复制并粘贴到REPL中进行调试——你必须在调试时添加global注释，然后在拷回函数时删除它们。\n初学者会在编写这类代码时漏掉global，并对代码不能工作感到莫名其妙——他们得到的错误是s未被定义，这似乎对碰巧犯这种错误的人没有任何启发效果。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"从Julia 1.5开始，这段代码在交互式环境中(如REPL或Jupyter笔记本)不需要global注释(就像Julia 0.6)，在文件和其他非交互式环境中，它打印出非常直接的警告：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"在软作用域中对s的赋值是不明确的，因为存在同名的全局变量：s将被视为一个新的局部变量。通过使用local s来消除该警告，或使用global s来赋值给现有的全局变量来消除歧义。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"这既解决了上述两个问题，又保留了1.0中“大规模编程”好处的行为：全局变量对可能遥远的代码含义没有幽灵影响。在REPL中复制粘贴调试工作良好，初学者也不会遇到任何问题，任何时候，如果有人忘记了一个global注释，或者不小心在一个软作用域中用一个局部隐藏了一个现有的全局变量（虽然听起来很奇怪），他们就会得到一个清晰的警告。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"这种设计的一个重要属性是，任何在文件中执行而没有警告的代码在新的REPL中都将以相同的方式执行。另一方面，如果你使用一个REPL会话并将其保存到文件中，如果它的行为与在REPL中不同，那么你将得到一个警告。","category":"page"},{"location":"ch05scope/#Let块","page":"变量的作用域","title":"Let块","text":"","category":"section"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"与对局部变量的赋值不同，let语句在每次运行时分配新的变量绑定。赋值会修改现有值的位置，let会创建新的位置。这种差异通常并不重要，只有在变量通过闭包存活的时间超过其作用域的情况下才会显现。let语法接受逗号分隔的一系列赋值和变量名：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"x, y, z = -1, -1, -1;\nlet x = 1, z\n    println(\"x: $x, y: $y\") # x is local variable, y the global\n    println(\"z: $z\") # errors as z has not been assigned yet but is local\nend","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"赋值是按顺序执行的，在左边的新变量被引入之前，右边的每个变量都在作用域内求值。因此，写let x = x是有意义的，因为两个x变量是不同的，有不同的存储空间。下面是一个需要let行为的例子：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"Fs = Vector{Any}(undef, 2); i = 1;\nwhile i <= 2\n    Fs[i] = () -> i\n    global i += 1\nend\nFs[1]()\nFs[2]()","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"在这里，我们创建并存储了两个返回变量i的闭包。然而，它始终是同一个变量i，因此两个闭包的行为是相同的。我们可以使用let为i创建一个新的绑定：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"Fs = Vector{Any}(undef, 2); i = 1;\nwhile i <= 2\n    let i = i\n        Fs[i] = () -> i\n    end\n    global i += 1\nend\nFs[1]()\nFs[2]()","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"由于begin构造不引入新的作用域，所以使用零参数let只引入一个新的作用域块而不创建任何新绑定是很有用的：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"let\n    local x = 1\n    let\n        local x = 2\n    end\n    x\nend","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"因为let引入了一个新的作用域块，所以内部的局部变量x与外部的局部变量x是不同的。","category":"page"},{"location":"ch05scope/#循环和推导","page":"变量的作用域","title":"循环和推导","text":"","category":"section"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"在循环和推导式中，在其主体作用域中引入的新变量会在每次循环迭代时重新分配，就像循环主体被一个let块包围一样，如下例所示：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"Fs = Vector{Any}(undef, 2);\nfor j = 1:2\n    Fs[j] = ()->j\nend\nFs[1]()\nFs[2]()","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"for循环或推导迭代变量总是一个新变量：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"function f()\n    i = 0\n    for i = 1:3\n        # empty\n    end\n    return i\nend;\nf()","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"然而，有时可以重用现有的局部变量作为迭代变量。这可以通过添加关键字outer方便地完成：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"function f()\n    i = 0\n    for outer i = 1:3\n        # empty\n    end\n    return i\nend;\nf()","category":"page"},{"location":"ch05scope/#常量","page":"变量的作用域","title":"常量","text":"","category":"section"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"变量的一个常见用法是给特定的、不变的值命名。这样的变量只被赋值一次。这个意图可以通过使用const关键字传递给编译器：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const e = 2.718;\nconst pi = 3.142;","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"可以在一个const语句中声明多个变量：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const a, b = 1, 2","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const声明只能在全局作用域中的全局变量上使用。编译器很难优化涉及全局变量的代码，因为它们的值(甚至它们的类型)几乎在任何时候都可能发生改变。如果全局变量不变，添加const声明就可以解决这个性能问题。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"局部常量则不同的。编译器能够自动确定局部变量何时为常量，因此不需要声明局部常量，实际上目前也不支持局部常量。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"特殊的顶层赋值，例如由function和struct关键字执行的赋值，默认情况下是常量。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"注意，const只影响变量绑定。变量可以绑定到一个可变对象(比如数组)，并且该对象仍然可以被修改。另外，当试图给一个被声明为常量的变量赋值时，可能会出现以下情况：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"如果新值的类型与常量的类型不同，则抛出一个错误：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const x = 1.0\nx = 1","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"如果新值的类型与常量相同，则会打印警告：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const y = 1.0\ny = 2.0","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"如果赋值不会导致变量值的改变，则不会给出消息：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const z = 100\nz = 100","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"最后一条规则适用于不可变对象，只要值不发生改变，变量的重新绑定实际上是被忽略的，例如：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const s1 = \"1\"\ns2 = \"1\"\npointer.([s1, s2], 1)\ns1 = s2\npointer.([s1, s2], 1)","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"然而，对于可变对象，会按预期打印警告：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const a = [1]\na = [1]","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"请注意，尽管有时可以，但强烈建议不要更改const变量的值，除非在交互使用时为了方便而故意为之。更改常量可能会导致各种问题或意外行为。例如，如果一个方法引用了一个常量，并且在更改该常量之前已经编译过了，那么它将会继续使用原来的值：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const x = 1\nf() = x\nf()\nx = 2\nf()","category":"page"},{"location":"ch07array/#数组","page":"数组","title":"数组","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"在前一章中，我们了解了简单数组以及其他形式的集。我们还遍历了集。然而，在Julia中，数组在提供高性能容器方面扮演着重要的角色，这些容器是由内存管理的，能够在本机应用程序之间传输数据。本章，我们将看看数组的一些高级应用。有时，操作是在数组上定义的，或者通过简单的语法修改可以执行复杂的数组操作。","category":"page"},{"location":"ch07array/#容器","page":"数组","title":"容器","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"数组是用于各种操作的最常见集，因为它们是可变的、可扩展的，并且在正确使用时是高效的。本章讨论的一些主题对于新手来说可能是高级的。因此，在你积累语言经验的同时，建议你稍后再复习本章的部分内容。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"向量作为容器是一种非常常见的用例。一些数据结构，如堆栈、队列、二进制堆通常使用一维数组或向量来实现。Julia提供了简单的函数来处理这些情况。下面展示了将向量用作堆栈的示例。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = []\npush!(a, 5)\npush!(a, 5, 6, 7, 8)\npop!(a)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"上述方法对向量按照堆栈的方式进行修改。在操作结束时，还可以使用empty!(vector)方法清空容器。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"length(a)\nisempty(a)\nempty!(a)\nisempty(a)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"让我们看看数组作为队列的操作方式。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"push!(a, 1, 2, 3, 4, 5)\npopfirst!(a)\npushfirst!(a, 1)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"pushfirst!(v, value)是一种将值添加到向量开头的方法。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"note: Note\n尽管pushfirst!和popfirst!方法是存在的，但它们不是最有效的，因为插入和删除第一个元素可能需要复制或移动元素。","category":"page"},{"location":"ch07array/#维度","page":"数组","title":"维度","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"数组可以是任意维度的。虽然我们在前面主要学习了向量(1维)和矩阵(2维)，我们将在本章更多地了解一些高维数组。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:24), 4, 3, 2)\nndims(a)\nsize(a)\nsize(a, 3)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"reshape接受一个集并创建指定形状的数组。ndims给出数组的维数，而size给出每个维中的元素数。size(array, dim)给出在特定维度的大小。数组的内存布局如下图所示：","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"(Image: 3D Array)","category":"page"},{"location":"ch07array/#索引","page":"数组","title":"索引","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"数组使用表达式A[I_1, I_2, ..., I_n]索引。I_i是我们将在本节中探讨的各种类型的索引。","category":"page"},{"location":"ch07array/#常量","page":"数组","title":"常量","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"索引表达式的最简单形式是标量或数字。下面是一些例子：","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:24), 4, 3, 2, 1)","category":"page"},{"location":"ch07array/#范围","page":"数组","title":"范围","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"索引表达式也可以是范围。冒号(:)表示维度中的所有索引。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a[:, 1, 1, 1]\na[2:3, 1, 1, 1]\na[1:2:3, 1, 1, 1]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"可以看到，范围对象可以是任何整数范围类型，如UnitRange、StepRange等。索引表达式也可以使用多个范围索引。这会产生多维数组，其中的元素是从范围中指定的位置提取的。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a[1:2:3, 1:2:3, 1, 1]","category":"page"},{"location":"ch07array/#向量","page":"数组","title":"向量","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"当索引表达式是向量或非标量时，输出将引入额外的维度。下面是一些例子：","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a[1:2:3, 1:2:3, [1], [1]]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"如上例所示，创建的是2×2×1×1数组，而不是2×2数组。默认情况下，索引向量是一维行向量。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a[1:2:3, [1; 3], 1, 1]\na[1:2:3, [1, 3], 1, 1]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"当索引不是按行顺序排列时，输出将无法合并为2×2矩阵：","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"b = a[1:2:3, [1 3], 1, 1]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"生成了一个2×1×2的矩阵。类似地，可以通过提供多维索引来创建更复杂的矩阵。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a[:, [2], [1], [1]]\na[[1 2; 3 4], [2], [1], [1]]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"这里，在第一个索引中引入多维索引为矩阵增加了一个额外维度。矩阵具有2×2×1×1×1维度。前2列是对第二列a[:, [1], [1], [1]]基于索引参数[1 2; 3 4]的重排列。","category":"page"},{"location":"ch07array/#线性索引","page":"数组","title":"线性索引","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"我们在前一章讨论过，数组以行为主的方式存储在一个连续的内存位置，索引指向底层数据。底层数据可以用单个整数索引访问。这种索引称为线性索引。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:6), (2, 3))\na[5]\na[1, 3]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"有一个叫做LinearIndices的类型可以帮助创建这种映射。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"LinearIndices(a)","category":"page"},{"location":"ch07array/#笛卡尔索引","page":"数组","title":"笛卡尔索引","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"笛卡尔索引是一个数字元组，作为数组的维数，代表一个元素。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"A = reshape(collect(1:6), 3, 2)\nci = CartesianIndices(A)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"使用笛卡尔或线性索引取决于对象和数据的组织。稍后，我们将通过查看视图和子数组来进一步了解这些主题的细节。","category":"page"},{"location":"ch07array/#布尔索引","page":"数组","title":"布尔索引","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"布尔索引的作用更像是数据的过滤器。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"x = reshape(collect(1:16), 4, 4)\nfilter = map(ispow2, x)\nx[filter]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"虽然逻辑索引似乎只是为了挑选筛选器值为真的特定值，但与范围索引组合，可以观察到有趣的变化。例如，下面的例子完全选取了第2行和第3行。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"x[[false, true, true, false], :]","category":"page"},{"location":"ch07array/#赋值","page":"数组","title":"赋值","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"我们使用索引的大多数例子都与从数组中提取信息有关。不过，也可以使用类似的表达式为数组元素赋值。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:24), 4, 3, 2, 1);\na[:, 2, 1, 1] = fill(25, 4)\na","category":"page"},{"location":"ch07array/#特殊索引","page":"数组","title":"特殊索引","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"为了便于在集中遍历，可以使用begin和end等特定的关键字作为索引。这些索引也可以与一些数值运算一起使用。前一个数组的元素可以像这样访问：","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a[begin, :, 2, 1], a[begin+1, :, 2, 1]\na[end, :, 2, 1], a[end-1, :, 2, 1]","category":"page"},{"location":"ch07array/#接口","page":"数组","title":"接口","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"以下方法适用于数组或所有支持元素索引访问的集(如Dict)。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"访问X[i]时调用getindex(X, i)返回位于i的元素的值。在多维数组中，访问X[I_1, I_2，..., I_n]时调用扩展的表达式getindex(X, I_1, I_2，..., I_n]。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"setindex!(X, v, i)将值v赋给位置i的数组元素。在多维数组中，表达式X[I_1, I_2，..., I_n] = v内部调用setindex!(X, v, I_1, I_2, ..., I_n)。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"表达式X[begin]调用firstindex(X)来获得第一个索引。firstindex(X, dim)用来获得指定维度的第一个索引。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"表达式X[end]调用lastindex(X)来获得最后一个索引。与firstindex一样，lastindex也可以将维度作为参数。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"firstindex(a)\nlastindex(a)\nlastindex(a, 1)\nlastindex(a, 2)\nlastindex(a, 3)\nlastindex(a, 4)","category":"page"},{"location":"ch07array/#切片","page":"数组","title":"切片","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"切片是通过指定索引来使用数组的一部分。以下是一些例子：","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:9), 3, 3)\na[:, 1]\na[1, :]\na[1, 2:3]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"大多数示例都相当直观，但请注意a[1，:]和a[1, 2:3]，这两个都应该是行矩阵。但是，Julia将返回一个单维列向量。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"b = a[1:2, :]\nb[1, 2] = 10\nb\na","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"使用索引获得切片的最终结果是分配一个新数组。可以看到，修改数组b并不影响a中的数据。这将导致大量的分配，并可能使应用程序的内存池碎片化。其次，这种无价值的增加分配会影响性能。让我们重写这个例子：","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"v = @view a[1:2, :]\nv[1, 2] = 10\nv","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"宏@view围绕数组创建一个视图，其引用数组a中的相同对象。由于视图没有自己的数据，修改视图也会导致底层容器数组中的数据被修改。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a","category":"page"},{"location":"ch07array/#广播","page":"数组","title":"广播","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"让我们看一些矩阵运算。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:9), 3, 3)\nb = reshape(collect(9:-1:1), 3, 3)\na + b","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"将a的每个元素与b的相应元素相加，最终得到一个与输入数组维数相同的数组。由于运算符+被定义为元素类型的运算，因此它可以直接应用于矩阵或数组。让我们看看乘法运算(*)。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a * b","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"返回的结果不是基于元素的乘法，而是矩阵乘法，也称为数组内积。如果要对数组进行元素运算，可以使用广播方法进行同样的操作。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"broadcast(*, a, b)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"可以使用行内点符号(.*)实现同样的效果。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a .* b","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"如果数组a和b的尺寸不同呢？它们能在元素级别上交互吗？保持a不变，让b分别为行向量和列向量，观察结果。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:9), 3, 3)\nb = [1 2 3]\na .+ b","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"同样，当b是列向量时：","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"b = [1, 2, 3]\na .+ b","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"当其中一个数组是行向量或列向量时，如果维数与该方向上的另一个向量匹配，那么它们将沿着该向量的长度广播。尽管广播是以数组为例介绍的，但它可以应用于任何集类型。下面是一个展示了字符串在集中按元素进行连接的示例。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"broadcast(string, (\"one\", \"two\", \"three\", \"four\"), \": \", 1:4)\nstring.((\"one\", \"two\", \"three\", \"four\"), \": \", 1:4)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"“: ”只有一个条目，它重复4次以保证与正在广播的其他集的映射一致。","category":"page"},{"location":"ch07array/#性能","page":"数组","title":"性能","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"有人可能会想，broadcast的效果可以很容易地用repeat来模拟。repeat获取数组的元素，并沿着指定的每个维度重复它们。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"v = [1, 2]\nrepeat(v, 2, 3) # Repeats twice in dim 1 and thrice in dim 2\na + repeat(b, 1, 3)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"这种说法并非完全不正确。但是，每次调用repeat都会分配数组并增加性能损失。broadcast消除了这种额外分配数组的需要。","category":"page"},{"location":"ch07array/#broadcast-vs.-map","page":"数组","title":"broadcast vs. map","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"在讨论broadcast时，有必要回顾前面讨论的map函数。不像broadcast那样在需要时重复元素，map函数执行一对一的映射。从下面的示例中可以看出，map函数只返回一个长度为3的数组，该数组与a和b的最小尺寸相匹配。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a\nb\nmap(+, a, b)","category":"page"},{"location":"ch07array/#归约","page":"数组","title":"归约","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"数组上的归约运算类似于求和。可以对数组沿行和列进行聚合。将数组元素映射到特定函数并按行和列归约结果是相当常见的输出。与broadcast类似，map和reduce方法确保中间分配最小化。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:16), (2, 2, 2, 2))\nreduce(+, a)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"给定集a, reduce方法对所有元素应用二元运算(+)并返回所有元素的和。","category":"page"},{"location":"ch07array/#结合性","page":"数组","title":"结合性","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"让我们将前面的运算符+替换为-。从左到右的结合律与从右到左的结合律会有完全不同的结果。Julia提供了foldl和foldr两个方法，这两个方法实际上是reduce方法左、右结合性的表示。我们可以使用结合运算符(=>)来仔细研究它们的区别。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"foldl(=>, [1, 2, 3, 4])\nfoldr(=>, [1, 2, 3, 4])\nreduce(=>, [1, 2, 3, 4])","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"用运算符(-)替换(=>)，可以看到结果的差异。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"foldl(-, [1, 2, 3, 4])\nfoldr(-, [1, 2, 3, 4])\nreduce(-, [1, 2, 3, 4])","category":"page"},{"location":"ch07array/#映射和归约","page":"数组","title":"映射和归约","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"集可以映射到特定的函数，结果可以归约为聚合结果。一个叫做mapreduce的专门函数同时结合了这两种运算。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"mapreduce(x->x*x, +, [1, 2, 3, 4])","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"前面的示例计算了集的平方和。","category":"page"},{"location":"ch07array/#切片-2","page":"数组","title":"切片","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"我们所研究的映射和归约方法同样适用于其他集。mapslices是一种特殊的函数，它与数组和数组切片密切相关。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:16), 2, 2, 2, 2)\nmapslices(sum, a, dims=[1, 2])","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"该函数对数组的前2维应用sum函数并返回结果。","category":"page"},{"location":"ch07array/#抽象数组类型","page":"数组","title":"抽象数组类型","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"到目前为止，我们观察到数组有两个不同的操作。首先，它提供了一个存储数据的容器，其次，它提供了访问和修改数据的各种方法。可以将迭代、索引和切片视为数据的各种访问方法。像Array{T,N}这样的具体类型满足这两种需求，但在存储方面是死板的。例如，一个只有对角元素的矩阵只需要N个元素来存储数据。一个三对角矩阵（对角和与其平行的前、后对角元素）只需要3N-2个元素来存储数据。使用Array{T, 2}或矩阵来存储这些数据是浪费的，因为它需要N*N的存储空间。AbstractArray{T, N}是满足这种需求的接口。以下是期望由派生类型实现的一些功能，以便它们与其他数组类型无缝地工作。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"size接口提供定义数组所有维度的大小。\n索引接口getindex和setindex!访问和修改数组的数据。\n数组的迭代器接口，使其行为像一个集。\n当需要时，一个类似的接口可以将专门化的数组转换为等效的array{T, N}类型。\n最后，axis方法支持非标准索引，比如从0而不是1开始索引。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"虽然我们建议读者阅读Julia文档以完全理解这个概念，但我们使用示例代码展示了一些实现。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"note: Note\nAbstractVector{T}和AbstractMatrix{T}分别是AbstractArray{T,1}和AbstractArray{T,2}的别名。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"让我们实现一个单位矩阵。单位矩阵的对角元素定义为1，其他元素定义为0。因为它们有固定的模式，所以不需要setindex!方法。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"struct MyIdentity{T} <: AbstractMatrix{T}\n    l::Int\nend\nBase.size(m::MyIdentity)=(m.l, m.l)\nBase.size(m::MyIdentity, d)=(d == 1 || d == 2) ? m.l : error(\"Invalid dimensions\")\nfunction Base.getindex(m::MyIdentity{T}, i, j) where {T}\n    1 <= i <= m.l && 1 <= j <= m.l || error(\"Invalid indices\")\n    i == j && return one(T)\n    return zero(T)\nend","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"仅仅是这个简单的定义就可以给出一个具有几乎所有必要功能的单位矩阵。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = MyIdentity{Int}(3)\na[2, 1]\na = MyIdentity{Float32}(3)\nsize(a)\nsize(a, 2)\nlength(a)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"只需定义size和getindex方法就可以定义矩阵的大部分行为。这是由于Julia基中定义的默认值。现在，如果我们将一个向量与MyIdentity{T}矩阵相乘，我们应该得到相同的向量。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a[5] # Linear Indexing\na*[1, 2, 3]","category":"page"},{"location":"ch07array/#稀疏数组","page":"数组","title":"稀疏数组","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"稀疏数组是我们前面讨论的AbstractArray概念的扩展。稀疏数组的本质是减少数组所需的总体存储空间。在许多数值应用中，行列组合中的大多数值都是0，非0值只出现在某些位置。例如，对角线矩阵只有对角线元素上的数据。稀疏数组更进一步，允许将值存储在一个向量中，并通过一个或多个索引向量存储值的位置。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"note: Note\n稀疏数组是Julia标准库中模块SparseArrays的一部分。在使用与稀疏数组相关的任何类型或方法之前，请确保通过using SparseArrays命令导入符号。我们将在后面的章节中详细讨论模块。","category":"page"},{"location":"ch07array/#稀疏向量存储","page":"数组","title":"稀疏向量存储","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"using SparseArrays\nstruct SparseVector{Tv, Ti <: Integer} <: AbstractSparseVector{Tv, Ti}\n    n::Int              # Length of the sparse vector\n    nzind::Vector{Ti}   # Indices of stored values\n    nzval::Vector{Tv}   # Stored values, typically nonzeros\nend","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"nzval是所有非零值的存储向量，nzind是这些值的索引位置，其中n是稀疏向量的长度。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"using SparseArrays\nI = [1, 4, 3, 5]; V = [1, 2, -5, 3];\nR = sparsevec(I, V)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"当I向量中索引的最大值为5时，将创建一个5元素向量。向量R的成员可以像常规向量一样被访问。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"R[2]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"findnz方法返回存储非零值的所有索引位置。本质上，给定一个稀疏向量或矩阵，它给出了nzind和nzval向量。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"findnz(R)","category":"page"},{"location":"ch07array/#稀疏矩阵存储","page":"数组","title":"稀疏矩阵存储","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"将稀疏向量的概念更进一步，我们可以采用为第2个维度增加一个向量来存储一个矩阵。但是，为了更好地进行存储管理，通常使用以下方法。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"列索引以递增顺序存储在向量中。\n行存储在第二个向量中，当列索引发生冲突时，行按递增顺序存储。\n值存储在按相同方式定义的单独向量中。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"这个概念被称为压缩稀疏列(CSC)。虽然这种格式具有很高的存储效率，但它对插入或修改并不友好，因为任何插入都可能需要将向量中的所有值向右移动。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"struct SparseMatrixCSC{Tv, Ti <: Integer} <: AbstractSparseMatrix{Tv, Ti}\n    m::Int              # Number of rows\n    n::Int              # Number of columns\n    colptr::Vector{Ti}  # Column j is in colptr[j]:(colptr[j+1]-1)\n    rowval::Vector{Ti}  # Row indices of stored values\n    nzval::Vector{Tv}   # Stored values, typically nonzeros\nend","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];\nS = sparse(I, J, V)\nS[1, 2]\nsize(S)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"与稀疏向量示例一样，SparseMatrixCSC也有类似的函数来创建、访问和操作矩阵。我们将把使用这些数据结构的细节留给读者。","category":"page"},{"location":"ch07array/#效率","page":"数组","title":"效率","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"虽然稀疏数据结构很适合存储，但它们可能不是索引和迭代的最佳选择。在使用这些结构时，要非常小心数据访问的复杂性。即使是简单的索引访问也可能需要扫描索引和数据向量的很大一部分。虽然在迭代过程中增量访问非零值可能是高效的，但对特定索引的随机访问就没有那么高效了。","category":"page"},{"location":"ch07array/#线性代数","page":"数组","title":"线性代数","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"前面介绍的大多数概念都是数组、向量和矩阵的表示方面，本节是关于它们在处理数学和科学计算中的应用。Julia线性代数功能被聚合到标准库下的一个名为LinearAlgebra的模块中。因此，在使用方法和数据结构之前，你需要使用以下语句。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"using LinearAlgebra","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"Julia线性代数模块可以看成是三个不同的部分。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"Julia原生的基本矩阵和向量运算。\nLAPACK函数。\nBLAS函数。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"基本模块包含诸如转置(tr)、求逆(inv)、点积(dot)等矩阵运算。还有其他方法，如奇异值分解(svd)、上下三角分解等。特征模块提供各种矩阵类型的特征值计算。我们不会在这里深入研究这些概念，在后面的章节中会有选择地介绍一些方法。","category":"page"},{"location":"#安装与配置","page":"安装与配置","title":"安装与配置","text":"","category":"section"},{"location":"","page":"安装与配置","title":"安装与配置","text":"Julia是一个跨平台应用，安装起来非常容易，不管是使用Windows、Linux还是macOS系统，都可到 Julia官方网站下载安装。在Windows下，安装过程中选择Add Julia to Path复选框，安装成功后就可以在命令行的任何位置启动Julia。","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"Julia有自己的图形窗口REPL（读取-求解-打印-循环），可对程序进行读取和执行。你可以通过桌面快捷图标、程序菜单或命令行来启动这个程序，当程序启动后，你将看到如下界面：","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"(Image: Julia启动界面)","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"最后一行 julia> 为命令提示符，它的出现表明Julia程序正常启动并进入到REPL，等待你输入代码。成功安装Julia软件后，我们需要对开发环境做一个简单的配置，以使你在Julia中的输入和输出看起来与书中的结果相一致（可能会有细微的差别）。在 julia> 提示符后输入如下命令：","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"using Pkg\nPkg.add(\"OhMyREPL\")\nusing OhMyREPL","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"大家可以先不用关心每条语句的具体含义，后面会逐步学到。配置完成后，如果你输入一行代码并按回车，REPL将显示结果：","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"1 + 1","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"另外一点需要说明的是，每次重新启动Julia程序后都要首先输入using OhMyREPL语句，这显然很麻烦。一个解决方案是可以将这条语句放入Julia启动文件startup.jl中。这样，Julia在启动时就会自动调用这条语句。startup.jl文件位于~/.julia/config/中，如果该目录下没有startup.jl文件或.julia目录中没有config目录，则可以自己创建一个。","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"在下载程序包时，如遇下载速度很慢的情况，可以将Julia程序包服务器镜像切换为国内镜像源，方法是在startup.jl文件中添加一条语句：ENV[\"JULIA_PKG_SERVER\"]=\"https://mirrors.bfsu.edu.cn/julia/static\"。","category":"page"},{"location":"ch12performance/#性能","page":"性能","title":"性能","text":"","category":"section"},{"location":"ch12performance/","page":"性能","title":"性能","text":"性能是Julia语言发展的核心特征和基本前提。因此，理解系统中可用的各种工具和技术是很自然的，这些工具和技术有助于编写高性能的代码。","category":"page"},{"location":"ch12performance/#背景知识","page":"性能","title":"背景知识","text":"","category":"section"},{"location":"ch12performance/","page":"性能","title":"性能","text":"优化的首要原则是不优化。Unix操作系统大师Kernighan和Pike在他们的开创性著作《编程实践》中提出了这一建议。一个正确工作的程序远远优于一个不正确的快速程序，这一点在二十年来没有什么变化。然而，为了确保程序的行为接近可接受的性能，需要采取许多变通方法。没有什么比绝对性能或针对所有条件进行优化的代码更好的了。在今天的标准下高性能的代码在计算能力方面与未来相对简单的应用程序相比可能要差得多。旅行者号是第一个离开太阳系的人造物体，它的计算能力远不如现代的手机。我们不必真正地手动优化每一个代码位。在大多数情况下，许多最优代码生成器和编译器编译的代码都远优于手工优化的代码。像Julia这样的现代语言利用LLVM来处理跨平台的最优代码生成，并解决了编译或代码生成过程中许多众所周知的优化问题。有人可能会问，如果硬件既便宜又容易获得，我们为什么还要费心优化代码呢？答案在于，无论硬件多么便宜，你都希望从中再挤出一些。","category":"page"},{"location":"ch12performance/#正确的优化级别","page":"性能","title":"正确的优化级别","text":"","category":"section"},{"location":"ch12performance/","page":"性能","title":"性能","text":"在单个处理器的单个线程上运行多个应用程序并不是真正的同步多任务处理。操作系统根据调度抢占任务，让处理器一次执行一个任务。用户会感觉所有的任务都在同时运行，实际上它们只是在很短的时间内执行，然后切换到下一个任务。在基于图形用户界面(GUI)的应用程序中，用户界面对用户输入的响应比其他后台任务的执行更加重要。对于在单处理器系统上运行长时间计算密集型任务的多任务应用程序，通常的做法是间歇性地处理UI事件，以保持UI的响应性。这在Windows系统中被称为空闲循环处理。在这里，最佳响应时间优先于原始执行速度。因此，纯粹的代码执行速度不是所有代码优化项目的目标。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"当处理器的指令集没有三角函数时，三角函数的计算将是耗时的，因为它们是通过软件仿真来实现的。游戏程序等对性能敏感的应用程序会用以下数学方程模拟行为。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"sin(θ+δθ)=sin(θ)cos(δθ) + cos(θ)sin(δθ) 2ex  \ncos(θ+δθ)=cos(θ)cos(δθ)-sin(θ)sin(δθ)  2ex\nlim_δθ 0sinδθ = δθ quad 和quad  lim_δθ0cosδθ=1-fracδθ^22","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"基本上，它们会以15度或30度的间隔查找sinθ和cosθ的值，并使用前面给出的增量方程计算中间值。用上述方程以15度为间隔生成的表仍在相当高的精度范围内。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"n = 6;\nδ = pi/180*(90/n);\nsinδ, cosδ = δ, (1-δ*δ/2);\nm = Matrix{Float64}(undef, (n+1, 2));\nm[1, 1], m[1, 2] = 0.0, 1.0;\nfor i in 1:n\n    m[i+1, 1] = m[i, 1]*cosδ + m[i, 2]*sinδ\n    m[i+1, 2] = m[i, 2]*cosδ - m[i, 1]*sinδ\nend\nm\nm1 = [[sin(i*δ) for i in 0:n] [cos(i*δ) for i in 0:n]]\nusing Statistics\nmean(m1-m), std(m1-m)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"这样的粗略估计可以产生相当精确的计算，同时保持足够快的计算速度。对于指令内置了三角函的现代CPU，可能不需要这种权衡。然而，它可以说明性能与精度的权衡在优化中是很常见的。而且，它们大多是特定于领域的。","category":"page"},{"location":"ch12performance/#资源","page":"性能","title":"资源","text":"","category":"section"},{"location":"ch12performance/","page":"性能","title":"性能","text":"云计算资源可以根据需要添加到项目或问题中。然而，资源成本显著增加了项目成本。增加硬件或处理能力可以解决更大的问题，但它们也增加了总成本。例如，如今的智能手机能够处理设备语音识别和许多涉及深度学习和神经计算的复杂计算任务，这在十年前的先进台式电脑上也是不可能的。如今智能手机的硬件比十年前的台式机更先进。因此，增加更多的资源来解决复杂问题永远不是一个解决方案，必须以最佳方式利用资源以减少费用。因此，性能管理是每个软件系统所必需的。","category":"page"},{"location":"ch12performance/#算法选择","page":"性能","title":"算法选择","text":"","category":"section"},{"location":"ch12performance/","page":"性能","title":"性能","text":"计算机科学家通常把最大的精力放在完善问题的算法上。为一个问题精心选择的算法和对一个不合适的算法进行大量的调整所得到的效果是不可同日而语的。当你的代码不能正确执行时，最好看看核心设计，了解它是否有正确的算法。在设计阶段保持对性能的关注可以减少大量的返工成本。例如，二分搜索的复杂度为O(log n)，而数组搜索的复杂度为线性时间或O(n)。直觉上，二分搜索似乎总是优于线性搜索。但是，随着现代处理器缓存和数组内存管理效率的提升，使用线性搜索较小的数组可能是高效的。而二叉树是基于磁盘存储的数据库索引的选择，二叉树也可能是内存数据库数据结构的选择。数据结构的选择需要考虑完整的系统性能，而不仅仅是理论渐进时间复杂度或最坏情况下的性能。","category":"page"},{"location":"ch12performance/#优化策略","page":"性能","title":"优化策略","text":"","category":"section"},{"location":"ch12performance/","page":"性能","title":"性能","text":"对整个代码库进行绝对的性能优化对任何人都没有帮助。过度优化的代码很难理解，最终可能只适合特定的平台。Julia建议编写可读的代码，并使用适当的算法，将代码生成和底层特定于目标的优化留给JIT编译器和LLVM工具集。它提供了一些工具，可以帮助分析代码并找到性能瓶颈所在。从程序员的角度来看，比起特定于平台的修复，编写通用的高级代码以保持跨平台的性能总是更受欢迎。如果优化在代码库中是必不可少的，那么最好将其本地化为一小组函数。","category":"page"},{"location":"ch12performance/#Julia和竞争者","page":"性能","title":"Julia和竞争者","text":"","category":"section"},{"location":"ch12performance/","page":"性能","title":"性能","text":"大多数开始优化代码的人都在努力寻找他们的目标性能。他们能达到既定目标吗？这实际上是将你的结果与行业基准进行比较。Julia占据了评测的极端位置，即最接近C编译代码的性能。C编译代码是一个纯粹的可执行文件。C的运行环境非常轻量，因为许多操作系统是使用C语言编写的，所以它是预加载的。Julia则没有这种相较于基于C的操作系统。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"Julia运行环境需要在程序第一次执行时加载，并在执行完成时退出。其次，Julia是一种即时编译语言。偶尔执行的Julia代码在调用之前可能没有被编译为本机二进制文件。在调用代码时，部分时间可能要花在将代码编译为本机格式上。为了使这两个系统处于可比较的状态，Julia的支持者建议在稳态条件下测量性能。当所有Julia代码至少运行一次，并且即时编译器将它们编译为本机二进制文件时，就达到了稳定状态。而该语言的批评者则不认同这种基准测试，因为他们认为加载时间没有被视为测试的一部分。Julia社区发布了一些竞争平台少量算法的一套微测试：","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"(Image: Julia Benchmark)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"从许多任务中可以看出，Julia的性能优于竞争对手，并且与本地C语言的性能相当接近。性能优化对于任何编程语言都是一个相当复杂的话题。我们不能对性能优化的每个方面都介绍到。我们只介绍一些可以帮助我们编写优化代码的工具和指南。","category":"page"},{"location":"ch12performance/#基准测试","page":"性能","title":"基准测试","text":"","category":"section"},{"location":"ch12performance/","page":"性能","title":"性能","text":"基准测试是将预期的性能与一个众所周知的目标进行比较。BenchmarkTool.jl包可以帮助开发人员度量执行Julia代码所花费的时间和分配的内存。让我们对基于查表方案的正弦函数j计算的性能进行基准测试，看看性能是否真的有所提升。我们将使用Julia BenchmarkTools.jl库提供的工具度量时间周期和内存分配。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"sin(x)函数的变量x是以弧度为单位的。我们可以建立一个函数sindeg(x)其中x的单位是度数。我们将评估应该使用Julia Base中的sin(x)函数还是我们讨论过的查找表方案近似的函数。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"using BenchmarkTools;\ndeg2rad(x) = pi/180.0*x\nsindeg = sin ∘ deg2rad\n@btime sindeg(52.0)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"@benchmark将运行代码多次；通过多次采样合计性能，并报告结果的统计信息。最小时间是一个更好的估计，因为它代表最少的系统开销或噪声。@time报告函数单次调用的分配和花费的最小时间，@btime则采用多次运行函数。我们将在大多数示例中使用@btime。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"struct MemoLookup\n    n\n    lookup\n    function MemoLookup(n)\n        step = 90/n\n        δ = pi/180*step\n        lookup = [[sin(i*δ) for i in 0:n] [cos(i*δ) for i in 0:n]]\n        new(n, lookup)\n    end\nend\nstep(m::MemoLookup) = 90/m.n\nm = MemoLookup(6)\nfunction sindegmemo(m::MemoLookup, x)\n    s, lookup = step(m), m.lookup\n    i = 1\n    while x >= s\n        x -= s\n        i += 1\n    end\n    iszero(x) && return lookup[i, 1]\n    x = deg2rad(x)\n    sinx, cosx = x, 1 - x*x/2\n    return lookup[i, 1]*cosx + lookup[i, 2]*sinx\nend\n@btime sindegmemo($m, 52.0)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"代码比之前计算的要慢。计算需要14个分配和224个字节的额外内存。如何解释这些分配呢？小而频繁的内存块分配可能会带来显著的性能开销。","category":"page"},{"location":"ch12performance/#代码生成工具","page":"性能","title":"代码生成工具","text":"","category":"section"},{"location":"ch12performance/","page":"性能","title":"性能","text":"这些调试工具可以在代码生成的不同阶段对代码进行分析。这些工具被命名为@code_XXX，其中xxx代表特定的阶段。Julia的代码翻译是分阶段进行的。代码被转换为抽象结构树，然后转换为LLVM代码，最后转换为本机输出。不同的宏帮助我们了解这个代码生成过程的各个阶段。Julia在内部并不使用它们来生成实际的代码。","category":"page"},{"location":"ch12performance/#类型稳定","page":"性能","title":"类型稳定","text":"","category":"section"},{"location":"ch12performance/","page":"性能","title":"性能","text":"在讨论函数及其返回值时，我们已经看到了一些类型稳定性的例子。我们知道，非确定性类型会导致低效的代码。让我们看一下上节提供的代码是否具有无法明确推断的类型。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"using InteractiveUtils\n@code_warntype sindegmemo(m, 52.0)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"@code_warntype将Julia代码转换为一个AST。AST在每一步都返回类型推断。非确定性类型在终端或Jupyter控制台中用颜色突出显示。有许多变量被赋给Any类型。这本质上意味着在任何计算过程中都将分配内存位置和间接指向实际的Float64值。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"我们将引入一个新的Memolooup，它为n和lookup等属性正确定义了类型。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"using InteractiveUtils\nstruct MemoLookup\n    n::Int\n    lookup::Matrix{Float64}\n    function MemoLookup(n)\n        step = 90/n\n        δ = pi/180*step\n        lookup = [[sin(i*δ) for i in 0:n] [cos(i*δ) for i in 0:n]]\n        new(n, lookup)\n    end\nend\nstep(m::MemoLookup) = 90/m.n\nm = MemoLookup(6)\nfunction sindegmemo(m::MemoLookup, x)\n    s, lookup = step(m), m.lookup\n    i = 1\n    while x >= s\n        x -= s\n        i += 1\n    end\n    iszero(x) && return lookup[i, 1]\n    x = deg2rad(x)\n    sinx, cosx = x, 1 - x*x/2\n    return lookup[i, 1]*cosx + lookup[i, 2]*sinx\nend\n@code_warntype sindegmemo(m, 52.0)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"没有变量被指定为Any类型。让我们看看这是否能提高性能。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"using BenchmarkTools\n@btime sindegmemo($m, 52.0)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"性能有显著提高：从276ns提高到4ns。但是，如果你还记得我们写的sindeg(x)函数的执行时间是18ns。sindeg(x)的构造正确吗？","category":"page"},{"location":"ch12performance/#非必要的分配","page":"性能","title":"非必要的分配","text":"","category":"section"},{"location":"ch12performance/","page":"性能","title":"性能","text":"一个方法是查看函数调用的@code_warntype转储。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"@code_warntype sindeg(52.0)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"虽然就类型推断而言，代码中没有问题(没有Any类型)，但x被赋值为一个Tuple{Float64}。这本质上意味着将创建一个新变量，并将函数输入赋值给这个新创建的元组。如果我们重新定义sindeg函数为：","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"sindeg1(x) = sin(deg2rad(x))\n@btime sindeg1(52.0)\n@btime sind(52.0)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"这与Julia函数sind(x)的性能已经一致。","category":"page"},{"location":"ch12performance/#参数数据类型","page":"性能","title":"参数数据类型","text":"","category":"section"},{"location":"ch12performance/","page":"性能","title":"性能","text":"参数数据类型可以提高性能，因为它们是在代码编译期间而不是在运行时解析的。挑战在于如何识别这些属性。例如，在MemoLookup类型中，表示表大小的属性n是一个常量，没有很多地参与到查找表的构造中。因此，它是作为类型参数的一个理想候选者。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"struct MemoLookupP{N}\n    lookup::Matrix{Float64}\n    function MemoLookupP{N}() where N\n        δ = pi/2N\n        lookup = [[sin(i*δ) for i in 0:N] [cos(i*δ) for i in 0:N]]\n        new{N}(lookup)\n    end\nend\nstep(m::MemoLookupP{N}) where N = 90.0/N\nconst m = MemoLookupP{6}()","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"我们定义了另一个singindegmemo函数，它接受MemoLookupP作为输入。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"using BenchmarkTools\nfunction sindegmemo(m::MemoLookupP, x::Float64)\n    s, lookup = step(m), m.lookup\n    i = 1\n    while x >= s\n        x -= s\n        i += 1\n    end\n    x, sini = deg2rad(x), lookup[i, 1]\n    iszero(x) && return sini\n    sinx, cosx, cosi = x, 1 - x*x/2, lookup[i, 2]\n    return sini*cosx + cosi*sinx\nend\n@btime sindegmemo(m, 52.0)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"从4ns到1.73ns是一个进步，但是我们能做得更好，让我们看一下生成的LLVM位码。","category":"page"},{"location":"ch12performance/#删除非必要代码","page":"性能","title":"删除非必要代码","text":"","category":"section"},{"location":"ch12performance/","page":"性能","title":"性能","text":"由LLVM生成的位码非常具有描述性并需要对代码助记符有很好的理解。但是，我们将只确定一些明显的问题，而不进行详细的分析：","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"using InteractiveUtils\n@code_llvm sindegmemo(m, 52.0)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"每当使用getindex方法访问数组时，都会检查边界。当数组在范围内时执行ib标签，当索引超出边界时执行oob标签。如果我们可以确定索引在边界内，则边界外的部分可以被消除。你可以使用宏@inbounds来确保不会生成边界检查代码。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"function sindegmemoib(m::MemoLookupP, x)\n    s, lookup = step(m), m.lookup\n    i = 1\n    while x >= s\n        x -= s\n        i += 1\n    end\n    x, sini = deg2rad(x), @inbounds lookup[i, 1]\n    iszero(x) && return sini\n    sinx, cosx, cosi = x, 1 - x*x/2, @inbounds lookup[i, 2]\n    return sini*cosx + cosi*sinx\nend\n@btime sindegmemoib($m, 60.0)\n@btime sindegmemoib($m, 22.0)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"我们已经进一步接近sind(x)的性能，但还不够。一个明显的问题是，为什么sindegmemoib在输入为60°时比输入为22°时性能更好？","category":"page"},{"location":"ch12performance/#分析","page":"性能","title":"分析","text":"","category":"section"},{"location":"ch12performance/","page":"性能","title":"性能","text":"在我们分析过的示例中，我们知道某个特定函数有一个我们希望克服的性能瓶颈。在许多大型应用中，不太容易获取这样的信息。例如，一个文字处理器打开文件和在屏幕上呈现内容的速度很慢。可能有很多因素。读取文件可能会很慢，文档中的某些功能计算起来很复杂，或者文件太大，读取所有数据和在内存中缓存数据可能会成为瓶颈。分析可以帮助你识别这些场景。在一个固定的时间间隔(比如每毫秒)，统计分析器将查看代码执行堆栈，并记录堆栈的状态，比如行号和查询期间执行的函数。一旦运行完成，它们将关联所有这些数据，并报告遇到某个特定函数的次数，以及为实现这个该函数而调用的所有函数的反向跟踪。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"Julia有一个内置的统计分析器。分析器位于Profile模块中。我们将使用这个工具来分析一个函数profile_test。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"using Profile\nfunction profile_test(n)\n    for i in 1:n\n        A = randn(100,100,20)\n        m = maximum(A)\n        Am = mapslices(sum, A; dims=2)\n        B = A[:,:,5]\n        Bsort = mapslices(sort, B; dims=1)\n        b = rand(100)\n        C = B .* b\n    end\nend\nprofile_test(1)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"代码运行一次，以便对其进行编译，而用于此类活动的时间不会被捕获为分析器采样的一部分。现在，我们运行该函数100次迭代，并对运行进行分析。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"@profile profile_test(100)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"数据是由分析器生成和缓存的，并且可以通过Profile.print()调用打印出来。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"Profile.print()","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"高亮显示的部分来自顶级函数profile_test。最大的时间花在第5行上，因为它占了总采样1792次的587次。你可以使用ProfileView包获得更好的输出视觉效果。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"using ProfileView\n@profview profile_test(100)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"(Image: Profview)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"我们体验了一些性能调优过程。在下一节中，我们将介绍一些编写高性能代码的指导原则。","category":"page"},{"location":"ch12performance/#高性能编程指南","page":"性能","title":"高性能编程指南","text":"","category":"section"},{"location":"ch12performance/#记忆","page":"性能","title":"记忆","text":"","category":"section"},{"location":"ch12performance/","page":"性能","title":"性能","text":"当一个纯函数被多次调用时，它将产生相同的输出。如果我们可以缓存这个值，它将不需要反复计算结果而减少计算开销，这个过程叫做记忆。一个最常见的例子是斐波那契数列。斐波那契级数最好用下面的代码来递归描述：","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"textfib(n) = n  3 quad  quad 1 quad  quad textfib(n-1) + textfib(n-2)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"每次调用都递归地调用函数两次。如果我们通过稍微修改函数来记录调用的次数，你可以看到函数调用的次数呈指数增长。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"using BenchmarkTools\nfunction fib(n)\n    if n < 3\n        return (result=1,calls=1)\n    else\n        r1, c1 = fib(n-2)\n        r2, c2 = fib(n-1)\n        return (result=r1+r2, calls=1+c1+c2)\n    end\nend\nfor i in 1:10\n    r, c = fib(i)\n    println(\"n: \", i, \"\\tresult: \",r, \"\\tcalls: \",c)\nend\n@btime fib(20)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"考虑到只涉及加法运算，这个函数仍然相当昂贵。fib(6) = fib(5) + fib(4)，我们已经在计算fib(5)时见过fib(4)。如果在计算时就缓存f(4)，我们就不必在计算f(5)和f(6)时再次计算它。我们可以重用前面计算的值。我们在下面的代码中使用了相同的概念：","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"const mem = Dict()\nfunction fib(n)\n    haskey(mem, n) && return mem[n]\n    println(\"Calling fib: \", n)\n    res = n < 3 ? 1 : fib(n-1) + fib(n-2)\n    mem[n] = res\nend\nfib(5)\n\n@btime fib(20)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"fib(5)仅被调用5次，fib(20)的运行时间仅为14ns；差不多是从字典里读出来再加上的时间。我们能否将这一概念推广到任何形式的记忆任务中？","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"function memoize(f)\n    memo = Dict()\n    (args...;kwargs...) -> begin\n        x = (args,kwargs)\n        haskey(memo, x) && return memo[x]\n        v = f(args...;kwargs...)\n        memo[x] = v\n        return v\n    end\nend","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"memoize(f)是一个高阶函数，它可以记住一个函数及其参数，以便于后续的值检索。memo字典被memoize返回的匿名函数作为闭包访问。使用memoize这样的函数，你可以定义如下fib(n)方法：","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"fib(n) = n < 3 ? 1 : fib(n-1) + fib(n-2)\nfib! = memoize(fib)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"Memoize.jl包有一个@memoize宏，它可以帮助指定函数支持记忆。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"using Memoize\n@memoize fib(n) = n < 3 ? 1 : fib(n-1) + fib(n-2)","category":"page"},{"location":"ch12performance/#全局变量","page":"性能","title":"全局变量","text":"","category":"section"},{"location":"ch12performance/","page":"性能","title":"性能","text":"这并不是真正的设计模式。我们希望你意识到使用全局变量的挑战。Julia全局变量没有指定的类型。它们可以根据被赋值的数据被赋予任何类型。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"GLOBAL_VAR = 3\nfunction add_to_global(x)\n    x + GLOBAL_VAR\nend\n@btime add_to_global(10)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"现在，让我们将全局变量传递给基本的加法运算符。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"@btime 10 + $GLOBAL_VAR","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"仅仅将全局变量包装到函数中就会有很大的开销，为什么会这样呢？让我们看看全局常数而不是变量。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"const GLOBAL_CONST = 20;\nadd_to_global_const(x) = x + GLOBAL_CONST\n@btime add_to_global_const(3)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"返回的值相当快，而且比全局变量好得多。让我们看看LLVM位码。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"using InteractiveUtils\n@code_llvm add_to_global_const(3)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"常数20直接被替换了。因此，没有类型歧义。加法操作在CPU的寄存器中进行，没有进行内存访问。全局变量有两个用途。它们分配一个特定的内存位置和一个内存位置句柄。但是，它们不是类型安全的。Ref{T}分配内存并且是类型安全的。通过将变量声明为const，可以确保内存位置也是固定的。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"const GLOBAL_REF = Ref(10)\nadd_to_global_ref(x) = x + GLOBAL_REF[]\n@btime add_to_global_ref(3)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"全局变量的性能有明显的提高，但它不如const或函数实参快。在检查LLVM位码时，你将看到，该代码本质上分为两部分。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"将值从特定内存位置加载到变量或寄存器或易失性内存位置。\n将该值加到另一个易失性内存位置。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"@code_llvm add_to_global_ref(3)","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"如果你不喜欢使用方括号([])访问Ref{T}语法，你也可以使用访问器模式。","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"let _x = Ref(5)\n    global X() = _x[]\n    global X(y) = (_x[] = y)\nend","category":"page"},{"location":"ch12performance/","page":"性能","title":"性能","text":"我们建议读者查看add_to_global_var的LLVM位码。由于没有全局变量的类型推断，该函数将不得不假设类型为Any，并在每次使用时解决类型冲突。","category":"page"}]
}
