var documenterSearchIndex = {"docs":
[{"location":"ch04function/#函数和方法","page":"函数和方法","title":"函数和方法","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"大多数代码都可以在类似shell的REPL接口中输入，如同正在编写脚本一样。但是，当你使用函数，向其传入或从中传出数据时，Julia的真正能力才体现出来。为了发挥多分派接口的强大功能，学习函数和方法成为Julia编程的基本需要。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"没有一个产品级应用是在单个文件中使用顺序语句开发出来的。大多数程序员喜欢将程序分割成小块的可执行单元。这解决了两个问题。首先，它创建了可重用单元，这些单元可以在更大的程序中的不同位置被多次调用。其次，小单元可以很容易地进行单元测试。因此，它们提高了代码的可靠性。我们将尝试以编程的方式解决国际象棋中的8皇后问题，并在此过程中理解Julia中的函数。","category":"page"},{"location":"ch04function/#皇后问题","page":"函数和方法","title":"8皇后问题","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"它是算法和人工智能领域的一个经典问题。目标是在满足不相互攻击的前提下，在棋盘上放置最大数量的皇后。下图给出了一种可能解。然而，这个解不是唯一的。我们将编写一个程序来解决8皇后问题。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"(Image: eight queens)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"在设计出问题的完整解决方案之前，我们必须有一个程序单元，作为输入信息，它接收两个皇后的位置，并输出皇后是否相互攻击。","category":"page"},{"location":"ch04function/#两个相互安全的皇后","page":"函数和方法","title":"两个相互安全的皇后","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"Julia中的这些小程序单元叫做函数。我们将创建一个函数，它接受两个皇后的输入位置，返回皇后的路径是否重叠则。以下是皇后互相攻击的条件。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"皇后有相同的x或y坐标：x₂ = x₁或y₂ = y₁。\n皇后彼此在对角线上，即：x₂ - x₁ = y₂ - y₁。","category":"page"},{"location":"ch03controlflows/#控制流","page":"控制流","title":"控制流","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"分支和循环等控制流是命令式编程风格的核心。作为一种多范式编程语言，Julia支持所有知名的命令式风格和结构。","category":"page"},{"location":"ch03controlflows/#复合语句","page":"控制流","title":"复合语句","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"语句是程序员给计算机下达的命令。如打印一段文字，或给一个变量赋初值。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"println(\"Hello, world!\")\na = 10.0","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"Julia每次只能执行一条语句。如果需要把多条语句作为一个大型的复合执行单元（如同一条语句）来看待，则可以使用begin和end块将任意语句集包围起来。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"z = begin\n    x = 1\n    y = 2\n    x + y\nend\nz","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"块中最后一个表达式的值作为复合块的值。同样的表达式可以在单行中写成使用大括号包围的由分号分隔的语句集。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"z = (x = 1; y = 2; x + y)","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"下面也是有效的复合语句。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"z = (x = 1;\n    y = 2;\n    x + y)\nz = begin x=1; y=2; x+y end","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"由上可见，要在单行中编写多条语序，需要使用;将每条语句分隔开来。另外，Julia是通过最小语义单元来判断输入的内容是否是单行的，而不是通过回车换行来判断。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"a =\n1","category":"page"},{"location":"ch03controlflows/#注释","page":"控制流","title":"注释","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"随着程序越来越长，越来越复杂，阅读起来也变得更加困难。因此，通过对程序增加笔记来说明它到底做了些什么是一个非常明智的方法。这些笔记被称为注释，它们以 # 号开头：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"# 计算已用时间的百分比（总时长是60分）\npercentage = (20 * 100) / 60","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"在这个例子中，注释独占一行。你也可以将注释放到一行的末尾：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"percentage = (20 * 100) / 60  # 已用时间的百分比","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"# 号以后的所有内容都被程序忽略掉——它对程序的执行不起任何作用。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"当我们写的注释需要连续占用很多行，这时在每行的开头都使用#会很麻烦。还有一种情况，我们可能需要在同一行的一条语句的中间插入注释，这时#会完全失效（因为#以后的内容被全部忽略），Julia提供的另一种注释方法#=...=#可以解决这类问题。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"#= 一行注释\n   另外一行注释\n=#\nv = 5   \nb = #=在中间插入注释=# 3.2","category":"page"},{"location":"ch03controlflows/#分支","page":"控制流","title":"分支","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"条件语句是编程语言的核心。它们提供了在代码中定义分支的途径，并且是迭代编程的基础。使用本地goto进行分支足以模拟编程语言中的任何迭代模型。","category":"page"},{"location":"ch03controlflows/#if...else","page":"控制流","title":"if...else","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"if...else是Julia中最常见的条件执行形式。一个典型的if条件如下所示:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"if <Boolean condition>\n    # do something\nelse\n    # do the something else\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"else部分是可选的。条件必须是布尔值。与布尔值true或false相同的整数不能代替对应的布尔值。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"if 1\n    println(\"Integer is good for Bool\")\nend\nif Bool(1)\n    println(\"Bool now\")\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"if表达式返回被执行分支的值。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"i = 1\nstr = if i > 1\n    \"Greater\"\nelse\n    \"Less\"\nend\nstr","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"同样的表达式也可以用三元运算符?和:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"str = i > 1 ? \"Greater\" : \"Less\"\nstr","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"虽然在大多数表达式中可以不使用空格，但在?和:两侧的空格则是必须的。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"julia> str = i > 1? \"Greater\" : \"Less\"\nERROR: syntax: space required before \"?\" operator\n\njulia> str = i > 1 ? \"Greater\": \"Less\"\nERROR: syntax: space required before colon in \"?\" expression","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"当遇到多重分支操作时，可使用if...elseif...else结构。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"val = 3\nif val == 1\n    \"one\"\nelseif val == 2\n    \"two\"\nelseif val == 3\n    \"three\"\nelseif val == 4\n    \"four\"\nelse\n    \"unknown\"\nend","category":"page"},{"location":"ch03controlflows/#非结构分支","page":"控制流","title":"非结构分支","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"诸如if...elseif...else的结构分支，是编程语言中条件执行的最优选择。然而，一些语言具有goto语句来将执行分支跳转到代码中的特定位置。Julia也使用宏@goto和@label提供了这样的功能。它们有以下限制:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"它们被限制在特定的代码块中。@goto可以在同一代码块中使用@label。\n它们不能跨函数使用。\n它们会影响代码的可读性。因此，通常在大多数结构化编程语言中不使用。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"Julia具有结构化分支和迭代，因此完全可以不使用非结构化分支。下面的代码仅是使用@goto和@label来对从1到10的连续数进行求和的示例:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"begin\n    s = 0\n    n = 10\n    @label loop\n    s = s + n\n    n = n - 1\n    if n > 0\n        @goto loop\n    end\n    s\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"显然，对于序列求和，迭代要比非结构化分支简单得多。","category":"page"},{"location":"ch03controlflows/#迭代","page":"控制流","title":"迭代","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"虽然我们可以使用非结构化分支goto实现代码的迭代执行，但作为一种高级语言，Julia提供了迭代执行的特定语言结构。最常见的是for和while。","category":"page"},{"location":"ch03controlflows/#for","page":"控制流","title":"for","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"s = 0;\nfor i = 1:10\n    s = s + i\nend\ns","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"在上面的代码片段中，我们从1枚举到10，并将值累加到s。在for循环中，我们将一个步长为1的范围对象1:10赋给参数i。该对象也可以写成1:1:10，表示<初始值>:<步长>:<最终值>。现在，我们修改代码，使其只对奇数进行累加。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"s = 0;\nfor i = 1:2:10\n    println(i)\n    s = s + i\nend\ns","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"可以看出，将范围对象的步长更改为2就可以达到预期的结果。","category":"page"},{"location":"ch03controlflows/#continue和break","page":"控制流","title":"continue和break","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"让我们在求和时忽略所有能被3整除的数。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"s = 0;\nfor i = 1:10\n    if i % 3 == 0\n        continue\n    end\n    println(i)\n    s = s + i\nend\ns","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"在这种情况下，continue用于跳过所有能被3整除的数。continue确保在迭代器仍处于活动状态时，表达式后面的代码块被排除在计算之外，而在代码中使用break将终止循环。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"s = 0;\nfor i = 1:10\n    if i % 3 == 0\n        break\n    end\n    println(i)\n    s = s + i\nend\ns","category":"page"},{"location":"ch03controlflows/#for...in","page":"控制流","title":"for...in","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"除了范围对象，for也可以与其他具有迭代器功能的序列对象一起使用。我们将在后面详细讨论迭代器接口。下面是一个for...in语法的代码片段。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"for i in [5,10,15]\n    println(i)\nend","category":"page"},{"location":"ch03controlflows/#多范围对象","page":"控制流","title":"多范围对象","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"一个for循环可以遍历多个范围对象。效果是在由左侧指定外层循环的范围的笛卡尔积上迭代。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"for i=1:3, j=1:2\n    println((i,j))\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"内部范围也可以受外部范围值的影响。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"for i=1:3, j=1:i\n    println((i, j))\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"这里的for循环是一个单独的循环，break语句可以完全终止它，这与嵌套的for循环只终止内部循环不同。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"for i=1:3, j=1:2\n    println((i, j))\n    if i == j\n        break\n    end\nend\nfor i=1:3\n    for j=1:2\n        println((i, j))\n        if i == j\n            break\n        end\n    end\nend","category":"page"},{"location":"ch03controlflows/#while","page":"控制流","title":"while","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"在Julia中，for用于迭代器和范围对象。while则更灵活，可以在任何条件下发挥作用。只要条件为真，循环就会继续执行。下面是一般语法。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"while <Boolean_condition is true>\n    <loop>\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"现在，如果我们考虑相同的1-10的加法例子，那么代码将如下所示:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"s, n = 0, 10;\nwhile n > 0\n    s = s + n\n    n = n - 1\nend\ns","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"与for循环类似，可以分别通过continue和break来跳过或终止执行。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"while循环重复计算起始处的条件，如果结果为true，则执行循环。在某些情况下，存在不管条件如何，都需要至少执行一次的循环，并在循环结束时计算新的条件来判断是否继续执行循环。这相当于其他语言中的do...while循环。Julia目前没有这个构造。但实现这个语义逻辑却很简单。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"julia> println(\"press q <enter> to end loop\")\npress q <enter> to end loop\n\njulia> while true\n           ch = readline()\n           ch == \"q\" && break\n       end\na\nq","category":"page"},{"location":"ch03controlflows/#异常处理","page":"控制流","title":"异常处理","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"当程序出现异常时，执行的函数可能无法返回一个有效值或使程序处于可恢复状态。有些程序可能会报告错误并终止执行。然而，在报告异常情况的同时，使程序恢复状态是非常有益的。其次，恢复的状态一定在函数调用的多个深度的调用堆栈中。因此，异常可能导致控制流移动到调用堆栈中的另一个函数，而不仅仅是调用方的地址空间。","category":"page"},{"location":"ch03controlflows/#try...catch","page":"控制流","title":"try...catch","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"将预期具有异常条件的代码放置在try之后。异常处理代码添加到catch之后的部分。end表达式结束try块。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"try\n    sqrt(-1)\ncatch e\n    println(e)\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"没有try...catch块的代码将在REPL中报告以下内容:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"sqrt(-1)","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"可以看到，REPL提供了默认的try...catch实现，它接受DomainError异常并打印一个带有堆栈跟踪的错误。Julia有相当多的标准异常，如ErrorException、DomainError、ArgumentError、BoundsError等。所有错误都派生自抽象类型Exception。","category":"page"},{"location":"ch03controlflows/#throw/rethrow","page":"控制流","title":"throw/rethrow","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"虽然catch提供了捕获异常并对异常采取操作的选项，但人们可以利用rethrow函数使异常进一步传播，而不是处理它。打印的错误信息是REPL默认的错误处理方法。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"try\n    sqrt(-1)\ncatch e\n    rethrow()\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"当出现一些意外的条件时，还可以抛出自定义异常。抛出的对象不一定总是Exception类型。它可以是任何对象。下面给出了一个抛出整数的例子:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"try\n    throw(1)\ncatch e\n    println((e,typeof(e)))\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"异常用于管理异常条件。如果行为只是代码流中的常规条件的表示，应使用其他控制流如if...else。其次，异常会增加大量的执行开销。因此，只有在需要时才有选择地使用它们。","category":"page"},{"location":"ch03controlflows/#finally","page":"控制流","title":"finally","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"当资源正在使用时，异常情况可能会迫使函数突然退出执行，这种情况下的资源无法回收。finally子句代码在正常和异常条件下都会被执行，确保资源被回收。在下面的示例中，即使出现异常，文件句柄f也会关闭。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"f = open(\"/etc/hosts\")\nisopen(f)\ntry\n    b = write(f,\"abc\")\ncatch e\n    println(e)\nfinally\n    close(f)\nend\nisopen(f)","category":"page"},{"location":"ch03controlflows/#异常的信息","page":"控制流","title":"异常的信息","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"因为每次堆栈展开时都需要验证异常对象，因此它们会影响执行速度。那么，如此复杂架构的异常对象为程序添加了什么价值？它们提供的主要优势之一是能够跟踪异常发生的堆栈。因此，可以得到错误的传播轨迹。其次，异常对象的形式提供了关于了解错误足够信息的能力。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"julia> sqrt(-1)\nERROR: DomainError with -1.0:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n [1] sqrt\n   @ ./math.jl:582 [inlined]\n [2] sqrt(x::Int64)\n   @ Base.Math ./math.jl:608\n [3] top-level scope\n   @ REPL[73]:1","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"DomainError有两个属性。val属性表示导致错误的值，msg属性详细描述消息细节。你可以通过创建Exception抽象类型的子类型来定义自己的异常。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"struct MyException <: Exception\n    params1\n    params2\n    # ...\n    paramsn\nend","category":"page"},{"location":"ch03controlflows/#堆栈跟踪","page":"控制流","title":"堆栈跟踪","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"堆栈跟踪是从异常处理中获得的一组非常重要的信息。函数catch_backtrace()在抛出异常时报告堆栈跟踪，而stacktrace()函数提供了对前面函数返回结果的解释。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"julia> try\n           sqrt(-1)\n       catch e\n           stacktrace(catch_backtrace())\n       end\n3-element Vector{Base.StackTraces.StackFrame}:\n sqrt at math.jl:582 [inlined]\n sqrt(x::Int64) at math.jl:608\n top-level scope at REPL[76]:2","category":"page"},{"location":"ch02dadatypes/#数据类型","page":"数据类型","title":"数据类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"类型是Julia语言的核心。尽管在语法上不需要显式地定义数据的类型，但Julia在编译过程中会对类型进行推断。Julia语言有预定义的类型。用户也可以定义自己的类型。有些类型可以通过参数进行修改。","category":"page"},{"location":"ch02dadatypes/#数据种类","page":"数据类型","title":"数据种类","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"通常，动态类型编程语言没有开发良好的类型系统，如Python中的数据类型就是非强制的。Julia类型系统是动态的，但总是在对象实例化时进行推断。这样，Julia在执行代码段或对代码进行即时(JIT)编译之前，数据类型就是已知的了。简而言之，Julia原生支持在使用前定义或推断任意对象或字面量的数据类型。在深入介绍数据类型之前，让我们先了解一下Julia对数据的分类：变量、常量和字面量的知识。","category":"page"},{"location":"ch02dadatypes/#变量","page":"数据类型","title":"变量","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia中的变量将名称与值关联起来。名称通常以字母开头的字母数字表示。下面给出了一些在Julia中变量名的例子。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"abc = 1\nπi = 30\na1 = 1\n1abc = 2\nsin = 1.0\ncos(0.0)\ncos = 0.0","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"从上面的结果可以看出，变量名可以包含Unicode字符；可以包含数字，但不能以数字开头；以函数名做为变量名时要特别慎重。变量名的另外一个限制是不能使用特殊字符和Julia的关键字，如下面的例程所示。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"julia> a@ = 1\nERROR: syntax: extra token \"@\" after end of expression\n\njulia> struct = 10\nERROR: syntax: unexpected \"=\"","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia的关键字很少。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"baremodule  begin   break       catch   const   continue\ndo          else    elseif      end     export  false \nfinally     for     function    global  if      import \nlet         local   macro       module  quote   return\nstruct      true    try         using   while ","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia还具有两字关键字(mutable struct、abstract type等)和中缀操作符(in、isa等)关键字。","category":"page"},{"location":"ch02dadatypes/#定义与初始化","page":"数据类型","title":"定义与初始化","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"大部分静态语言，如C，变量的定义和初始化是独立的。定义声明变量的类型，其底层操作是向内存申请一块相应类型的地址空间并命名（变量名）。初始化则在地址空间中存入规定类型的具体值。变量和值的关系是：变量是主体，值是变量的附属。如下面C代码片段所示。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"int i;  /* 将i定义为整数类型 */\ni = 10; /* 初始化i */\nint j = 20; /* 在一条语句中定义并初始化变量 */","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia则将变量和值的关系翻转过来：值是主体，变量是值的附属。大多数Julia变量是在对类型进行初始化时定义的。事实上，类型是作为初始化过程的一部分赋给变量的。也可以显式地声明变量将要绑定的值的类型，Julia会尝试将值转换成相应的类型，不成功则会报错。对于REPL中的全局变量，不允许声明变量的类型。例程如下所示。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a = 1\ntypeof(a)\na = 1.0\ntypeof(a)\nlet a::Int = 1.0\n    println(typeof(a))\nend\nlet a::Int = 1.1\n    println(typeof(a))\nend\na::Int = 1","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"从上面的介绍可以判断，Julia中的一般变量是没有固定地址的，事实也是如此。Julia甚至没有为我们开放变量地址的查询功能（后面会介绍可查询地址的变量类型），这一切都交给了底层程序自动处理。在Julia中，没有初始化的变量是无效的（后面会介绍例外的情况）:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"i","category":"page"},{"location":"ch02dadatypes/#常量","page":"数据类型","title":"常量","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"常量可以看作是不能修改的变量。然而，Julia并没有严格地遵循常量不变的条件。在类型不变的情况下修改常量的值，它会发出警告，但改变常量类型的情况是不允许的。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"const ICONSTANT = 1\nICONSTANT = 5\nICONSTANT = 5.0","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在使用中，尽管常量的值是可以修改的，但我们应该严格遵守常量不变的特性，以避免程序在执行中产生不可预见的错误。","category":"page"},{"location":"ch02dadatypes/#字面量","page":"数据类型","title":"字面量","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"字面量是表示一个值的常表达式。因为它们出现在变量定义的右边，因此常被称为右首值。它们也是一个值的本质表示形式。下面是一些不同类型的字面表达式。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"2           # Integer\n2.0         # Double precision Float (Float64)\n2f0         # Single precision Float (Float32)\n'a'         # Char\n\"string\"    # String","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"当我们深入研究类型时，我们将根据特定类型的上下文含义更详细地回顾字面量。通常，变量初始化为var = <literals>。","category":"page"},{"location":"ch02dadatypes/#内置数据类型","page":"数据类型","title":"内置数据类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia语言自身定义了许多内置类型。而更多的类型则是在Julia库中定义的。Julia语言提供了扩展这些功能的灵活性。此外，定义的类型不作为保留的关键字存在。下面是该语言中一些常用的类型。","category":"page"},{"location":"ch02dadatypes/#Nothing","page":"数据类型","title":"Nothing","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Nothing是值nothing的类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(nothing)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof函数可用于查询值所属类型的信息。当代码中确实需要未初始化的变量条件时，可以使用nothing来初始化这个变量。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a = nothing\ni = 6\nif i < 5\n    a = 5\nend\ntypeof(a)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"这里，如果i小于5 a就被赋值为5。否则，它仍保持未初始化。Nothing和nothing在函数参数和返回类型中也被广泛使用。","category":"page"},{"location":"ch02dadatypes/#数值类型","page":"数据类型","title":"数值类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"下面是在Julia中定义为数值数据类型的一些数据类型。","category":"page"},{"location":"ch02dadatypes/#Bool","page":"数据类型","title":"Bool","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"true和false在Julia中属于Bool类型。数值上，true的值为1,false的值为0。","category":"page"},{"location":"ch02dadatypes/#整数","page":"数据类型","title":"整数","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"整型数字类型分为具有不同字节大小的无符号和有符号类型。有符号数字类型有:Int8、Int16、Int32、Int64和Int128。对应的无符号数字类型分别为:UInt8、UInt16、UInt32、UInt64和UInt128。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(1)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"数字字面量的默认数值类型是Int，根据机器的体系结构，它映射到Int32或Int64。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"对于无符号数字，字面量由0<表示说明符><数字>指定。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(0b1), typeof(0o7), typeof(0xff)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"这些由二进制、八进制和十六进制表示的数字都被映射到UInt8。数字的尺寸由满足字面量所需的最小字节大小决定。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(0xf), typeof(0xfff),typeof(0xfffff), typeof(0xfffffffff), typeof(0xfffffffffffffffff)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"无符号整数的前面也是可以加+/-号的，但加-号的含义不是得到一个负的整数，而是得到该整数的二进制补码（后续将介绍相关知识）。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"-0x2\nInt(ans)","category":"page"},{"location":"ch02dadatypes/#浮点数","page":"数据类型","title":"浮点数","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"根据IEEE 754规范，Julia使用Float16、Float32和Float64来表示半精度、单精度和双精度浮点数。使用字面量f和e作为Float32和Float64的指数分隔符。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(1.0), typeof(1e0),typeof(1.e4)\ntypeof(1.0f0), typeof(1f-6), typeof(1.f4)","category":"page"},{"location":"ch02dadatypes/#抽象类型","page":"数据类型","title":"抽象类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia中的类型可以从抽象类型派生出来。大多数面向对象语言将这种关系视为在类层次结构中描述对象的一种方法。在Julia中，抽象类型仅仅是像接口一样的概念性表示，内部没有数据元素。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"abstract type MyAbstractType end\nstruct MyConcreteType <: MyAbstractType\n    member\nend\na = MyConcreteType(5)\na isa MyAbstractType","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"虽然我们将在后面详细讨论这个概念，但类型只能从一个抽象类型派生出来。中缀运算符isa用于判断特定对象是否属于特定类型。这里类型可以是具体类型也可以是抽象类型。下面是Julia中数字类型的类型层次结构。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: numerictypes)","category":"page"},{"location":"ch02dadatypes/#基本类型","page":"数据类型","title":"基本类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"基本类型是使用固定字节数表示数据的一种具体类型。基本类型的经典例子是整数和浮点数。与大多数语言不同，除了一组固定的内置类型外，Julia允许声明自己的基本类型。实际上，Julia的基本类型都是在语言本身中定义的:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"primitive type Float16 <: AbstractFloat 16 end\nprimitive type Float32 <: AbstractFloat 32 end\nprimitive type Float64 <: AbstractFloat 64 end\n\nprimitive type Bool <: Integer 8 end\nprimitive type Char <: AbstractChar 32 end\n\nprimitive type Int8    <: Signed   8 end\nprimitive type UInt8   <: Unsigned 8 end\nprimitive type Int16   <: Signed   16 end\nprimitive type UInt16  <: Unsigned 16 end\nprimitive type Int32   <: Signed   32 end\nprimitive type UInt32  <: Unsigned 32 end\nprimitive type Int64   <: Signed   64 end\nprimitive type UInt64  <: Unsigned 64 end\nprimitive type Int128  <: Signed   128 end\nprimitive type UInt128 <: Unsigned 128 end","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"声明基本类型的一般语法是:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"primitive type «name» «bits» end\nprimitive type «name» <: «supertype» «bits» end","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"虽然用户可以定义自己的基本类型，但建议只有在现有的基本类型不能满足要求时再定义新的基本类型。相同位值的基本类型本质上是不可互换的，也不能无缝转换。类型层次结构在这类类型的行为中扮演着重要的角色。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"UInt32(3f-1)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"尽管它们都是32位实体，但单精度浮点数不能在每种情况下都表示为无符号整数。不能创建任意大小位的基本类型，目前仅支持8位倍数的位大小。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"primitive type MyType1 40 end\nprimitive type MyType2 4 end","category":"page"},{"location":"ch02dadatypes/#位类型","page":"数据类型","title":"位类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia可以在二进制接口层面上与编译完成的语言，如C/C++、FORTRAN等进行无缝地交互，得益于Julia中定义的某些数据类型同这些本地编译语言所使用的类型在二进制布局中是一致的。这种类型被称为位类型。Julia中的基本类型都是位类型的数据类型。某些复合数据类型也是位类型。我们将在遇到他们时进一步讨论。位类型可以通过在实例上调用isbits函数或在类型上调用isbitstype函数进行查询。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a = 10\nisbits(a)\nisbitstype(Int)","category":"page"},{"location":"ch02dadatypes/#有理数和复数","page":"数据类型","title":"有理数和复数","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"虽然有理数和复数是数字类型，但它们不是基本类型。它们是使用复合数据类型创建的，我们将把复合数据类型作为用户定义类型的一部分来介绍。","category":"page"},{"location":"ch02dadatypes/#字符","page":"数据类型","title":"字符","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Char是由32位值表示的字符。它是Unicode字符的一个有效UCS-4表示。我们将在String一章详细讨论Char及其与String的关系。AbstractChar抽象类型可方便用户开发自己的类Char数据类型。","category":"page"},{"location":"ch02dadatypes/#字符串","page":"数据类型","title":"字符串","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"字符串是字符的集合。虽然大多数字符串是由Unicode字符编码组成的，但它们也可以存储其他类型的二进制数据。AbstractString抽象类型方便用户定义自己的字符串类型。","category":"page"},{"location":"ch02dadatypes/#用户定义类型","page":"数据类型","title":"用户定义类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"虽然Julia提供了相当多的内置类型，但仍需要将各种属性组合在一起的数据类型。","category":"page"},{"location":"ch02dadatypes/#结构","page":"数据类型","title":"结构","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia用struct表示一旦被初始化，其内部属性就不能被修改的自定义复合类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"struct Rectangle\n    h::Float64\n    w::Float64\nend\nr = Rectangle(10.0, 20.0)\nr.h = 15","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Rectangle是一个struct，初始化值为10.0和20.0。属性值不能被修改。函数Rectangle(10.0, 20.0)用来执行初始化。它是一个特殊的函数。当我们讨论函数和方法时，将进行深入介绍。","category":"page"},{"location":"ch02dadatypes/#可变结构","page":"数据类型","title":"可变结构","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"假设我们需要Rectangle是可修改的，则可以创建一个可变结构，如下所示:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"mutable struct MRectangle\n    h::Float64\n    w::Float64\nend\nmr = MRectangle(10.0, 20.0)\nmr.h = 15.0\nmr","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"可以看到，属性值在实例化对象之后是可以被修改的。Julia中的复合数据类型也可以从抽象类型派生出来。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"abstract type Shape end\nstruct Rectangle <: Shape\n    w::Float64\n    h::Float64\nend\nstruct Square <: Shape\n    l::Float64\nend","category":"page"},{"location":"ch02dadatypes/#成员","page":"数据类型","title":"成员","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia中的复合类型具有成员属性，但没有成员函数或方法。Julia的多分派体系结构使函数的行为类似于特定类型的方法，但它们与面向对象语言中的方法不同。有一类特殊的函数，它可以是类型的成员。这些函数被称为构造函数。我们将在讨论函数时详细讨论构造函数。成员的类型信息并不总是在复合类型中被指定。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"mutable struct A\n    member\nend\na = A(5)\ntypeof(a.member)\na1 = A(\"string\")\ntypeof(a1.member)","category":"page"},{"location":"ch02dadatypes/#Any","page":"数据类型","title":"Any","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"虽然在前面的例子中，模糊性问题在对对象进行实例化时得到了解决，但我们永远不能确定动态成员属性未来将被赋予哪种数据类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a.member = \"julia\"\ntypeof(a.member)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a.member之前的类型是Int64，现在是String。Julia假定这种未指明的类型为Any。在不能确定类型的情况下，Julia将假定类型为Any。从性能的角度来看，使用Any是不可取的。每次访问Any类型的对象时，它都会重定向到另一个实际的对象。我们不可能事先知道Any对象的大小。实际上，它是一个指向内存中实际对象所在的另一个位置的指针:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: anytype)","category":"page"},{"location":"ch02dadatypes/#参数数据类型","page":"数据类型","title":"参数数据类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Any作为类型会引入不必要的跳转，因此效率很低。有时，类型不一定会影响算法，但会引入不同的数据位大小。例如，前面介绍的Rational数据类型，分子和分母可以是任何整数类型，如Int8、Int16、Int32、Int64或Int128。Rational数据类型的定义如下:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"struct Rational{T<:Integer} <: Real\n    num::T\n    den::T\nend","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"两个属性num和den的类型为T，其中T是Integer的子类型。Rational是Real的一个子类型。以下是参数数据类型的一些特性。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Rational{Any}\nRational{Int32} <: Rational\nRational{Int32} <: Rational{Integer}","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"理解这种行为尤其重要。尽管Int32是Integer的子类型，但参数表示Rational{Int32}不是Rational{Integer}的子类型。然而，Rational{Int32}是Rational的子类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a = Rational{Int32}(1,UInt32(2))\ntypeof(a.num), typeof(a.den)\nb = Rational{Integer}(1,UInt32(2))\ntypeof(b.num), typeof(b.den)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"与具体数据类型一样，抽象数据类型也可以参数化。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"abstract type Shape{T<:AbstractFloat} end\nstruct Rectangle{T<:AbstractFloat} <: Shape{T}\n    w::T\n    h::T\nend\nstruct Square{T<:AbstractFloat} <: Shape{T}\n    s::T\nend","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"根据上面的方案，针对T可以开发不同的功能，如将T设为Float32或Float64，构建的Rectangle{Float32}类型与Rectangle{Float64}类型完全不同，它们是在编译过程中实例化具体类型时生成的。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"类型的参数化是Julia语言一个非常有用的特性，除此以外，也可以对整数值进行参数化。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"struct Point{T<:AbstractFloat,N}\n    x::Vector{T}\nend\nnum_coor(::Point{T,N}) where {T<:AbstractFloat,N} = N\np2 = Point{Float32,2}([1f0,2f0])\np3 = Point{Float32,3}([1f0,2f0,3f0])\nnum_coor(p2)\nnum_coor(p3)\npush!(p2.x,3)\np2\nnum_coor(p2)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"可以看出，类型中使用的N是用作类型参数的整数。","category":"page"},{"location":"ch02dadatypes/#类型上的运算","page":"数据类型","title":"类型上的运算","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"某些操作适用于类型。在前面，我们已经看到了一些，本节将详细介绍它们。","category":"page"},{"location":"ch02dadatypes/#typeof","page":"数据类型","title":"typeof","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"此函数提供与类型的实例相关联的具体类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a = 1 // 2\ntypeof(a)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"类型本身也有类型，它们都是DataType类型的实例。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(Int)\ntypeof(Any)\ntypeof(DataType)","category":"page"},{"location":"ch02dadatypes/#别名","page":"数据类型","title":"别名","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"与任何其他实例对象一样，类型可以进行比较和赋值。下面是来自base/boot.jl的代码片段。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"if Int === Int64\n    const UInt = UInt64\nelse\n    const UInt = UInt32\nend","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Int对象与Int64对象进行比较，如果相同则UInt初始化为UInt64，否则初始化为UInt32。因此根据机器架构，UInt成为UInt64或UInt32的别名。","category":"page"},{"location":"ch02dadatypes/#isa","page":"数据类型","title":"isa","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"判断实例是否属于特定类型。isa也可以用作中缀运算符。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"isa(1,Number)\nisa(1,Matrix)\nisa(1,Int)\n\"julia\" isa String","category":"page"},{"location":"ch02dadatypes/#supertype","page":"数据类型","title":"supertype","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"这个函数返回一个类型的直接超类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"supertype(Int32)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":">:用于指定（在结构或函数定义阶段）或判断一个类是否是另一个类的超类。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Integer >: UInt8\nFloat64 >: Float16","category":"page"},{"location":"ch02dadatypes/#:","page":"数据类型","title":"<:","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"此操作符用于表示一个类型是否是另一个类型的子类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Int32 <: Integer\nInt32 <: AbstractFloat\nInt32 <: Real\nInt32 <: Signed","category":"page"},{"location":"ch02dadatypes/#打印数据类型","page":"数据类型","title":"打印数据类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在定义了复杂的数据类型后，常需要以有意义的方式表示数据。默认情况下，所有成员都将作为元组打印。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"struct A \n    a1::Int32\n    a2::Float64\nend\na = A(1,2)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"其次，数据经常打印在REPL上。要禁止在REPL上打印数据，可以用分号(;)结束语句。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a;\na","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"默认情况下，Nothing不会标记输出。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"nothing","category":"page"},{"location":"ch02dadatypes/#show","page":"数据类型","title":"show","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"默认情况下，为了在REPL上显示输出，会在数据类型上调用相关的show方法。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"struct A\n    a1::Int32\n    a2::Float64\nend\na = A(1, 2)\nfunction Base.show(io::IO, a::A)\n    println(io, \"a1: \", a.a1, \" a2: \", a.a2)\nend\na","category":"page"},{"location":"ch02dadatypes/#print","page":"数据类型","title":"print","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"show用于在任何类型的输出设备上显示数据，而print只能用于输出文本信息。如果没有引入特定的打印例程，则在调用print时在内部使用show。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"print(a)","category":"page"},{"location":"ch02dadatypes/#string","page":"数据类型","title":"string","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"此函数可用于将任何类型转换为其字符串表示形式。当没有提供适当的转换方法时，将在内部调用print函数以获取数据类型的文本表示。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"string(a)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在前面的代码中可以清楚地看到print或底层show的用法。而字符串中额外的行尾则归因于println的使用，它向语句添加了一个EOL。如果想去掉它，只需要将show中的println换为print即可。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"function Base.show(io::IO, a::A)\n    print(io, \"a1: \", a.a1, \" a2: \", a.a2)\nend\nstring(a)","category":"page"},{"location":"ch02dadatypes/#数字在计算机中的存储与运算","page":"数据类型","title":"数字在计算机中的存储与运算","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在Julia中，如果你输入(sqrt3)^2，结果将是2.9....96，其中9重复了15次。相比与传统的数学运算，计算机的运算方式有两个明显且本质的区别:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"计算机只能表示有限数量的数字;\n计算机中表示的数字只能有有限多个有效数字。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"因此，能够在计算机中精确表示的数字只是有理数的一个子集。每当计算机执行一个运算，当结果不是一个可以在计算机中精确表示的数字时，就会用一个近似值来代替这个数字。这被称为舍入误差：用计算机进行实数计算时产生的错误。","category":"page"},{"location":"ch02dadatypes/#实数的浮点表示方法","page":"数据类型","title":"实数的浮点表示方法","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"下面是在计算机中表示实数的一般模型：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"x=s(a_1a_2a_t)_betatimesbeta^e tag1","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"其中","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"beginalign*\ns   x=1 的符号 2ex \ne   指数范围为LeU 2ex \n(a_1 a_t)_beta  = dfraca_1beta+dfraca_2beta^2+cdots+dfraca_tbeta^t尾数 2ex\nβ   基数 2ex\nt   有效数字个数精度 \nendalign*","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在浮点表示法(1)中，如果我们以这样一种方式指定e，即a_1 0，那么表示将是唯一的。这称为规格化的浮点表示法。例如，如果β = 10，在规格化的浮点数中，我们将把0012写成012  10^1，而不是0012  10^0或00012  10^1。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在当今大多数计算机中，基数是β = 2。过去老式的IBM大型机中曾使用过基数8和16。一些手持计算器使用基数10。莫斯科国立大学开发的Setun计算机，使用的基数是3，但并没有得到广泛推广。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"对于s，β，t，e的值，在一般浮点模型(1)中有多种选择。IEEE 64位浮点表示是当今大多数计算机中使用的特定模型：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"x=(-1)^s(1a_2a_3 a_53)_2 2^e-1023 tag2","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"注意在方程(1)和(2)中s的不同表现形式。在(2)中，s为0或1。s = 0，x是正的；s = 1, x是负的。\n由于β = 2，在x的规格化浮点表示中，小数点后的第一个(非零)位必然是1。因此我们不需要存储这个数字。这就是为什么在(2)中我们把x写成从1开始的小数。即使精度是t = 52，我们也能够访问到第53位有效数字a_53。\n指数的范围是:0e2047。稍后会讨论2047的来源。但首先，我们讨论一下为什么在(2)表示法中我们用e - 1023作为指数，而不是简单地用e(在(1)表示法中)作为指数。如果最小的可能指数是e = 0，那么计算机能生成的最小正数将是(1000)_2 = 1：当然，我们需要计算机来表示小于1的数字！这就是为什么我们在表示(2)中使用称为有偏指数的移位表达式e - 1023。注意，有偏指数的范围是- 1023e - 10231024。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"下图说明了计算机的物理位如何与上面的表示相对应。下表中编号为1到64的每个单元对应于计算机内存中的物理位。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: Physical bits)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"第一位是符号位：它存储s的值，0或1。\n蓝色的2到12位存储指数e(不是e1023)。使用11位，可以生成从0到2^111 = 2047的整数。下面是如何得到e的最小值和最大值：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"e=(000)_2=0 1ex \ne=(111)_2 =2^0+2^1++2^10=dfrac2^11-12-1=2047","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"红色的52位，存储有效数字a_2到a_53。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"例1：求10.375的浮点表示形式。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"解： 通过计算 10=0times2^0+textcolorblue1 2^1 + textcolorgreen0times2^2+textcolorred1times2^3 和 0375=0times2^-1+textcolorblue1times2^-2+textcolorgreen1times2^-3 可以得到 10=(textcolorred1textcolorgreen0textcolorblue10)_2 和 0375=(0textcolorblue1textcolorgreen1)_2。最终得到：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"10375=(1010011)_2=(1010011)_2times2^3","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"式中(1010011)_2  2^3为该数字的规格化的浮点表示。现在我们将其改写为式(2)的表示形式：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"10375=(-1)^0(1010011)_2times2^1026-1023","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"由于1026 =(10000000010)_2，按位表示的最终结果为：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: 基于10的数)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"注意因为数字是正数，第一个符号位是0。接下来的11位(蓝色)代表指数e = 1026，下一组红色的位是尾数，尾数的最末一位有效数字以后用0填充。在Julia中，我们可以通过输入bitstring(10.375)来逐位表示：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"bitstring(10.375)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"特殊情况：0，无穷，非数","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在浮点算术中有两个零：+00和00，它们有特殊的表示。在表示0时，所有的指数位和尾数位都设置为0。符号位是0的代表+00，1的代表00：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: zeros)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"当指数位设置为0时，我们有e = 0，因此e1023 =1023。这种将所有指数位设置为零的情况，是为00和非规格化数字保留的。非规格化数用来表示靠近0的数或0。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"下面是计算机中正负无穷数的表示方法：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: 正负无穷数)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"当指数位全设置为1时，我们有e = 2047，因此e1023 = 1024。这种安排是专门为以及其他特殊值，如NaN(非数)保留的；当尾数等于0时表示无穷大，尾数不等于0时表示非数。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"综上所述，尽管(2)中的1023e10231024，但在表示非零实数时，我们只能访问1022e10231023的指数范围。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"因此，计算机可以表示的最小正实数（非规格化）为：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"x=(-1)^0(0001)_2times2^-1022=2^-52times2^-1022=50times10^-324","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"最大正实数（规格化）为：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"x=(-1)^0(1111)_2times2^1023=left(1+dfrac12+dfrac12^2++dfrac12^52 right)times2^1023=(2-2^-52)times2^1023018times10^309","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在计算过程中，如果得到一个小于最小浮点数的数字，则会产生下溢错误。大于最大值的数字会产生上溢错误。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia中上溢和下溢错误分别是正负无穷：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"nextfloat((2.0-2^(-52))*2.0^1023)\nprevfloat(-(2.0-2^(-52))*2.0^1023)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"其运算方式与水银式温度计类似。","category":"page"},{"location":"ch02dadatypes/#整数的表示方法","page":"数据类型","title":"整数的表示方法","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在前一节中，我们讨论了计算机中实数的表示方法。这里我们将简要讨论整数的表示方法。计算机如何表示整数n？与实数类似，我们以2为基数开始写n。我们有64位来表示它的有效数字和符号。与浮点数一样，我们为符号分配一位，将其余的63位用于有效数字。当对整数进行加法运算时，这种方法有一些缺点。另一种方法被称为二进制补码，它更常用，包括在Julia中。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"举个例子，假设我们的计算机是8位的。要用二进制补码表示12(或任何正整数)，只需将它写成以2为基数展开的形式：(00001100)_2。为了表示−12，我们做如下操作：翻转所有数位，用0替换1，用1替换0，然后在结果上加1。翻转数字12，我们得到(11110011)_2，加上1（二进制）得到(11110100)_2。因此，−12在二进制补码法中被表示为(11110100)_2。为了表示-12，费了那么大的功夫，感觉有点奇怪，但当把12和-12二进制表示相加时，这种表示方法的优势立刻显现：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(00001100)_2+(11110100)_2=(textcolorred100000000)_2","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"这个和的前8位(从右到左)，也就是计算机能表示的(忽略红色数字1)，是(00000000)_2。所以就像以10为基数的12 +(- 12)= 0一样，这些数的表示形式的和也是0。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"我们可以用Julia实现64位的计算。函数bitstring输出一个整数的数位，对于负数使用二进制补码：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"bitstring(12)\nbitstring(-12)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"你可以验证当截断到64位时，这些表示的和为0。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"下面是另一个说明二进制补码优点的例子。考虑−3和5的表现，","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"-3=(11111101)_2 和 5 =(00000101)_2","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"−3和5的和是2；那么它们表示形式的二进制和呢？我们有：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(11111101)_2+(00000101)_2=(textcolorred100000010)_2","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"如果我们忽略红色的第9位，结果是(10)_2，结果也确实是2。注意，如果我们遵循浮点表示中使用的相同方法，并将最左边的位分配给整数的符号，就不会有这个属性。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"还记得对无符号整数取负的例子吧，它实际上返回的就是原整数的二进制补码。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"0xc\n-0xc","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在二进制补码中，使用64位，可以表示2^63 =9223372036854775808和2^631 =9223372036854775807之间的整数。小于或大于这个范围的任何整数都会产生下溢或上溢错误。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"整数的溢出与浮点数有所不同，如下所示：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typemax(Int64)\ntypemin(Int64)\ntypemax(Int64) + 1\ntypemin(Int64) - 1","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"当获得一个超过最大（或最小）可能值的整数时，Julia绕到最小（或最大）的整数，并继续计算。其运算方法与指针式钟表完全一样。","category":"page"},{"location":"#安装与配置","page":"安装与配置","title":"安装与配置","text":"","category":"section"},{"location":"","page":"安装与配置","title":"安装与配置","text":"Julia是一个跨平台应用，安装起来非常容易，不管是使用Windows、Linux还是macOS系统，都可到 Julia官方网站下载安装。在Windows下，安装过程中选择Add Julia to Path复选框，安装成功后就可以在命令行的任何位置启动Julia。","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"Julia有自己的图形窗口REPL（读取-求解-打印-循环），可对程序进行读取和执行。你可以通过桌面快捷图标、程序菜单或命令行来启动这个程序，当程序启动后，你将看到如下界面：","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"(Image: Julia启动界面)","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"最后一行 julia> 为命令提示符，它的出现表明Julia程序正常启动并进入到REPL，等待你输入代码。成功安装Julia软件后，我们需要对开发环境做一个简单的配置，以使你在Julia中的输入和输出看起来与书中的结果相一致（可能会有细微的差别）。在 julia> 提示符后输入如下命令：","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"using Pkg\nPkg.add(\"OhMyREPL\")\nusing OhMyREPL","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"大家可以先不用关心每条语句的具体含义，后面会逐步学到。配置完成后，如果你输入一行代码并按回车，REPL将显示结果：","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"1 + 1","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"另外一点需要说明的是，每次重新启动Julia程序后都要首先输入using OhMyREPL语句，这显然很麻烦。一个解决方案是可以将这条语句放入Julia启动文件startup.jl中。这样，Julia在启动时就会自动调用这条语句。startup.jl文件位于~/.julia/config/中，如果该目录下没有startup.jl文件或.julia目录中没有config目录，则可以自己创建一个。","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"在下载程序包时，如遇下载速度很慢的情况，可以将Julia程序包服务器镜像切换为国内镜像源，方法是在startup.jl文件中添加一条语句：ENV[\"JULIA_PKG_SERVER\"]=\"https://mirrors.bfsu.edu.cn/julia/static\"。","category":"page"}]
}
