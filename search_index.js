var documenterSearchIndex = {"docs":
[{"location":"dadatypes/#数据类型","page":"数据类型","title":"数据类型","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"类型是Julia语言的核心。尽管在语法上不需要显式地定义数据的类型，但Julia在编译过程中会对类型进行推断。Julia语言有预定义的类型。用户也可以定义自己的类型。有些类型可以通过参数进行修改。","category":"page"},{"location":"dadatypes/#数据种类","page":"数据类型","title":"数据种类","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"通常，动态类型编程语言没有开发良好的类型系统，如Python中的数据类型就是非强制的。Julia类型系统是动态的，但总是在对象实例化时进行推断。这样，Julia在执行代码段或对代码进行即时(JIT)编译之前，数据类型就是已知的了。简而言之，Julia原生支持在使用前定义或推断任意对象或字面量的数据类型。在深入介绍数据类型之前，让我们先了解一下Julia对数据的分类：变量、常量和字面量的知识。","category":"page"},{"location":"dadatypes/#变量","page":"数据类型","title":"变量","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Julia中的变量将名称与值关联起来。名称通常以字母开头的字母数字表示。下面给出了一些在Julia中变量名的例子。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"abc = 1\nπi = 30\na1 = 1\n1abc = 2\nsin = 1.0\ncos(0.0)\ncos = 0.0","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"从上面的结果可以看出，变量名可以包含Unicode字符；可以包含数字，但不能以数字开头；以函数名做为变量名时要特别慎重。变量名的另外一个限制是不能使用特殊字符和Julia的关键字，如下面的例程所示。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"julia> a@ = 1\nERROR: syntax: extra token \"@\" after end of expression\n\njulia> struct = 10\nERROR: syntax: unexpected \"=\"","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Julia的关键字很少。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"baremodule  begin   break       catch   const   continue\ndo          else    elseif      end     export  false \nfinally     for     function    global  if      import \nlet         local   macro       module  quote   return\nstruct      true    try         using   while ","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Julia还具有两字关键字(mutable struct、abstract type等)和中缀操作符(in、isa等)关键字。","category":"page"},{"location":"dadatypes/#定义与初始化","page":"数据类型","title":"定义与初始化","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"大部分静态语言，如C，变量的定义和初始化是独立的。定义声明变量的类型，其底层操作是向内存申请一块相应类型的地址空间并命名（变量名）。初始化则在地址空间中存入规定类型的具体值。变量和值的关系是：变量是主体，值是变量的附属。如下面C代码片段所示。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"int i;  /* 将i定义为整数类型 */\ni = 10; /* 初始化i */\nint j = 20; /* 在一条语句中定义并初始化变量 */","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Julia则将变量和值的关系翻转过来：值是主体，变量是值的附属。大多数Julia变量是在对类型进行初始化时定义的。事实上，类型是作为初始化过程的一部分赋给变量的。也可以显式地声明变量将要绑定的值的类型，Julia会尝试将值转换成相应的类型，不成功则会报错。对于REPL中的全局变量，不允许声明变量的类型。例程如下所示。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"a = 1\ntypeof(a)\na = 1.0\ntypeof(a)\nlet a::Int = 1.0\n    println(typeof(a))\nend\nlet a::Int = 1.1\n    println(typeof(a))\nend\na::Int = 1","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"从上面的介绍可以判断，Julia中的一般变量是没有固定地址的，事实也是如此。Julia甚至没有为我们开放变量地址的查询功能（后面会介绍可查询地址的变量类型），这一切都交给了底层程序自动处理。在Julia中，没有初始化的变量是无效的（后面会介绍例外的情况）:","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"i","category":"page"},{"location":"dadatypes/#常量","page":"数据类型","title":"常量","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"常量可以看作是不能修改的变量。然而，Julia并没有严格地遵循常量不变的条件。在类型不变的情况下修改常量的值，它会发出警告，但改变常量类型的情况是不允许的。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"const ICONSTANT = 1\nICONSTANT = 5\nICONSTANT = 5.0","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"在使用中，尽管常量的值是可以修改的，但我们应该严格遵守常量不变的特性，以避免程序在执行中产生不可预见的错误。","category":"page"},{"location":"dadatypes/#字面量","page":"数据类型","title":"字面量","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"字面量是表示一个值的常表达式。因为它们出现在变量定义的右边，因此常被称为右首值。它们也是一个值的本质表示形式。下面是一些不同类型的字面表达式。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"2           # Integer\n2.0         # Double precision Float (Float64)\n2f0         # Single precision Float (Float32)\n'a'         # Char\n\"string\"    # String","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"当我们深入研究类型时，我们将根据特定类型的上下文含义更详细地回顾字面量。通常，变量初始化为var = <literals>。","category":"page"},{"location":"dadatypes/#内置数据类型","page":"数据类型","title":"内置数据类型","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Julia语言自身定义了许多内置类型。而更多的类型则是在Julia库中定义的。Julia语言提供了扩展这些功能的灵活性。此外，定义的类型不作为保留的关键字存在。下面是该语言中一些常用的类型。","category":"page"},{"location":"dadatypes/#Nothing","page":"数据类型","title":"Nothing","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Nothing是值nothing的类型。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(nothing)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"typeof函数可用于查询值所属类型的信息。当代码中确实需要未初始化的变量条件时，可以使用nothing来初始化这个变量。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"a = nothing\ni = 6\nif i < 5\n    a = 5\nend\ntypeof(a)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"这里，如果i小于5 a就被赋值为5。否则，它仍保持未初始化。Nothing和nothing在函数参数和返回类型中也被广泛使用。","category":"page"},{"location":"dadatypes/#数值类型","page":"数据类型","title":"数值类型","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"下面是在Julia中定义为数值数据类型的一些数据类型。","category":"page"},{"location":"dadatypes/#Bool","page":"数据类型","title":"Bool","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"true和false在Julia中属于Bool类型。数值上，true的值为1,false的值为0。","category":"page"},{"location":"dadatypes/#整数","page":"数据类型","title":"整数","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"整型数字类型分为具有不同字节大小的无符号和有符号类型。有符号数字类型有:Int8、Int16、Int32、Int64和Int128。对应的无符号数字类型分别为:UInt8、UInt16、UInt32、UInt64和UInt128。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(1)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"数字字面量的默认数值类型是Int，根据机器的体系结构，它映射到Int32或Int64。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"对于无符号数字，字面量由0<表示说明符><数字>指定。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(0b1), typeof(0o7), typeof(0xff)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"这些由二进制、八进制和十六进制表示的数字都被映射到UInt8。数字的尺寸由满足字面量所需的最小字节大小决定。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(0xf), typeof(0xfff),typeof(0xfffff), typeof(0xfffffffff), typeof(0xfffffffffffffffff)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"无符号整数的前面也是可以加+/-号的，但加-号的含义不是得到一个负的整数，而是得到该整数的二进制补码（后续将介绍相关知识）。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"-0x2\nInt(ans)","category":"page"},{"location":"dadatypes/#浮点数","page":"数据类型","title":"浮点数","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"根据IEEE 754规范，Julia使用Float16、Float32和Float64来表示半精度、单精度和双精度浮点数。使用字面量f和e作为Float32和Float64的指数分隔符。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(1.0), typeof(1e0),typeof(1.e4)\ntypeof(1.0f0), typeof(1f-6), typeof(1.f4)","category":"page"},{"location":"dadatypes/#抽象类型","page":"数据类型","title":"抽象类型","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Julia中的类型可以从抽象类型派生出来。大多数面向对象语言将这种关系视为在类层次结构中描述对象的一种方法。在Julia中，抽象类型仅仅是像接口一样的概念性表示，内部没有数据元素。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"abstract type MyAbstractType end\nstruct MyConcreteType <: MyAbstractType\n    member\nend\na = MyConcreteType(5)\na isa MyAbstractType","category":"page"},{"location":"#安装与配置","page":"安装与配置","title":"安装与配置","text":"","category":"section"},{"location":"","page":"安装与配置","title":"安装与配置","text":"Julia是一个跨平台应用，安装起来非常容易，不管是使用Windows、Linux还是macOS系统，都可到 Julia官方网站下载安装。在Windows下，安装过程中选择Add Julia to Path复选框，安装成功后就可以在命令行的任何位置启动Julia。","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"Julia有自己的图形窗口REPL（读取-求解-打印-循环），可对程序进行读取和执行。你可以通过桌面快捷图标、程序菜单或命令行来启动这个程序，当程序启动后，你将看到如下界面：","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"(Image: Julia启动界面)","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"最后一行 julia> 为命令提示符，它的出现表明Julia程序正常启动并进入到REPL，等待你输入代码。成功安装Julia软件后，我们需要对开发环境做一个简单的配置，以使你在Julia中的输入和输出看起来与书中的结果相一致（可能会有细微的差别）。在 julia> 提示符后输入如下命令：","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"using Pkg\nPkg.add(\"OhMyREPL\")\nusing OhMyREPL","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"大家可以先不用关心每条语句的具体含义，后面会逐步学到。配置完成后，如果你输入一行代码并按回车，REPL将显示结果：","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"1 + 1","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"另外一点需要说明的是，每次重新启动Julia程序后都要首先输入using OhMyREPL语句，这显然很麻烦。一个解决方案是可以将这条语句放入Julia启动文件startup.jl中。这样，Julia在启动时就会自动调用这条语句。startup.jl文件位于~/.julia/config/中，如果该目录下没有startup.jl文件或.julia目录中没有config目录，则可以自己创建一个。","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"在下载程序包时，如遇下载速度很慢的情况，可以将Julia程序包服务器镜像切换为国内镜像源，方法是在startup.jl文件中添加一条语句：ENV[\"JULIA_PKG_SERVER\"]=\"https://mirrors.bfsu.edu.cn/julia/static\"。","category":"page"}]
}
