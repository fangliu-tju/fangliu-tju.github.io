var documenterSearchIndex = {"docs":
[{"location":"dadatypes/#数据类型","page":"数据类型","title":"数据类型","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"类型是Julia语言的核心。尽管在语法上不需要显式地定义数据的类型，但Julia在编译过程中会对类型进行推断。Julia语言有预定义的类型。用户也可以定义自己的类型。有些类型可以通过参数进行修改。","category":"page"},{"location":"dadatypes/#数据种类","page":"数据类型","title":"数据种类","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"通常，动态类型编程语言没有开发良好的类型系统，如Python中的数据类型就是非强制的。Julia类型系统是动态的，但总是在对象实例化时进行推断。这样，Julia在执行代码段或对代码进行即时(JIT)编译之前，数据类型就是已知的了。简而言之，Julia原生支持在使用前定义或推断任意对象或字面量的数据类型。在深入介绍数据类型之前，让我们先了解一下Julia对数据的分类：变量、常量和字面量的知识。","category":"page"},{"location":"dadatypes/#变量","page":"数据类型","title":"变量","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Julia中的变量将名称与值关联起来。名称通常以字母开头的字母数字表示。下面给出了一些在Julia中变量名的例子。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"abc = 1\nπi = 30\na1 = 1\n1abc = 2\nsin = 1.0\ncos(0.0)\ncos = 0.0","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"从上面的结果可以看出，变量名可以包含Unicode字符；可以包含数字，但不能以数字开头；以函数名做为变量名时要特别慎重。变量名的另外一个限制是不能使用特殊字符和Julia的关键字，如下面的例程所示。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"julia> a@ = 1\nERROR: syntax: extra token \"@\" after end of expression\n\njulia> struct = 10\nERROR: syntax: unexpected \"=\"","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Julia的关键字很少。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"baremodule  begin   break       catch   const   continue\ndo          else    elseif      end     export  false \nfinally     for     function    global  if      import \nlet         local   macro       module  quote   return\nstruct      true    try         using   while ","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Julia还具有两字关键字(mutable struct、abstract type等)和中缀操作符(in、isa等)关键字。","category":"page"},{"location":"dadatypes/#定义与初始化","page":"数据类型","title":"定义与初始化","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"大部分静态语言，如C，变量的定义和初始化是独立的。定义声明变量的类型，其底层操作是向内存申请一块相应类型的地址空间并命名（变量名）。初始化则在地址空间中存入规定类型的具体值。变量和值的关系是：变量是主体，值是变量的附属。如下面C代码片段所示。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"int i;  /* 将i定义为整数类型 */\ni = 10; /* 初始化i */\nint j = 20; /* 在一条语句中定义并初始化变量 */","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Julia则将变量和值的关系翻转过来：值是主体，变量是值的附属。大多数Julia变量是在对类型进行初始化时定义的。事实上，类型是作为初始化过程的一部分赋给变量的。也可以显式地声明变量将要绑定的值的类型，Julia会尝试将值转换成相应的类型，不成功则会报错。对于REPL中的全局变量，不允许声明变量的类型。例程如下所示。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"a = 1\ntypeof(a)\na = 1.0\ntypeof(a)\nlet a::Int = 1.0\n    println(typeof(a))\nend\nlet a::Int = 1.1\n    println(typeof(a))\nend\na::Int = 1","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"从上面的介绍可以判断，Julia中的一般变量是没有固定地址的，事实也是如此。Julia甚至没有为我们开放变量地址的查询功能（后面会介绍可查询地址的变量类型），这一切都交给了底层程序自动处理。在Julia中，没有初始化的变量是无效的（后面会介绍例外的情况）:","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"i","category":"page"},{"location":"dadatypes/#常量","page":"数据类型","title":"常量","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"常量可以看作是不能修改的变量。然而，Julia并没有严格地遵循常量不变的条件。在类型不变的情况下修改常量的值，它会发出警告，但改变常量类型的情况是不允许的。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"const ICONSTANT = 1\nICONSTANT = 5\nICONSTANT = 5.0","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"在使用中，尽管常量的值是可以修改的，但我们应该严格遵守常量不变的特性，以避免程序在执行中产生不可预见的错误。","category":"page"},{"location":"dadatypes/#字面量","page":"数据类型","title":"字面量","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"字面量是表示一个值的常表达式。因为它们出现在变量定义的右边，因此常被称为右首值。它们也是一个值的本质表示形式。下面是一些不同类型的字面表达式。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"2           # Integer\n2.0         # Double precision Float (Float64)\n2f0         # Single precision Float (Float32)\n'a'         # Char\n\"string\"    # String","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"当我们深入研究类型时，我们将根据特定类型的上下文含义更详细地回顾字面量。通常，变量初始化为var = <literals>。","category":"page"},{"location":"dadatypes/#内置数据类型","page":"数据类型","title":"内置数据类型","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Julia语言自身定义了许多内置类型。而更多的类型则是在Julia库中定义的。Julia语言提供了扩展这些功能的灵活性。此外，定义的类型不作为保留的关键字存在。下面是该语言中一些常用的类型。","category":"page"},{"location":"dadatypes/#Nothing","page":"数据类型","title":"Nothing","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Nothing是值nothing的类型。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(nothing)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"typeof函数可用于查询值所属类型的信息。当代码中确实需要未初始化的变量条件时，可以使用nothing来初始化这个变量。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"a = nothing\ni = 6\nif i < 5\n    a = 5\nend\ntypeof(a)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"这里，如果i小于5 a就被赋值为5。否则，它仍保持未初始化。Nothing和nothing在函数参数和返回类型中也被广泛使用。","category":"page"},{"location":"dadatypes/#数值类型","page":"数据类型","title":"数值类型","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"下面是在Julia中定义为数值数据类型的一些数据类型。","category":"page"},{"location":"dadatypes/#Bool","page":"数据类型","title":"Bool","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"true和false在Julia中属于Bool类型。数值上，true的值为1,false的值为0。","category":"page"},{"location":"dadatypes/#整数","page":"数据类型","title":"整数","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"整型数字类型分为具有不同字节大小的无符号和有符号类型。有符号数字类型有:Int8、Int16、Int32、Int64和Int128。对应的无符号数字类型分别为:UInt8、UInt16、UInt32、UInt64和UInt128。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(1)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"数字字面量的默认数值类型是Int，根据机器的体系结构，它映射到Int32或Int64。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"对于无符号数字，字面量由0<表示说明符><数字>指定。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(0b1), typeof(0o7), typeof(0xff)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"这些由二进制、八进制和十六进制表示的数字都被映射到UInt8。数字的尺寸由满足字面量所需的最小字节大小决定。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(0xf), typeof(0xfff),typeof(0xfffff), typeof(0xfffffffff), typeof(0xfffffffffffffffff)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"无符号整数的前面也是可以加+/-号的，但加-号的含义不是得到一个负的整数，而是得到该整数的二进制补码（后续将介绍相关知识）。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"-0x2\nInt(ans)","category":"page"},{"location":"dadatypes/#浮点数","page":"数据类型","title":"浮点数","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"根据IEEE 754规范，Julia使用Float16、Float32和Float64来表示半精度、单精度和双精度浮点数。使用字面量f和e作为Float32和Float64的指数分隔符。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(1.0), typeof(1e0),typeof(1.e4)\ntypeof(1.0f0), typeof(1f-6), typeof(1.f4)","category":"page"},{"location":"dadatypes/#抽象类型","page":"数据类型","title":"抽象类型","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Julia中的类型可以从抽象类型派生出来。大多数面向对象语言将这种关系视为在类层次结构中描述对象的一种方法。在Julia中，抽象类型仅仅是像接口一样的概念性表示，内部没有数据元素。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"abstract type MyAbstractType end\nstruct MyConcreteType <: MyAbstractType\n    member\nend\na = MyConcreteType(5)\na isa MyAbstractType","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"虽然我们将在后面详细讨论这个概念，但类型只能从一个抽象类型派生出来。中缀运算符isa用于判断特定对象是否属于特定类型。这里类型可以是具体类型也可以是抽象类型。下面是Julia中数字类型的类型层次结构。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: numerictypes)","category":"page"},{"location":"dadatypes/#基本类型","page":"数据类型","title":"基本类型","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"基本类型是使用固定字节数表示数据的一种具体类型。基本类型的经典例子是整数和浮点数。与大多数语言不同，除了一组固定的内置类型外，Julia允许声明自己的基本类型。实际上，Julia的基本类型都是在语言本身中定义的:","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"primitive type Float16 <: AbstractFloat 16 end\nprimitive type Float32 <: AbstractFloat 32 end\nprimitive type Float64 <: AbstractFloat 64 end\n\nprimitive type Bool <: Integer 8 end\nprimitive type Char <: AbstractChar 32 end\n\nprimitive type Int8    <: Signed   8 end\nprimitive type UInt8   <: Unsigned 8 end\nprimitive type Int16   <: Signed   16 end\nprimitive type UInt16  <: Unsigned 16 end\nprimitive type Int32   <: Signed   32 end\nprimitive type UInt32  <: Unsigned 32 end\nprimitive type Int64   <: Signed   64 end\nprimitive type UInt64  <: Unsigned 64 end\nprimitive type Int128  <: Signed   128 end\nprimitive type UInt128 <: Unsigned 128 end","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"声明基本类型的一般语法是:","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"primitive type «name» «bits» end\nprimitive type «name» <: «supertype» «bits» end","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"虽然用户可以定义自己的基本类型，但建议只有在现有的基本类型不能满足要求时再定义新的基本类型。相同位值的基本类型本质上是不可互换的，也不能无缝转换。类型层次结构在这类类型的行为中扮演着重要的角色。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"UInt32(3f-1)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"尽管它们都是32位实体，但单精度浮点数不能在每种情况下都表示为无符号整数。不能创建任意大小位的基本类型，目前仅支持8位倍数的位大小。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"primitive type MyType1 40 end\nprimitive type MyType2 4 end","category":"page"},{"location":"dadatypes/#位类型","page":"数据类型","title":"位类型","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Julia可以在二进制接口层面上与编译完成的语言，如C/C++、FORTRAN等进行无缝地交互，得益于Julia中定义的某些数据类型同这些本地编译语言所使用的类型在二进制布局中是一致的。这种类型被称为位类型。Julia中的基本类型都是位类型的数据类型。某些复合数据类型也是位类型。我们将在遇到他们时进一步讨论。位类型可以通过在实例上调用isbits函数或在类型上调用isbitstype函数进行查询。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"a = 10\nisbits(a)\nisbitstype(Int)","category":"page"},{"location":"dadatypes/#有理数和复数","page":"数据类型","title":"有理数和复数","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"虽然有理数和复数是数字类型，但它们不是基本类型。它们是使用复合数据类型创建的，我们将把复合数据类型作为用户定义类型的一部分来介绍。","category":"page"},{"location":"dadatypes/#字符","page":"数据类型","title":"字符","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Char是由32位值表示的字符。它是Unicode字符的一个有效UCS-4表示。我们将在String一章详细讨论Char及其与String的关系。AbstractChar抽象类型可方便用户开发自己的类Char数据类型。","category":"page"},{"location":"dadatypes/#字符串","page":"数据类型","title":"字符串","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"字符串是字符的集合。虽然大多数字符串是由Unicode字符编码组成的，但它们也可以存储其他类型的二进制数据。AbstractString抽象类型方便用户定义自己的字符串类型。","category":"page"},{"location":"dadatypes/#用户定义类型","page":"数据类型","title":"用户定义类型","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"虽然Julia提供了相当多的内置类型，但仍需要将各种属性组合在一起的数据类型。","category":"page"},{"location":"dadatypes/#结构","page":"数据类型","title":"结构","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Julia用struct表示一旦被初始化，其内部属性就不能被修改的自定义复合类型。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"struct Rectangle\n    h::Float64\n    w::Float64\nend\nr = Rectangle(10.0, 20.0)\nr.h = 15","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Rectangle是一个struct，初始化值为10.0和20.0。属性值不能被修改。函数Rectangle(10.0, 20.0)用来执行初始化。它是一个特殊的函数。当我们讨论函数和方法时，将进行深入介绍。","category":"page"},{"location":"dadatypes/#可变结构","page":"数据类型","title":"可变结构","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"假设我们需要Rectangle是可修改的，则可以创建一个可变结构，如下所示:","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"mutable struct MRectangle\n    h::Float64\n    w::Float64\nend\nmr = MRectangle(10.0, 20.0)\nmr.h = 15.0\nmr","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"可以看到，属性值在实例化对象之后是可以被修改的。Julia中的复合数据类型也可以从抽象类型派生出来。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"abstract type Shape end\nstruct Rectangle <: Shape\n    w::Float64\n    h::Float64\nend\nstruct Square <: Shape\n    l::Float64\nend","category":"page"},{"location":"dadatypes/#成员","page":"数据类型","title":"成员","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Julia中的复合类型具有成员属性，但没有成员函数或方法。Julia的多分派体系结构使函数的行为类似于特定类型的方法，但它们与面向对象语言中的方法不同。有一类特殊的函数，它可以是类型的成员。这些函数被称为构造函数。我们将在讨论函数时详细讨论构造函数。成员的类型信息并不总是在复合类型中被指定。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"mutable struct A\n    member\nend\na = A(5)\ntypeof(a.member)\na1 = A(\"string\")\ntypeof(a1.member)","category":"page"},{"location":"dadatypes/#Any","page":"数据类型","title":"Any","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"虽然在前面的例子中，模糊性问题在对对象进行实例化时得到了解决，但我们永远不能确定动态成员属性未来将被赋予哪种数据类型。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"a.member = \"julia\"\ntypeof(a.member)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"a.member之前的类型是Int64，现在是String。Julia假定这种未指明的类型为Any。在不能确定类型的情况下，Julia将假定类型为Any。从性能的角度来看，使用Any是不可取的。每次访问Any类型的对象时，它都会重定向到另一个实际的对象。我们不可能事先知道Any对象的大小。实际上，它是一个指向内存中实际对象所在的另一个位置的指针:","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: anytype)","category":"page"},{"location":"dadatypes/#参数数据类型","page":"数据类型","title":"参数数据类型","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Any作为类型会引入不必要的跳转，因此效率很低。有时，类型不一定会影响算法，但会引入不同的数据位大小。例如，前面介绍的Rational数据类型，分子和分母可以是任何整数类型，如Int8、Int16、Int32、Int64或Int128。Rational数据类型的定义如下:","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"struct Rational{T<:Integer} <: Real\n    num::T\n    den::T\nend","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"两个属性num和den的类型为T，其中T是Integer的子类型。Rational是Real的一个子类型。以下是参数数据类型的一些特性。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Rational{Any}\nRational{Int32} <: Rational\nRational{Int32} <: Rational{Integer}","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"理解这种行为尤其重要。尽管Int32是Integer的子类型，但参数表示Rational{Int32}不是Rational{Integer}的子类型。然而，Rational{Int32}是Rational的子类型。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"a = Rational{Int32}(1,UInt32(2))\ntypeof(a.num), typeof(a.den)\nb = Rational{Integer}(1,UInt32(2))\ntypeof(b.num), typeof(b.den)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"与具体数据类型一样，抽象数据类型也可以参数化。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"abstract type Shape{T<:AbstractFloat} end\nstruct Rectangle{T<:AbstractFloat} <: Shape{T}\n    w::T\n    h::T\nend\nstruct Square{T<:AbstractFloat} <: Shape{T}\n    s::T\nend","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"根据上面的方案，针对T可以开发不同的功能，如将T设为Float32或Float64，构建的Rectangle{Float32}类型与Rectangle{Float64}类型完全不同，它们是在编译过程中实例化具体类型时生成的。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"类型的参数化是Julia语言一个非常有用的特性，除此以外，也可以对整数值进行参数化。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"struct Point{T<:AbstractFloat,N}\n    x::Vector{T}\nend\nnum_coor(::Point{T,N}) where {T<:AbstractFloat,N} = N\np2 = Point{Float32,2}([1f0,2f0])\np3 = Point{Float32,3}([1f0,2f0,3f0])\nnum_coor(p2)\nnum_coor(p3)\npush!(p2.x,3)\np2\nnum_coor(p2)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"可以看出，类型中使用的N是用作类型参数的整数。","category":"page"},{"location":"dadatypes/#类型上的运算","page":"数据类型","title":"类型上的运算","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"某些操作适用于类型。在前面，我们已经看到了一些，本节将详细介绍它们。","category":"page"},{"location":"dadatypes/#typeof","page":"数据类型","title":"typeof","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"此函数提供与类型的实例相关联的具体类型。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"a = 1 // 2\ntypeof(a)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"类型本身也有类型，它们都是DataType类型的实例。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(Int)\ntypeof(Any)\ntypeof(DataType)","category":"page"},{"location":"dadatypes/#别名","page":"数据类型","title":"别名","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"与任何其他实例对象一样，类型可以进行比较和赋值。下面是来自base/boot.jl的代码片段。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"if Int === Int64\n    const UInt = UInt64\nelse\n    const UInt = UInt32\nend","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Int对象与Int64对象进行比较，如果相同则UInt初始化为UInt64，否则初始化为UInt32。因此根据机器架构，UInt成为UInt64或UInt32的别名。","category":"page"},{"location":"dadatypes/#isa","page":"数据类型","title":"isa","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"判断实例是否属于特定类型。isa也可以用作中缀运算符。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"isa(1,Number)\nisa(1,Matrix)\nisa(1,Int)\n\"julia\" isa String","category":"page"},{"location":"dadatypes/#supertype","page":"数据类型","title":"supertype","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"这个函数返回一个类型的直接超类型。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"supertype(Int32)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":">:用于指定（在结构或函数定义阶段）或判断一个类是否是另一个类的超类。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Integer >: UInt8\nFloat64 >: Float16","category":"page"},{"location":"dadatypes/#:","page":"数据类型","title":"<:","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"此操作符用于表示一个类型是否是另一个类型的子类型。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"Int32 <: Integer\nInt32 <: AbstractFloat\nInt32 <: Real\nInt32 <: Signed","category":"page"},{"location":"dadatypes/#打印数据类型","page":"数据类型","title":"打印数据类型","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"在定义了复杂的数据类型后，常需要以有意义的方式表示数据。默认情况下，所有成员都将作为元组打印。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"struct A \n    a1::Int32\n    a2::Float64\nend\na = A(1,2)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"其次，数据经常打印在REPL上。要禁止在REPL上打印数据，可以用分号(;)结束语句。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"a;\na","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"默认情况下，Nothing不会标记输出。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"nothing","category":"page"},{"location":"dadatypes/#show","page":"数据类型","title":"show","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"默认情况下，为了在REPL上显示输出，会在数据类型上调用相关的show方法。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"struct A\n    a1::Int32\n    a2::Float64\nend\na = A(1, 2)\nfunction Base.show(io::IO, a::A)\n    println(io, \"a1: \", a.a1, \" a2: \", a.a2)\nend\na","category":"page"},{"location":"dadatypes/#print","page":"数据类型","title":"print","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"show用于在任何类型的输出设备上显示数据，而print只能用于输出文本信息。如果没有引入特定的打印例程，则在调用print时在内部使用show。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"print(a)","category":"page"},{"location":"dadatypes/#string","page":"数据类型","title":"string","text":"","category":"section"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"此函数可用于将任何类型转换为其字符串表示形式。当没有提供适当的转换方法时，将在内部调用print函数以获取数据类型的文本表示。","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"string(a)","category":"page"},{"location":"dadatypes/","page":"数据类型","title":"数据类型","text":"在前面的代码中可以清楚地看到print或底层show的用法。而字符串中额外的行尾则归因于println的使用，它向语句添加了一个EOL。","category":"page"},{"location":"#安装与配置","page":"安装与配置","title":"安装与配置","text":"","category":"section"},{"location":"","page":"安装与配置","title":"安装与配置","text":"Julia是一个跨平台应用，安装起来非常容易，不管是使用Windows、Linux还是macOS系统，都可到 Julia官方网站下载安装。在Windows下，安装过程中选择Add Julia to Path复选框，安装成功后就可以在命令行的任何位置启动Julia。","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"Julia有自己的图形窗口REPL（读取-求解-打印-循环），可对程序进行读取和执行。你可以通过桌面快捷图标、程序菜单或命令行来启动这个程序，当程序启动后，你将看到如下界面：","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"(Image: Julia启动界面)","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"最后一行 julia> 为命令提示符，它的出现表明Julia程序正常启动并进入到REPL，等待你输入代码。成功安装Julia软件后，我们需要对开发环境做一个简单的配置，以使你在Julia中的输入和输出看起来与书中的结果相一致（可能会有细微的差别）。在 julia> 提示符后输入如下命令：","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"using Pkg\nPkg.add(\"OhMyREPL\")\nusing OhMyREPL","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"大家可以先不用关心每条语句的具体含义，后面会逐步学到。配置完成后，如果你输入一行代码并按回车，REPL将显示结果：","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"1 + 1","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"另外一点需要说明的是，每次重新启动Julia程序后都要首先输入using OhMyREPL语句，这显然很麻烦。一个解决方案是可以将这条语句放入Julia启动文件startup.jl中。这样，Julia在启动时就会自动调用这条语句。startup.jl文件位于~/.julia/config/中，如果该目录下没有startup.jl文件或.julia目录中没有config目录，则可以自己创建一个。","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"在下载程序包时，如遇下载速度很慢的情况，可以将Julia程序包服务器镜像切换为国内镜像源，方法是在startup.jl文件中添加一条语句：ENV[\"JULIA_PKG_SERVER\"]=\"https://mirrors.bfsu.edu.cn/julia/static\"。","category":"page"}]
}
