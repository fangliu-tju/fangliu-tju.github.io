var documenterSearchIndex = {"docs":
[{"location":"ch08string/#字符串","page":"字符串","title":"字符串","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"文本是当今计算中最常用的数据类型之一。文本可以表示特定自然语言中的特定表达式(如英语中的句子)，任意字符的二进制转储(如二进制字节数组)，表达式的多语言表示(其中句子可能包含来自另一种语言的单词)。我们将介绍在Julia中文本是如何表现的。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"一个句子可能包含来自多种语言的符号和字符。例如，英语句子中的数学符号和希腊表达式。最后，文本通常被用作除了使用文本关键字外没有其他方法表示实体的最后手段。对于这种情况，虽然经常使用Julia符号，但是文本也是可以的。本章将对前面所讨论的各个方面作一些详细的探讨。文本使用的多样性带来了许多表示方面的挑战，我们必须从概念上理解Julia语言的设计。虽然文本的结构可能会涉及文档结构和表示的复杂性，但我们将把讨论的范围限制在字符串的概念上。","category":"page"},{"location":"ch08string/#字符串-2","page":"字符串","title":"字符串","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"字符串是作为文本表示的字符的集合。虽然它们在特定语言中可能是有意义的句子，但它们可以是完全没有意义的字符的集合。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"This is a valid sentence.","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"Abccnajkvnkavnak","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"前面两行都是有效的字符串，但在英语中不都是有效的句子。","category":"page"},{"location":"ch08string/#字符","page":"字符串","title":"字符","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"一组字符组成一个字符串。在前面的例子中：","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"[' ', 'T', 'a', 'c', 'd', ‘e’, ‘h’, ‘i’, ‘l’, ‘n’, ‘s’, ‘t’, 'v']字符组成句子 This is a valid sentence。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"字符在集中的顺序和位置也很重要。","category":"page"},{"location":"ch08string/#编码","page":"字符串","title":"编码","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"我们平时书写的字符对计算机来说没有任何意义。在计算机中，每个实体都被表示为一个数值或数值的等价二进制值。这样的数字被称为编码。在使用美国信息交换标准码(ASCII)作为编码方案的计算机中，字符a被表示为编码值97或0x61。ASCII只是表示英语字符集编码中的一种。另外一种是扩展二进制编码的十进制交换码(EBCDIC)，它曾是IBM大型机的首选，但现在不再流行了。在开始研究文本的Julia语言结构之前，我们将从概念上讨论一些编码（在深入研究一些具体编码之前，先进行一些理论理解）。这个介绍不完全按照时间的先后顺序，因为我们的重点是获得一种直观的理解。","category":"page"},{"location":"ch08string/#ASCII","page":"字符串","title":"ASCII","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"7位字符表示法，目的是表示所有可打印英语字符，以及一些用于设备间通信(如串行或并行通信通道)的非打印字符。ASCII的设计方式是在特定范围内将大写字母和小写字母分组；类似地，所有数字也都分组在一个范围内。这使得编程和识别字符更加容易，这一点是EBCDIC所欠缺的。与此同时，由于字节已经成为微处理器中的计算单元，这使得最左边的1个自由位可以容纳额外的128个字符。美国国家标准协会(ANSI)考虑了常用的非英语字符，并试图将其中的128个字符作为ANSI字符代码。微软和苹果这样的操作系统供应商也提出了他们自己的字符编码，如Windows-1252编码或Mac Roman编码，等等。它们基本上都支持从0到127的字符代码的一般ASCII规范，但为了方便起见，它们为从128到255的每个字符代码添加了各自的字符集。这导致了在不同操作系统和设备上显示和转换文档时的“编码战争”。业界中使用的术语“高位ASCII”或“扩展ASCII”，本质上是字符码128-255在不同标准之间的变化。","category":"page"},{"location":"ch08string/#ISO-8859","page":"字符串","title":"ISO-8859","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"ISO-8859是一组编码，包含1-16个代码页，每个代码页代表可以一起表示的一类欧洲语言——有时也称为Latin-1、Latin-2等编码。所有这些代码页都有0-127支持基本ASCII字符，而128-255可能支持一类特殊的欧洲区域语言，如西里尔语、波罗的海语等。这种安排确保了在计算机中轻松地支持欧洲语言。通常，多语言文档或屏幕会使用某种形式的代码页切换命令，并从新代码页中拾取切换的字符编码。当然，它的优点是所有字符串都可以表示为8位值的二进制转储。","category":"page"},{"location":"ch08string/#'C'编码","page":"字符串","title":"'C'编码","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"‘C’语言是在20世纪70年代末引入的，它使用了非常简单的文本范式。任何二进制8位字节数组都是字符串。数组的最后一个字节必须以字符码(0)或NULL结束。这个概念被称为NULL终止字符串或c字符串，它确保了代码解释保持在字符串操作之外。C语言本身在实现字符串方法时完全忽略了语言内部的编码解释，并期望程序员在他们正在开发的应用程序或系统中处理它。由于缺乏更好的术语，一些计算机系统，如GNU Linux，将其称为C编码。在UNIX等系统中，C编码是系统的默认编码。","category":"page"},{"location":"ch08string/#Unicode","page":"字符串","title":"Unicode","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"随着计算机的普及，人们越来越清楚地认识到计算不能再局限于一个特定的区域。其次，数据交换还要求数据能够在任何可用的计算系统中显示。第三，因为计算机中可用的存储和内存都变得便宜了，所以表示文本所需的内存可以增加到超过一个字节。不需要再对字符进行单字节限制。一群计算机科学家和来自不同组织和学术机构的语言学家聚集在一个Unicode联盟组织下，提出了通用编码字符集(UCS)。1991年引入的第一组字符集大约有7000个字符，由称为UCS-2的2字节字符表示。很快，随着更多的语言加入到规范中，字符开始增长。这时在一个称为UCS-4的表示中为每个字符分配4个字节。实际上，Unicode规范定义了16个大小为65536(2^16)的代码平面，其中实际使用的值很少。从技术上讲，32位中只有20位真正用于实际目的。然而，许多计算机系统继续在操作系统中实现宽字符，Windows开发了一个本地16位操作系统Windows NT，并停止了旧的Windows 95代码基。在上世纪90年代末和新千年前期，需要使用宏分别编译8位和16位版本的代码。","category":"page"},{"location":"ch08string/#Unicode转换","page":"字符串","title":"Unicode转换","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"世界上的一部分人正忙于重写操作系统核心以支持宽字符。甚至一些unix派生系统也有4字节实现的宽字符。Ken Thompson提出了重用c编码作为Unicode字符基础的想法。但是，c编码或c字符串不能被用作整个字节的数据被设置为NULL的UCS-2和UCS-4，因为在c语言中，字符串终止字符被定义为0。例如，字符'a'的UCS-2代码是U+0061，其前导字节为0。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"他希望Unicode字符的表示方式是这样的：","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"ASCII字符在新的编码中仍然有效，这意味着不能对0x00-0x7F范围内的任何字符进行转换。\n对于任何值为128或更高的字符，必须用多字节字符表示。\n新的编码必须有一个前导字节，告诉接下来要读取多少个字节。\n在出现歧义的情况下，应该选择用最少字节数表示的代码。\n用于前导和后置字节的模式必须是这样的，如果有任何违反，它将很容易识别字符序列是损坏的，以便于在即使没有如CRC等任何冗余检查的情况下更容易传输。\n这个方案确保除了实际的NUL字符之外，其他字符的字节都不是零。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"下面是该方案最终的样子：","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"(Image: UTF-8)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"上面的表示称为UTF-8。那21位以外的编码呢？到目前为止，Unicode规范使用的信息不超过21位，但该方案可以容纳多达36位的信息，覆盖整个UCS-4范围。与UTF-8类似，UTF-16考虑将字符代码扩展为每次2字节的字符。此外还有UTF-32转换方案。","category":"page"},{"location":"ch08string/#Julia对Unicode的支持","page":"字符串","title":"Julia对Unicode的支持","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"Julia语言原生支持Unicode，甚至变量和常量也可以使用Unicode字符。Julia字符串(String类型)在内部被存储为UTF-8编码的Unicode字符流。Julia中的字符(Char)被表示为4字节的UTF-8编码。在Julia中，以UInt8表示的原始字节不是Char。然而，作为一种语言，Julia支持用其他编码表示字符串的结构。还可以使用Julia接口开发自己的字符代码和字符串。你可能需要与原生C/C++应用程序交换信息，这可能需要从Julia代码中将字符串信息交换为Cstring。在C语言中，Cstring是一个以零结束的字符串。","category":"page"},{"location":"ch08string/#字体和字形","page":"字符串","title":"字体和字形","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"让我们看看a在不同字体中的表示：","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"(Image: Glyphs a)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"字体和字形提供了字符的视觉外观和感觉。作为一种编程语言，Julia没有提供任何控制字体或字形选择的机制。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"现在我们理解了文本计算的各个方面，让我们看看Julia是如何满足这些需求的。","category":"page"},{"location":"ch08string/#字符串-3","page":"字符串","title":"字符串","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"在Julia中，String对象可以用以下字面表达式进行初始化。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"str = \"This is a string\"","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"字符串是不变的，一旦创建，它们就不能被修改。下面是另一种定义字符串的方法，其保留了格式和新行字符，特殊字符不需要额外的引号。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"str = \"\"\"\n This is a preformatted\n \"string\" \"\"\"","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"字符串可以包含由其他变量计算得到的信息，并纳入最终计算结果。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"a = \"Jack\";\nb = \"Jill\";\nc = \"100\";\nstr = \"$a owes $b $c dollars\"","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"字符串中使用的特殊字符，如引号(\")或反斜杠(\\)需要使用反斜杠(\\)转义。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"str = \"This is a \\\"quoted\\\\ ' string\"","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"note: Note\n字符串是不变的。因此，它们可以驻留在系统内存中，即使在收集垃圾时也不会被覆盖。内存调试器可用于读取随机内存位置。对于像密码这样的敏感数据，你应该考虑使用字节或字符数组结构，并在使用数据后覆盖内存位置。解引用内存对象并强制调用垃圾回收可能不是最安全的选项。","category":"page"},{"location":"ch08string/#字符串方法","page":"字符串","title":"字符串方法","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"我们将介绍一些字符串的标准方法。","category":"page"},{"location":"ch08string/#比较","page":"字符串","title":"比较","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"字符串对象之间可以使用标准比较运算符isequal(==)、isless(<)或大于(>)进行比较。比较通常根据字典顺序。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s1 = \"abc\"\ns2 = \"def\"\ns1 < s2\ns2 > s1\ns1 = \"abc\"\ns2 = \"abc\"\ns1 == s2","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"等同运算符(===)在不同对象之间进行比较，对于不变的字符串对象，则按位进行比较。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s1 === s2","category":"page"},{"location":"ch08string/#迭代","page":"字符串","title":"迭代","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"就像数组和集一样，字符串也是字符序列的自然集。因此，当对字符串进行迭代时，你能够枚举字符。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s = \"Julia\";\nfor c in s\n    println(c)\nend","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"与其他集一样，Julia字符串也支持基于1的索引，并在每个位置上显示字符。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s[1], s[2], s[3], s[4], s[5]","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"begin和end也可以像在其他类型的集中一样使用。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s[begin], s[begin+2], s[end-1], s[end]","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"让我们取一个包含多字节UTF-8字符的字符串。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s = \"\\u2200 x \\u2203 y\"\nlength(s)       # No of characters in the String\nsizeof(s)       # No fo bytes in the String\ns[1]\ns[2]\ns[4]","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"因此，getindex方法将字节索引作为输入，并返回一个有效的字符。但是，当索引没有映射到有效字符时，就会像s[2]中的情况一样抛出异常。但是，for...in循环可对字符进行迭代。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"for c in s\n    println(c)\nend","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"另一种使用索引变量的方式是使用方法nextind。该方法将返回下一个具有有效字符的索引。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"i, l = firstindex(s), lastindex(s);\nwhile i <= l\n    println(s[i])\n    i = nextind(s, i)\nend","category":"page"},{"location":"ch08string/#拆分和连接","page":"字符串","title":"拆分和连接","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"将字符串拆分为子字符串的最简单方法之一是使用索引，连接则使用运算符(*)。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"str = \"This is a String\"\nstr[1:4]\nstr[1:4]*str[end-6:end]","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"由于字符串是不变的，每个子字符串或连接运算都会在它们被连接之前分配中间字符串。可以使用repeat函数或其别名运算符(^)创建文本模式的重复序列。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"repeat(\"A:-\", 5)\n\"A:=\"^4","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"join对输入字符串集进行组合。可以选择提供分隔符如逗号(,)和最后连接词如and。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"join([\"1\", \"2\", \"3\", \"4\", \"5\"])\njoin([\"Jack\", \"Jill\", \"Cathy\", \"Trevor\"], \", \", \" and \")","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"chomp移除字符串中的最后一个行结束符。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"str = \"This is a\\nString\\n\"\nchomp(str)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"chop从头部和尾部删除字符。默认情况下，不从头部删除字符，只从尾部删除一个字符。但是，关键字head和tail可以用来分别指定从头部和尾部删掉打字符数。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"chop(\"October\")\nchop(\"October\", head=2, tail=3)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"split方法根据空格拆分字符串对象并返回一个子字符串对象数组。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s = \"\\u2200 x \\u2203 y\"\nss = split(s)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"字符串对象是不变的，任何提取字符串一部分的表达式都将分配一个新的字符串。子字符串是字符串对象的视图。在前面的示例中，数组中所有拆分的子字符串对象都指向同一个字符串对象。子字符串对象扩展了AbstractString接口，因此在需要时可用于转换为字符串对象。split方法也支持分隔符。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s = \"\\u2200,x,\\u2203,y\"\nss = split(s, ',', limit=2)\ns = \"\\u2200,x,\\u2203,y\"\nss = rsplit(s, ',', limit=2)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"split示例使用逗号(，)作为分隔符，并将分割部分的数量限制为2。与split从左边拆分字符串类似，rsplit从右边拆分字符串。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"lpad和rpad为字符串添加前缀或后缀，使其达到指定的长度。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"lpad(\"string\", 10, \"p\")\nrpad(\"string\", 10, \"s\")","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"strip函数删除字符串两边的空格字符。该函数还可以有选择地接受一个要从两端删除的字符数组。也可以使用计算值为true在两端进行删除。lstrip和rstrip是两个类似于strip的函数，但只分别作用于字符串的左端和右端。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"strip(\"     string 123    \")\nstrip(\" {a}    sting 123  \",['{', 'a', '}', ' '])\nstrip(\"    string 123 aaa\") do x\n    return x == ' ' || x == 'a'\nend","category":"page"},{"location":"ch08string/#大小写转换","page":"字符串","title":"大小写转换","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"一些函数都输出结果如字面意义所示：","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"uppercase(\"Julia\")\nlowercase(\"JULiA\")\ntitlecase(\"hands on programming in julia\")\nuppercasefirst(\"julia\")\nlowercasefirst(\"JuLia\")","category":"page"},{"location":"ch08string/#模式匹配","page":"字符串","title":"模式匹配","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"模式匹配函数可以分为不同的类别。下面给出了其中的一些：","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"startswith，endswith和contains分别搜索字符串的开始部分，结束部分和字符串中的任何位置，返回它们是否在字符串中出现。occurrence (needle, haystack)是contains(haystack, needle)的另一种表示形式。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"str = \"Introduction to Julia\";\nstartswith(str, \"Intro\")\nendswith(str, \"Julia\")\ncontains(str, \"to\")\noccursin(\"to\", str)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"findfirst和findnext沿着字符串对象搜索模式序列。findlast返回模式最后出现的位置。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"r = findfirst(\"o\", \"Introduction to Julia\");\nwhile r !== nothing\n    println(r)\n    r = findnext(\"o\", \"Introduction to Julia\", r.stop+1)\nend\nfindlast(\"o\", \"Introduction to Julia\")","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"replace将搜索的输入模式更改为选取的另一文本。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"replace(\"Introduction to Julia\", \"o\"=>\"a\")","category":"page"},{"location":"ch08string/#正则表达式","page":"字符串","title":"正则表达式","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"正则表达式是一种模式匹配语言构造，它使计算机程序员能够定义与文本字符串匹配的复杂模式。这些模式主要用于编译器设计和标记器等。UNIX中使用正则表达式(regex)进行模式匹配的几个常用应用程序是lex、grep和egrep。与grep支持的标准语法相比，PERL、Python和R等编程语言提供了扩展的正则表达式语法支持。PERL兼容正则表达式(PCRE)库集成到了Julia中。因此，Julia对正则表达式的支持与任何其他语言一样强大。虽然我们在这里展示了一些正则表达式的示例，但这一节并没有专门介绍正则表达式的所有细节。读者需要阅读更专业的文档来深入了解正则表达式。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"可以看到，下面的示例中创建了一个Regex对象。将它与字符串匹配。匹配的对象存储在RegexMatch对象中。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"rx = Regex(\"a.a\")\nm = match(rx, \"abracadabra\")\nm.match","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"偏移匹配可以匹配到ada而不是aca。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"m = match(rx, \"abracadabra\", 5)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"在下面的例子中，一个@r_str宏(将在下一章详细讨论)被用来初始化Regex对象。rx对象定义了一个捕获组，匹配的正则表达式可以将捕获保存在capture属性中。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"rx = r\"a(.)a\";\nm = match(rx, \"abracadabra\");\nm.captures","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"现在使用命名捕获显示相同的示例。可以使用捕获的组名对RegexMatch进行索引来收集捕获的数据。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"rx = Regex(\"a(?<key>.)a\");\nm = match(rx, \"abracadabra\");\nm.captures\nm[\"key\"]","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"你还可以将模式多次匹配到字符串中。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"rx = r\"a.a\"\nm = eachmatch(rx, \"abracadabra\", overlap=true)\ncollect(m)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"当允许重叠字符串时，aca和ada都是匹配的。当overlap参数设置为false时，只匹配aca。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"m = eachmatch(rx, \"abracadabra\", overlap=false)\ncollect(m)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"不仅仅是match或eachmatch, 正则表达式匹配也被作为模式参数用于比如findfirst，findnext，occursin，replace，split，rsplit，startwith和endswith。","category":"page"},{"location":"ch08string/#编码-2","page":"字符串","title":"编码","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"Julia中的字符串对象本质上是Unicode表示。它们是否遵循特定的转换？可以转换为其他东西吗？有些问题对于读者来说是很自然的。如果你还记得迭代中的讨论，nextind方法将索引对齐到下一个UTF-8字符的位置上。这确保字符串对象本质上是UTF-8表示。但是，可以通过函数transcode提取出UTF-8、16和32数组表示。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"s = \"\\u2200 x \\u2203 y\"\ntranscode(UInt8, s)\ntranscode(UInt16, s)\ntranscode(UInt32, s)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"transcode还可以将UTF字节数组转换为字符串对象。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"transcode(String, transcode(UInt16, s))","category":"page"},{"location":"ch08string/#有用的函数","page":"字符串","title":"有用的函数","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"有些函数相当直观。然而，不仅仅局限于ASCII字符集或英语字符，所有这些方法都适用于存在相关函数的所有语言的Unicode字符。它们利用Unicode表中的字符类别定义来确定这些属性。例如，所有属于Lu类别的字符对于isuppercase方法都返回真。类似地，当isspace方法查询字符时，类别Zs将被提取。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"isascii(\"∀ x ∃ y\"), isascii(\"abcd ef\")\niscntrl('a'), iscntrl('\\x1')\nisdigit('a'), isdigit('9')\nisxdigit('a'), isxdigit('x')\nisletter('1'), isletter('a')\nisnumeric('1'), isnumeric('௰') #No. 10 in Tamil (Indian) Language\nisuppercase('A'), islowercase('a')\nisspace('\\n'), isspace('\\r'), isspace(' '), isspace('\\x20')","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"在处理字符串和编码时，我们发现一些函数针对单个字符的属性。因此，将字符串转换为字符数组是很重要的。","category":"page"},{"location":"ch08string/#字符数组","page":"字符串","title":"字符数组","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"如前所述，字符串对象是字符的集。但是，它们不能被修改。你不能像对数组或其他容器类型那样灵活地对它们进行操作。然而，有很多函数可以用来转换字符串对象和创建另外的字符串对象。然而,如果需要，你可以使用collect方法将字符串转换为字符数组。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"collect(\"∀ x ∃ y\")","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"如前面所示，你还可以使用transcode方法来获得字符串对象的UTF-8，16，32转换向量。一旦有了字符数组，就可以在数组操作中以任何需要的方式使用它。","category":"page"},{"location":"ch08string/#用户定义字符串","page":"字符串","title":"用户定义字符串","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"罗马不是一天建成的，Julia字符串API也不是。字符串是包装在集中的UTF-8表示，该集将字符对象作为eltype。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"eltype(\"abcd\")","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"该体系结构被进一步扩展，以定义一个抽象的AbstractString类型，该类型将AbstractChar视为一个元素类型。在1.0之前的版本中，Julia有很多这样的实现，比如ASCIIString、UTF8String等等，它实际上是为一些常用的编码方案提供了基础。许多经典的字符串类型在功能上合并到String类型中，一些被移动到一个名为LegacyString.jl的可选包中。虽然使用那个包没有什么显著的好处，但是对于有兴趣尝试和实现自己的字符串类型的人来说，它们是一个很好的参考来源。如果你对实现自己的字符串类型感兴趣，请确保实现了AbstractString和AbstractChar接口。","category":"page"},{"location":"ch08string/#AbstractChar","page":"字符串","title":"AbstractChar","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"这个接口本质上要求任何派生字符都应该有一个Unicode表示值。同样，给定一个有效的Unicode值，必须能够创建一个字符。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"struct MyChar <: AbstractChar \n    a::UInt32\nend\nMyChar(n::Number)=MyChar(UInt32(n))\nBase.codepoint(c::MyChar) = c.a\nMyChar(32)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"如果代codepoint输入值不在编码范围内，构造函数必须抛出错误。","category":"page"},{"location":"ch08string/#AbstractString","page":"字符串","title":"AbstractString","text":"","category":"section"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"AbstractString接口要复杂得多，并且对字符串对象的内部组成也做了一些假设。例如，这些接口定义了在字符串中定义一个字符所需的最小字节数的假设。如果你使用LegacyString，你会意识到ASCIIString使用一个unit8的codeunit，而UTF16String使用一个unit16的codeunit。但两者在代码单元中的内部数据长度相同。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"using Pkg\nPkg.add(\"LegacyStrings\")\nusing LegacyStrings\ns = ASCIIString(\"abcd\");\ncodeunit(s)\nncodeunits(s)\ns16 = UTF16String(transcode(UInt16, \"abcd\\0\")); # NULL termination\ncodeunit(s16)\nncodeunits(s16)\neltype(s),eltype(s16)","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"尽管前面例子中的ASCIIString和UTF16String对存储的内部数据有完全不同的内部表示，但它们使用Char作为迭代的eltype。没有为这两种数据类型定义另外的字符类型。","category":"page"},{"location":"ch08string/","page":"字符串","title":"字符串","text":"除了上述方法外，AbstractString的派生类型还需要实现所有迭代和索引方法，如iterate、getindex、nextind、prevind、lastindex、firstindex，以及一些与集相关的方法，如length。","category":"page"},{"location":"ch04function/#函数和方法","page":"函数和方法","title":"函数和方法","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"大多数代码都可以在类似shell的REPL接口中输入，如同正在编写脚本一样。但是，当你使用函数，向其传入或从中传出数据时，Julia的真正能力才体现出来。为了发挥多分派接口的强大功能，学习函数和方法成为Julia编程的基本需要。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"没有一个产品级应用是在单个文件中使用顺序语句开发出来的。大多数程序员喜欢将程序分割成小块的可执行单元。这解决了两个问题。首先，它创建了可重用单元，这些单元可以在更大的程序中的不同位置被多次调用。其次，小单元可以很容易地进行单元测试。因此，它们提高了代码的可靠性。我们将尝试以编程的方式解决国际象棋中的8皇后问题，并在此过程中理解Julia中的函数。","category":"page"},{"location":"ch04function/#皇后问题","page":"函数和方法","title":"8皇后问题","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"它是算法和人工智能领域的一个经典问题。目标是在满足不相互攻击的前提下，在棋盘上放置最大数量的皇后。下图给出了一种可能解。然而，这个解不是唯一的。我们将编写一个程序来解决8皇后问题。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"(Image: eight queens)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"在设计出问题的完整解决方案之前，我们必须有一个程序单元，作为输入信息，它接收两个皇后的位置，并输出皇后是否相互攻击。","category":"page"},{"location":"ch04function/#两个相互安全的皇后","page":"函数和方法","title":"两个相互安全的皇后","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"Julia中的这些小程序单元叫做函数。我们将创建一个函数，它接受两个皇后的输入位置，返回皇后的路径是否重叠则。以下是皇后互相攻击的条件。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"皇后有相同的x或y坐标：x₂ = x₁或y₂ = y₁。\n皇后彼此在对角线上，即：x₂ - x₁ = y₂ - y₁。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"如果两边的符号相同，就得到x_1 - y_1= x_2 - y_2。同样地，如果符号相反，我们会得到x_1 + y_1= x_2 + y_2。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"根据观察，我们在Julia中有以下函数:","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function attacks(x1, y1, x2, y2)\n    if x1 == x2\n        return true\n    elseif y1 == y2\n        return true\n    elseif x1 - y1 == x2 - y2\n        return true\n    elseif x1 + y1 == x2 + y2\n        return true\n    else\n        return false\n    end\nend\nattacks(1, 2, 4, 5)\nattacks(1, 2, 4, 6)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function...end是定义函数的分隔符。return语句用于返回函数的最终输出。一个函数可以有多个返回语句。上面的函数有5个return语句，返回的都是布尔值。","category":"page"},{"location":"ch04function/#运算符","page":"函数和方法","title":"运算符","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"在前面的函数中，我们使用了几个运算符和变量。很明显，+和-是两个数之间的加减二元运算符。==是比较两个值是否相等的运算符。在Julia中，运算符被视为普通函数，它们可以返回一个值。==运算符返回布尔值，该函数仅由if条件和布尔返回值组成。我们可以用逻辑或(||)运算符的简单组合来重写这个函数。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function attacks(x1, y1, x2, y2)\n    return x1 == x2 || y1 == y2 || x1 - y1 == x2 - y2 || x1 + y1 == x2 + y2\nend\nattacks(1, 2, 4, 5) # hide\nattacks(1, 2, 4, 6) # hide","category":"page"},{"location":"ch04function/#简洁格式","page":"函数和方法","title":"简洁格式","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"尽管我们推荐使用return关键字，但Julia函数对它不是强制的。如果未指定，end语句之前的表达式的值将作为函数的返回值返回。因此，下面是前面所述函数的另一种表示:","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function attacks(x1, y1, x2, y2)\n    x1 == x2 || y1 == y2 || x1 - y1 == x2 - y2 || x1 + y1 == x2 + y2\nend\nattacks(1, 2, 4, 5) # hide\nattacks(1, 2, 4, 6) # hide","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"Julia进一步简化了函数，使其看起来更像一个数学表达式。同样的函数也可以写成:","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"attacks(x1, y1, x2, y2) = (x1 == x2 || y1 == y2 || x1 - y1 == x2 - y2 || x1 + y1 == x2 + y2)\nattacks(1, 2, 4, 5) # hide\nattacks(1, 2, 4, 6) # hide","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"上述格式只适用于函数体内只有一条语句的情况。如函数体内有多条语句，但仍想使用简洁格式，则可使用begin...end块定义复合表达式。然而，对于包含多个语句的函数，不建议使用简洁形式。下面的例子尽管是一个有效的Julia函数，但作为风格指南，还是不鼓励使用它。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"attacks(x1, y1, x2, y2) = begin\n    if x1 == x2\n        return true\n    elseif y1 == y2\n        return true\n    elseif x1 - y1 == x2 - y2\n        return true\n    elseif x1 + y1 == x2 + y2\n        return true\n    else\n        return false\n    end\nend","category":"page"},{"location":"ch04function/#匿名函数","page":"函数和方法","title":"匿名函数","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"Julia中的函数可以像任何其他对象一样赋给变量。我们可以定义一个匿名函数，并通过下面的代码赋给变量attacks_var:","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"attacks_var = (x1, y1, x2, y2) -> (x1 == y2 || y1 == y2 || x1 - y1 == x2 - y2 || x1 + y1 == x2 + y2)\nattacks_var(1, 2, 3, 4)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"attacks_var的行为类似于一个函数，但它实际上是一个变量，一个匿名函数被赋给了它，这为Julia提供了很大的灵活性。","category":"page"},{"location":"ch04function/#输入参数","page":"函数和方法","title":"输入参数","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"attacks函数有四个输入参数。函数的输入参数在Julia中也是一种数据类型，称为元组。元组是一个不可变集合，在Julia中指定逗号分隔的值时创建。它们也可以通过在圆括号中包含几个逗号分隔的值来表示。空元组可以用一个空括号表示，当元组只有一个元素时，必须在这个元素后面加一个逗号。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"1, 2\na = ()\ntypeof(a)\na = (1)\ntypeof(a)\na = (1,)\ntypeof(a)\na = (2, 3)\ntypeof(a)\na[1]\na[1] = 5","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"可以看到，元组中的元素可以通过索引进行访问。但是，它的元素不能被修改。下面是一些基于变量位置从元组对变量进行多重赋值的示例。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"i, j = 1, 2\ni\nj\ni = 1, 2 # i是一个元组\ni\ni, = 1, 2 # i是一个整数\ni","category":"page"},{"location":"ch04function/#定数量输入参数","page":"函数和方法","title":"定数量输入参数","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"如果我们用5或3个输入参数调用方法会发生什么？","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"attacks(1, 2, 3, 4, 5)\nattacks(1, 2, 3)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"报告错误，说明函数仅定义了考虑4个输入参数的情况。但是，由于在函数定义中没有指定参数类型，程序默认将参数类型设置为Any，因此该函数可以接受任何类型的输入数据。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"输入参数是可选的。下面是一个没有输入参数的函数:","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function hello_world()\n    println(\"Hello world!\")\nend\nhello_world()","category":"page"},{"location":"ch04function/#变数量输入参数","page":"函数和方法","title":"变数量输入参数","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"可以在Julia中定义接受可变数量参数(varargs)的函数。参数使用模式匹配和递归进行分配。以下是一些例子:","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"mysum(x, y...) = x + mysum(y...)\nmysum(x) = x\nmysum(1, 2)\nmysum(1, 2, 3)\nmysum(1, 2, 3, 4, 5, 6, 7)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"让我们看看另一个从输入参数计算最大值的函数。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"mymax(x, y...) = mymax(x, mymax(y...))\nmymax(x, y) = x > y ? x : y\nmymax(1, 2, 3)\nmymax(4, 10, 3, 2, 1)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"当你指定mymax(x)时会发生什么？当然，它必然给出一个错误，因为没有只接受一个参数作为输入的函数。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"mymax(1)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"它可以很容易地通过添加一个输入参数的函数来修复，如下所示:","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"mymax(x) = x\nmymax(1)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"让我们看看mymax定义了多少个方法。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"methods(mymax)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"我们有1个、2个和可变数量输入参数共3个mymax方法。","category":"page"},{"location":"ch04function/#默认值","page":"函数和方法","title":"默认值","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"让我们稍微修改一下mymax函数，这样就不需要创建单参数函数了。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"mymax(x, y...) = mymax(x, mymax(y...))\nmymax(x, y=x) = x > y ? x : y\nmethods(mymax)\nmymax(1)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"我们只引入两个函数：一个有可变数量的参数，另一个有两个参数，但其中一个带有默认值。系统内部生成了3个函数，只有一个参数的函数映射到了有两个参数但其中一个是默认值的函数。","category":"page"},{"location":"ch04function/#汇集和分散","page":"函数和方法","title":"汇集和分散","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"在函数定义中对一个输入参数使用运算符...时，其行为称为汇集。它尝试接受多个输入，并将它们表示为单个元组变量。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function test(args...)\n    println(typeof(args))\nend\ntest(1, 2, 3, 4.0)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"因为args是一个元组，所以可以通过索引来访问参数值。一些实现可以使用递归来处理变输入参数数量函数，就像我们前面定义的mymax和mysum方法一样。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"让我们回到皇后攻击函数。皇后被表示为x和y位置的元组是很自然的，例如(12)。然而，我们创建的函数有4个参数。在这种情况下，分散会有所帮助。在函数调用中，...运算符将目标集合展开，并将单个值作为函数的输入传递。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"q1 = (1, 2)\nq2 = (3, 4)\nattacks(q1..., q2...)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"虽然汇集和分散为Julia中的函数式编程提供了显著的好处，但它们不是性能友好的运算符。因此，在需要时，必须谨慎地使用它们。","category":"page"},{"location":"ch04function/#返回值","page":"函数和方法","title":"返回值","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"所有Julia函数都显式或隐式地返回一个值。我们在前面定义的各种攻击函数中看到了这些示例。一个函数可以什么都不返回吗？这样的函数仍然会返回nothing，它是一个Nothing类型的单例实例。前面介绍的hello_world()函数就是一个类似的例子。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"a = hello_world()\ntypeof(a)","category":"page"},{"location":"ch04function/#类型安全","page":"函数和方法","title":"类型安全","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"让我们再次以最初冗长的攻击函数为例，但对其进行了一些小修改。我们从函数中删除返回false的else语句。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function attacks(x1, y1, x2, y2)\n    if x1 == x2\n        return true\n    elseif y1 == y2\n        return true\n    elseif x1 - y1 == x2 - y2\n        return true\n    elseif x1 + y1 == x2 + y2\n        return true\n    end\nend\na = attacks(1, 2, 3, 4)\nb = attacks(1, 2, 3, 5)\ntypeof(a), typeof(b)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"你可能会发现在代码中使用nothing代替false是可以接受的。但是，由于可能存在类型稳定性问题，这种做法是不可取的。根据函数的输入，函数调用者可能得到Bool值或Nothing值。这种类型的不一致性可能导致调用者不能为返回值分配适当的资源，并且可能进行许多超出需要的额外分配，或者可能不得不将Any作为返回类型。我们将在性能一章中详细讨论代码性能受到类型稳定性问题影响的实例。从函数返回类型一致的返回值通常是一个好方法。其次，类型安全问题不能完全消除。它们并不总是对性能产生不利影响。Julia提供了识别它们的工具。我们稍后将详细讨论。返回类型并不是类型安全问题的唯一来源。由于Julia类型是可选的，各种输入参数以及输入参数与常量表达式的相互作用也会导致类型安全问题。我们将在性能管理一章中用实例介绍其中一部分内容。","category":"page"},{"location":"ch04function/#多返回值","page":"函数和方法","title":"多返回值","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"大多数编程语言都坚持一个函数只返回一个值。这同样适用于Julia。使用Julia的元组类型，可以返回多个值。我们将扩展攻击函数，将路径相交的原因作为另一个返回值同布尔值一起返回给我们。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function attacks_with_reason(x1, y1, x2, y2)\n    if x1 == x2\n        return true, :x\n    elseif y1 == y2\n        return true, :y\n    elseif x1 - y1 == x2 - y2\n        return true, :diag\n    elseif x1 + y1 == x2 + y2\n        return true, :xdiag\n    else\n        return false, :na\n    end\nend\nattacks_with_reason(1, 2, 3, 4)\nattacks_with_reason(1, 2, 3, 1)\nattacks_with_reason(1, 2, 3, 2)\nattacks_with_reason(1, 2, 2, 1)\nattacks_with_reason(1, 2, 1, 3)","category":"page"},{"location":"ch04function/#递归","page":"函数和方法","title":"递归","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"递归是函数式编程中常用的编程范式，在Julia中也同样流行。在递归编程中，要遵循以下过程:","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"函数应该在问题的一个子集内调用自己。\n必须有一个确定的使递归终止的条件。\n对结果进行集合以得到最终输出。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"我们将应用所有这些条件来解决8皇后问题。目前，我们已经找到了判断皇后是否会攻击其他皇后的一种机制。我们将通过递归地从上到下向每一行添加一个皇后来解决这个问题。假设我们考虑一个大小为8×8的棋盘。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"首先考虑第1行，在第1行起始列位置1上添加一个皇后。\n然后在第2行添加一个皇后。\na) 我们从列1开始不断增加列序号，直到找到一个不受其他皇后攻击的列为止。这里将使用前面开发的攻击函数来进行检验。\nb) 如果可以放置皇后，则马上放置并递归调用这个函数来检查是否可以将皇后放置在第3行、第4行、...，直到第8行。\nc) 如果放置成功，则返回函数结果，不成功则递归地转回紧邻的上一行，继续寻找下一个可以放置的列。\n如果能够在最后一行添加一个皇后，则返回true。\n如果在任意一行中添加皇后失败，则返回false。\n使用递归方法的变参数数量的函数非常有用，它提供了一种跟踪已添加的所有列的自然机制。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"所提出的方法并不局限于8皇后问题，而是可以用于N皇后问题。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"attacks(x1, y1, x2, y2) = \n       (x1 == x2 || y1 == y2 || x1 - y1 == x2 - y2 || x1 + y1 == x2 + y2)\nfunction queens(N,xs...)\n    currentrow = length(xs) + 1         # 当前要检验的行 \n    if currentrow > N                   # 如果成立，则所有行都检验成功了\n        println(\"Final Positions: \",xs) # 按行打印最终列位置\n        return true                     # 返回成功解决问题\n    end\n    for i = 1:N                         # 检验每一列\n        res = false                     # 初始设置皇后不相互攻击\n        for j = 1:currentrow-1          # 对当前行与前面以完成的各行进行攻击检验\n            (res = attacks(currentrow, i, j, xs[j])) && break # 对当前行的i列与前面各行进行攻击检验，攻击返回true并结束检验，不攻击返回false并继续检验直到所有行都检验完毕\n        end\n        res && continue                 # 攻击，则检验当前行的下一列\n        v = queens(N,xs...,i)           # 不攻击，则将该列（按顺序首先找到的可行列）加到列位置列表中，并继续对下一行进行检验，返回成功与否\n        v && return v                   # 成功则返回，不成功则在当前行寻找下一个不攻击的可行列\n    end\n    return false                        # 所有列都检验完，仍找不到可行列，则返回失败\nend\nqueens(8)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"作为递归的一部分，可以在函数调用的开头添加println语句来观察变数量参数的行为。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function queens(N,xs...)\n    println(xs)\n    currentrow = length(xs) + 1     \n    # ...    \n    if currentrow > N                   # hide\n        println(\"Final Positions: \",xs) # hide\n        return true                     # hide\n    end                                 # hide\n    for i = 1:N                         # hide\n        res = false                     # hide\n        for j = 1:currentrow-1          # hide\n            (res = attacks(currentrow, i, j, xs[j])) && break # hide\n        end                             # hide\n        res && continue                 # hide\n        v = queens(N,xs...,i)           # hide\n        v && return v                   # hide\n    end                                 # hide\n    return false                        # hide\nend                                     # hide\nqueens(8)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"程序得到的解如下图所示。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"(Image: solution)","category":"page"},{"location":"ch04function/#多分派和多态","page":"函数和方法","title":"多分派和多态","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"在面向对象的编程中，通常只有单分派和多态，而没有多分派。多态被用来描述基于方法所操作的对象的行为的改变。简单地说，area在矩形对象和三角形对象上使用的计算方法是不同的。在前面的例子中，我们看到函数的行为因参数的数量不同而不同。本节，我们将看到函数可以根据参数的类型表现出不同的行为。在Julia中，当同名函数根据参数的类型和个数具有不同的行为时，它们被称为方法。","category":"page"},{"location":"ch04function/#数据类型","page":"函数和方法","title":"数据类型","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"下面的示例显示了两个area函数：一个用于Triangle类型，另一个用于Rectangle类型。由于这两个形状都是父抽象类型Shape的子类型，我们可以修改默认的show方法，以便从show方法中调用相关的area函数。Base.show是在REPL中显示对象时调用的默认方法。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"abstract type Shape end\nstruct Rectangle <: Shape\n    w::Float32\n    h::Float32\nend\nstruct Triangle <: Shape\n    a::Float32\n    b::Float32\n    c::Float32\nend\narea(r::Rectangle) = r.w*r.h\nfunction area(t::Triangle)\n    a, b, c = t.a, t.b, t.c\n    s = (a + b + c)/2\n    return sqrt(s*(s-a)*(s-b)*(s-c))\nend\nr, t = Rectangle(3, 4), Triangle(3, 4, 5)\narea(r)\narea(t)\nBase.show(io::IO, s::Shape) = print(io, \"Shape Type: \", typeof(s), \" Area: \", area(s))\nr\nt\nmethods(show, (IO,Union{Shape,Rectangle,Triangle}))\nmethods(area)","category":"page"},{"location":"ch04function/#多分派","page":"函数和方法","title":"多分派","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"在典型的面向对象语言中，方法与对象相关联。根据对象类型调用特定的函数。这种方法分派是作为单分派接口调用的。然而，支持多分派接口的语言不会将函数关联到特定类型上。根据对象运行时的类型，函数解析到相应的方法接口并调用最相关的方法。area方法不是矩形类型或三角形类型的方法，而是根据对象类型从多分派查询表中查找得到的。另外，从上面的例程可以看到，对于Rectangle和Triangle两种不同的类型，show只定义了一种方法，这称为多态，实际上，上述show方法的多态性是通过对area函数进行多分派来实现的。","category":"page"},{"location":"ch04function/#构造函数","page":"函数和方法","title":"构造函数","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"对象可以有内在的约束，在创建它们时，必须强制执行，以避免创建无效对象。构造函数可实现这个目的。在矩形或三角形的类型定义中，可通过构造函数来避免当边为负值时创建无效对象。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"struct RectangleA\n    w::Float32\n    h::Float32\n    function RectangleA(w::Real, h::Real)\n        (w > 0 && h > 0) || error(\"invalid rectangle with non-positive h or w\")\n        return new(w,h)\n    end\nend","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"创建对象现在调用定义的构造函数。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"a = RectangleA(1.0,-4.0)\na = RectangleA(1//5, 4//5)\na = RectangleA(1, 4)\na = RectangleA(1.0, 4.0)\na = RectangleA(1.0, 4)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"构造函数可以接受任何实数作为输入参数，并确保不允许非正数作为实参的一部分。假设我们要创建两个额外的构造函数来构造正方形。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"RectangleA(a=1.0) = RectangleA(a, a)\nRectangleA()\nRectangleA(2.0)\nmethods(RectangleA)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"我们用一条语句创建了两个构造函数，其中一个是由于默认实参而创建的。现在可以看到创建了3个构造函数，其中两个是在类型定义之外声明的外部构造函数。一个是在类型定义中声明的内部构造函数。创建内部构造函数是为了确保构造约束得到强制执行。使用外部构造函数主要是为了方便和提供构造灵活性。如果没有提供构造函数，则自动产生默认构造函数来初始化该类型的属性。在前面的RectangleA示例中，当没有定义其他内部构造函数时，将创建以下默认的内部构造函数：","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"RectangleA(h::Float32, w::Float32)=new(h,w)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"new函数是一个只能在内部构造函数中使用的特殊函数。它以定义中的顺序初始化参数来创建对象。","category":"page"},{"location":"ch04function/#返回值-2","page":"函数和方法","title":"返回值","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"构造函数必须返回一个初始化良好的对象。在Julia中，期望在对构造函数的调用结束时得到正确初始化的对象。虽然在某些情况下，由于性能原因，复合对象可能不被初始化，但这种情况通常是一个特例。构造函数必须返回一个它试图构造的类型的对象。","category":"page"},{"location":"ch04function/#参数化数据类型","page":"函数和方法","title":"参数化数据类型","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"在前面讨论参数化数据类型时，我们没有详细说明它们对函数和分派接口或构造函数的影响。在下面创建的RectangleB类型中，我们希望使用任何Real类型作为矩形属性的参数类型。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"struct RectangleB{T <: Real}\n    w::T\n    h::T\nend\nRectangleB(2//3, 1//4)\nRectangleB(1f0, 2f0)\nRectangleB(2//3, 1f0)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"默认构造函数RectangleB(::T, ::T) where T<:Real被创建，但T只能是同一种特定的类型。它不能同时是Rational{Int64}和Float32。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"RectangleB{Int}('a', 1f0)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"但是，当我们显式地指定参数类型作为构造函数的一部分时，类型可以被正确地转换。","category":"page"},{"location":"ch04function/#分派接口","page":"函数和方法","title":"分派接口","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"让我们创建两个方法，aspect_ratio和area。比率是矩形的宽高比。面积是矩形的高度与宽度的乘积。在前面的示例中我们已经看到了area方法的实现。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"area(r::RectangleB) = r.w*r.h\naspect_ratio(r::RectangleB) = r.w/r.h\nr1, r2, r3= RectangleB(1//2, 2//3), RectangleB(1.5, 0.5), RectangleB(1, 2)\narea(r1), area(r2), area(r3)\naspect_ratio(r1), aspect_ratio(r2), aspect_ratio(r3)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"根据矩形的参数类型，area函数返回的值是Rational{Int}和Int，但在aspect_ratio函数中似乎忽略了这个规则。运算符/是一个浮点除法运算符。Julia中的有理或除法运算符是//。让我们为aspect_ratio建立一个针对于整数和有理数类型的方法。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"aspect_ratio(r::RectangleB{T}) where T<:Union{Integer, Rational} = r.w//r.h\naspect_ratio(r1), aspect_ratio(r2), aspect_ratio(r3)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"显然，Rational和Integer类型的方法被分派到了新方法，而其他数字类型(如Float64)则被分派到了旧方法。T<:Union{Integer, Rational}本质上意味着类型可以从Integer或Rational类型上派生出来。联合在Julia中广泛用于表示多个类型中的一个。你也可以像下面的例子一样使用3种方法，而不是使用联合。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"aspect_ratio(r::RectangleB{T}) where T<:Integer = r.w//r.h\naspect_ratio(r::RectangleB{T}) where T<:Rational = r.w//r.h","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"重点是要从参数类型中子类型之间的关系的角度来理解分派规则。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"RectangleB{Rational{Int}} <: RectangleB{Rational}\nRectangleB{Rational{Int}} <: RectangleB\nRectangleB{Rational} <: RectangleB","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"子类型关系仅与直接参数类型相关。RectangleB{Rational{Int}}不是RectangleB{Rational}的子类型，而是RectangleB的子类型。","category":"page"},{"location":"ch04function/#类型互动","page":"函数和方法","title":"类型互动","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"让我们看看以下的一些例子：","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"1f0 + 2\n1f0 + 2.0","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"我们将Int类型与Float32类型相加，返回的结果是一个Float32。类似地，我们将Float32与Float64相加，结果得到一个Float64。所有这些似乎都很自然。似乎Int被提升为Float32，然后执行加法运算。与其他编程语言不同，Julia的类型提升不是隐式的。任何类型的转换都需要显式地执行。Julia核心库内部定义了许多这样的规则，这些规则被显式地调用，结构就是我们看到的这些无缝转换。","category":"page"},{"location":"ch04function/#转换","page":"函数和方法","title":"转换","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"初始化任何值的典型方法是通过构造函数。例如，你可以通过指定Int(1.0)将像1.0这样的整型浮点值转换为Int。但是，Int(1.5)会抛出一个InexactError。在大多数情况下，这是由程序员显式地调用来实现的。但是，有时转换是通过隐式调用来实现的。在这种情况下，调用convert(T, x)。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function f()\n    i::Int = 0\n    i = 1.5\n    return i\nend\nf()","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"i是定义为Int类型的变量。当将值1.5赋给它时，将调用convert方法，从而抛出InexactError。对于数值类型，convert方法调用T(x)或构造函数，在本例中为Int64(1.5)。前面的RectangleB示例可显示更详细的情况。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"RectangleB{Int}('a', 1.0)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"在这种情况下，RectangleB{Int}作为构造函数提供，convert(Int, 'a')和convert(Int, 1.0)被隐式调用，Char和Float64被转换为Int。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"RectangleB{Int}(\"abc\", 1.0)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"不存在从String到Int的转换方法导致了构造函数失败。","category":"page"},{"location":"ch04function/#提升","page":"函数和方法","title":"提升","text":"","category":"section"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"让我们再看看RectangleP类型。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"struct RectangleP{T <: Real}\n    w::T\n    h::T\nend","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"当没有指定构造函数时，将定义一个默认构造函数，如下所示：","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"struct RectangleP{T<:Real}\n    w::T\n    h::T\n    RectangleP(w::T, h::T) where T<:Real = new{T}(w, h)\nend\nRectangleP(1, 2.0)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"RectangleP(1, 2.0)失败。有办法解决这个问题吗？","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function RectangleP(w::T1, h::T2) where {T1<:Real, T2<:Real}\n    w1, h1 = promote(w, h)\n    return RectangleP(w1, h1)\nend\nRectangleP(1, 2.0)","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"我们定义了一个支持两个形参的外部构造函数。参数从Real中派生出来，但可以彼此不同。我们对参数调用promote方法来获得提升了的函数参数，然后根据提升的参数创建RectangleP。上面例子的情况是，在Int和Float64的提升中，Float64将是提升的类型。这种行为在下面的例子中会清楚地展现。假设我们要确定能同时塞入两个RectangleP对象的一个RectangleP的尺寸限制（假设矩形不旋转）。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"function minrect(r1::RectangleP, r2::RectangleP)\n    w = r1.w < r2.w ? r1.w : r2.w\n    h = r1.h < r2.h ? r1.h : r2.h\n    return RectangleP(w, h)\nend\nminrect(RectangleP(1, 2), RectangleP(2.0, 0.5))\nminrect(RectangleP(1, 2), RectangleP(3.0, 4.0))","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"虽然前面的代码没有错，但你可能已经注意到函数基于输入数据会返回一个RectangleP{Float64}或RectangleP{Int}的情况。从类型稳定性的角度来看，这绝对是不可取的。当RectangleP{Float64}和RectangleP{Int}相互作用时，我们可以创建一个Base.promote_rule以便产生正确的提升。","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"Base.promote_rule(::Type{RectangleP{T}}, ::Type{RectangleP{S}}) where {T<:Real, S<:Real} = RectangleP{promote_type(S, T)}\nBase.convert(::Type{RectangleP{T}}, x::RectangleP{S}) where {T<:Real, S<:Real} = S === T ? x : RectangleP(T(x.w), T(x.h))\nfunction minrect(tr1::RectangleP, tr2::RectangleP)\n    r1, r2 = promote(tr1, tr2)\n    w = r1.w < r2.w ? r1.w : r2.w\n    h = r1.h < r2.h ? r1.h : r2.h\n    return RectangleP(w, h)\nend\nminrect(RectangleP(1,2), RectangleP(3.0,4.0))","category":"page"},{"location":"ch04function/","page":"函数和方法","title":"函数和方法","text":"为了保持一致，我们必须确保提升产生一致的类型。因为对Float64和Int64提升的结果是Float64，所以我们希望确保RectangleP{Float64}和RectangleP{Int}之间的提升得到RectangleP{Float64}。其次，我们创建一个转换方法来将RectangleP{S}转换为RectangleP{T}。当在minrect中调用promote时，会在内部调用promote_rule和convert方法。数据被转换为RectangleP{Float64}。因此，最终的返回类型将是RectangleP{Float64}。","category":"page"},{"location":"ch03controlflows/#控制流","page":"控制流","title":"控制流","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"分支和循环等控制流是命令式编程风格的核心。作为一种多范式编程语言，Julia支持所有知名的命令式风格和结构。","category":"page"},{"location":"ch03controlflows/#复合语句","page":"控制流","title":"复合语句","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"语句是程序员给计算机下达的命令。如打印一段文字，或给一个变量赋初值。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"println(\"Hello, world!\")\na = 10.0","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"Julia每次只能执行一条语句。如果需要把多条语句作为一个大型的复合执行单元（如同一条语句）来看待，则可以使用begin和end块将任意语句集包围起来。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"z = begin\n    x = 1\n    y = 2\n    x + y\nend\nz","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"块中最后一个表达式的值作为复合块的值。同样的表达式可以在单行中写成使用大括号包围的由分号分隔的语句集。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"z = (x = 1; y = 2; x + y)","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"下面也是有效的复合语句。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"z = (x = 1;\n    y = 2;\n    x + y)\nz = begin x=1; y=2; x+y end","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"由上可见，要在单行中编写多条语序，需要使用;将每条语句分隔开来。另外，Julia是通过最小语义单元来判断输入的内容是否是单行的，而不是通过回车换行来判断。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"a =\n1","category":"page"},{"location":"ch03controlflows/#注释","page":"控制流","title":"注释","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"随着程序越来越长，越来越复杂，阅读起来也变得更加困难。因此，通过对程序增加笔记来说明它到底做了些什么是一个非常明智的方法。这些笔记被称为注释，它们以 # 号开头：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"# 计算已用时间的百分比（总时长是60分）\npercentage = (20 * 100) / 60","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"在这个例子中，注释独占一行。你也可以将注释放到一行的末尾：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"percentage = (20 * 100) / 60  # 已用时间的百分比","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"# 号以后的所有内容都被程序忽略掉——它对程序的执行不起任何作用。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"当我们写的注释需要连续占用很多行，这时在每行的开头都使用#会很麻烦。还有一种情况，我们可能需要在同一行的一条语句的中间插入注释，这时#会完全失效（因为#以后的内容被全部忽略），Julia提供的另一种注释方法#=...=#可以解决这类问题。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"#= 一行注释\n   另外一行注释\n=#\nv = 5   \nb = #=在中间插入注释=# 3.2","category":"page"},{"location":"ch03controlflows/#分支","page":"控制流","title":"分支","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"条件语句是编程语言的核心。它们提供了在代码中定义分支的途径，并且是迭代编程的基础。使用本地goto进行分支足以模拟编程语言中的任何迭代模型。","category":"page"},{"location":"ch03controlflows/#if...else","page":"控制流","title":"if...else","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"if...else是Julia中最常见的条件执行形式。一个典型的if条件如下所示:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"if <Boolean condition>\n    # do something\nelse\n    # do the something else\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"else部分是可选的。条件必须是布尔值。与布尔值true或false相同的整数不能代替对应的布尔值。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"if 1\n    println(\"Integer is good for Bool\")\nend\nif Bool(1)\n    println(\"Bool now\")\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"if表达式返回被执行分支的值。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"i = 1\nstr = if i > 1\n    \"Greater\"\nelse\n    \"Less\"\nend\nstr","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"同样的表达式也可以用三元运算符?和:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"str = i > 1 ? \"Greater\" : \"Less\"\nstr","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"虽然在大多数表达式中可以不使用空格，但在?和:两侧的空格则是必须的。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"julia> str = i > 1? \"Greater\" : \"Less\"\nERROR: syntax: space required before \"?\" operator\n\njulia> str = i > 1 ? \"Greater\": \"Less\"\nERROR: syntax: space required before colon in \"?\" expression","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"当遇到多重分支操作时，可使用if...elseif...else结构。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"val = 3\nif val == 1\n    \"one\"\nelseif val == 2\n    \"two\"\nelseif val == 3\n    \"three\"\nelseif val == 4\n    \"four\"\nelse\n    \"unknown\"\nend","category":"page"},{"location":"ch03controlflows/#非结构分支","page":"控制流","title":"非结构分支","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"诸如if...elseif...else的结构分支，是编程语言中条件执行的最优选择。然而，一些语言具有goto语句来将执行分支跳转到代码中的特定位置。Julia也使用宏@goto和@label提供了这样的功能。它们有以下限制:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"它们被限制在特定的代码块中。@goto可以在同一代码块中使用@label。\n它们不能跨函数使用。\n它们会影响代码的可读性。因此，通常在大多数结构化编程语言中不使用。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"Julia具有结构化分支和迭代，因此完全可以不使用非结构化分支。下面的代码仅是使用@goto和@label来对从1到10的连续数进行求和的示例:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"begin\n    s = 0\n    n = 10\n    @label loop\n    s = s + n\n    n = n - 1\n    if n > 0\n        @goto loop\n    end\n    s\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"显然，对于序列求和，迭代要比非结构化分支简单得多。","category":"page"},{"location":"ch03controlflows/#短路求值","page":"控制流","title":"短路求值","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"Julia中的&&和||运算符分别对应逻辑“和”和“或”运算。此外，它们还有一个附加的短路求值属性：它们不一定对第二个参数求值(也有按位的&和|运算符，可以用作逻辑的“和”和“或”，它们不具有短路行为，但要注意&和|的优先级高于&&和||)。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"短路求值与条件求值非常相似：在由这些运算符连接的一系列布尔表达式中，整个链的最终布尔值由计算最小数量的表达式来确定。这意味着：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"在表达式a && b中，子表达式b仅在a的计算结果为true时才被计算。\n在表达式a || b中，子表达式b仅在a的计算结果为false时才计算。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"理由是：如果是a是false，不管b的值如何，a && b必是false。同样，如果是a是true，不管b的值如何，a || b必是true。&&和||都是右结合的，但&&的优先级高于||。验证这种行为的方法很容易：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"t(x) = (println(x); true)\nf(x) = (println(x); false)\nt(1) && t(2)\nt(1) && f(2)\nf(1) && t(2)\nf(1) && f(2)\nt(1) || t(2)\nt(1) || f(2)\nf(1) || t(2)\nf(1) || f(2)","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"可以很容易地以同样的方式验证&&和||运算符各种组合的结合性和优先级。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"这种行为在Julia中经常被用来代替非常简短的if语句。if <条件> <语句> end可以写成<条件> && <语句>（可以读作：<条件>成立则执行<语句>）。类似地，if !<条件> <语句> end可以写成<条件> || <语句>可以读作：<条件>成立否则执行<语句>）。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"例如，一个递归的阶乘可以这样定义：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"function fact(n::Int)\n    n >= 0 || error(\"n must be non-negative\")\n    n == 0 && return 1\n    n * fact(n-1)\nend\nfact(5)\nfact(0)\nfact(-1)","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"不需要短路求值的布尔运算可以通过按位布尔运算符来完成：&和|。它们是普通函数，支持中缀运算符语法，总是对实参进行求值计算：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"f(1) & t(2)\nt(1) | t(2)","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"就像if、elseif或三元运算符中使用的条件表达式一样，&&或||的运算数必须是布尔值(true或false)。在条件链中除了最后一项的任何地方使用非布尔值都是错误的：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"1 && true","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"另一方面，可以在条件链的末尾使用任何类型的表达式。它将根据前面的条件被计算和返回：","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"true && (x = (1, 2, 3))\nfalse && (x = (1, 2, 3))","category":"page"},{"location":"ch03controlflows/#迭代","page":"控制流","title":"迭代","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"虽然我们可以使用非结构化分支goto实现代码的迭代执行，但作为一种高级语言，Julia提供了迭代执行的特定语言结构。最常见的是for和while。","category":"page"},{"location":"ch03controlflows/#for","page":"控制流","title":"for","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"s = 0;\nfor i = 1:10\n    s = s + i\nend\ns","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"在上面的代码片段中，我们从1枚举到10，并将值累加到s。在for循环中，我们将一个步长为1的范围对象1:10赋给参数i。该对象也可以写成1:1:10，表示<初始值>:<步长>:<最终值>。现在，我们修改代码，使其只对奇数进行累加。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"s = 0;\nfor i = 1:2:10\n    println(i)\n    s = s + i\nend\ns","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"可以看出，将范围对象的步长更改为2就可以达到预期的结果。","category":"page"},{"location":"ch03controlflows/#continue和break","page":"控制流","title":"continue和break","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"让我们在求和时忽略所有能被3整除的数。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"s = 0;\nfor i = 1:10\n    if i % 3 == 0\n        continue\n    end\n    println(i)\n    s = s + i\nend\ns","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"在这种情况下，continue用于跳过所有能被3整除的数。continue确保在迭代器仍处于活动状态时，表达式后面的代码块被排除在计算之外，而在代码中使用break将终止循环。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"s = 0;\nfor i = 1:10\n    if i % 3 == 0\n        break\n    end\n    println(i)\n    s = s + i\nend\ns","category":"page"},{"location":"ch03controlflows/#for...in","page":"控制流","title":"for...in","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"除了范围对象，for也可以与其他具有迭代器功能的序列对象一起使用。我们将在后面详细讨论迭代器接口。下面是一个for...in语法的代码片段。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"for i in [5,10,15]\n    println(i)\nend","category":"page"},{"location":"ch03controlflows/#多范围对象","page":"控制流","title":"多范围对象","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"一个for循环可以遍历多个范围对象。效果是在由左侧指定外层循环的范围的笛卡尔积上迭代。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"for i=1:3, j=1:2\n    println((i,j))\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"内部范围也可以受外部范围值的影响。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"for i=1:3, j=1:i\n    println((i, j))\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"这里的for循环是一个单独的循环，break语句可以完全终止它，这与嵌套的for循环只终止内部循环不同。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"for i=1:3, j=1:2\n    println((i, j))\n    if i == j\n        break\n    end\nend\nfor i=1:3\n    for j=1:2\n        println((i, j))\n        if i == j\n            break\n        end\n    end\nend","category":"page"},{"location":"ch03controlflows/#while","page":"控制流","title":"while","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"在Julia中，for用于迭代器和范围对象。while则更灵活，可以在任何条件下发挥作用。只要条件为真，循环就会继续执行。下面是一般语法。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"while <Boolean_condition is true>\n    <loop>\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"现在，如果我们考虑相同的1-10的加法例子，那么代码将如下所示:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"s, n = 0, 10;\nwhile n > 0\n    s = s + n\n    n = n - 1\nend\ns","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"与for循环类似，可以分别通过continue和break来跳过或终止执行。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"while循环重复计算起始处的条件，如果结果为true，则执行循环。在某些情况下，存在不管条件如何，都需要至少执行一次的循环，并在循环结束时计算新的条件来判断是否继续执行循环。这相当于其他语言中的do...while循环。Julia目前没有这个构造。但实现这个语义逻辑却很简单。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"julia> println(\"press q <enter> to end loop\")\npress q <enter> to end loop\n\njulia> while true\n           ch = readline()\n           ch == \"q\" && break\n       end\na\nq","category":"page"},{"location":"ch03controlflows/#异常处理","page":"控制流","title":"异常处理","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"当程序出现异常时，执行的函数可能无法返回一个有效值或使程序处于可恢复状态。有些程序可能会报告错误并终止执行。然而，在报告异常情况的同时，使程序恢复状态是非常有益的。其次，恢复的状态一定在函数调用的多个深度的调用堆栈中。因此，异常可能导致控制流移动到调用堆栈中的另一个函数，而不仅仅是调用方的地址空间。","category":"page"},{"location":"ch03controlflows/#try...catch","page":"控制流","title":"try...catch","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"将预期具有异常条件的代码放置在try之后。异常处理代码添加到catch之后的部分。end表达式结束try块。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"try\n    sqrt(-1)\ncatch e\n    println(e)\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"没有try...catch块的代码将在REPL中报告以下内容:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"sqrt(-1)","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"可以看到，REPL提供了默认的try...catch实现，它接受DomainError异常并打印一个带有堆栈跟踪的错误。Julia有相当多的标准异常，如ErrorException、DomainError、ArgumentError、BoundsError等。所有错误都派生自抽象类型Exception。","category":"page"},{"location":"ch03controlflows/#throw/rethrow","page":"控制流","title":"throw/rethrow","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"虽然catch提供了捕获异常并对异常采取操作的选项，但人们可以利用rethrow函数使异常进一步传播，而不是处理它。打印的错误信息是REPL默认的错误处理方法。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"try\n    sqrt(-1)\ncatch e\n    rethrow()\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"当出现一些意外的条件时，还可以抛出自定义异常。抛出的对象不一定总是Exception类型。它可以是任何对象。下面给出了一个抛出整数的例子:","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"try\n    throw(1)\ncatch e\n    println((e,typeof(e)))\nend","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"异常用于管理异常条件。如果行为只是代码流中的常规条件的表示，应使用其他控制流如if...else。其次，异常会增加大量的执行开销。因此，只有在需要时才有选择地使用它们。","category":"page"},{"location":"ch03controlflows/#finally","page":"控制流","title":"finally","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"当资源正在使用时，异常情况可能会迫使函数突然退出执行，这种情况下的资源无法回收。finally子句代码在正常和异常条件下都会被执行，确保资源被回收。在下面的示例中，即使出现异常，文件句柄f也会关闭。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"f = open(\"/etc/hosts\")\nisopen(f)\ntry\n    b = write(f,\"abc\")\ncatch e\n    println(e)\nfinally\n    close(f)\nend\nisopen(f)","category":"page"},{"location":"ch03controlflows/#异常的信息","page":"控制流","title":"异常的信息","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"因为每次堆栈展开时都需要验证异常对象，因此它们会影响执行速度。那么，如此复杂架构的异常对象为程序添加了什么价值？它们提供的主要优势之一是能够跟踪异常发生的堆栈。因此，可以得到错误的传播轨迹。其次，异常对象的形式提供了关于了解错误足够信息的能力。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"julia> sqrt(-1)\nERROR: DomainError with -1.0:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n [1] sqrt\n   @ ./math.jl:582 [inlined]\n [2] sqrt(x::Int64)\n   @ Base.Math ./math.jl:608\n [3] top-level scope\n   @ REPL[73]:1","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"DomainError有两个属性。val属性表示导致错误的值，msg属性详细描述消息细节。你可以通过创建Exception抽象类型的子类型来定义自己的异常。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"struct MyException <: Exception\n    params1\n    params2\n    # ...\n    paramsn\nend","category":"page"},{"location":"ch03controlflows/#堆栈跟踪","page":"控制流","title":"堆栈跟踪","text":"","category":"section"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"堆栈跟踪是从异常处理中获得的一组非常重要的信息。函数catch_backtrace()在抛出异常时报告堆栈跟踪，而stacktrace()函数提供了对前面函数返回结果的解释。","category":"page"},{"location":"ch03controlflows/","page":"控制流","title":"控制流","text":"julia> try\n           sqrt(-1)\n       catch e\n           stacktrace(catch_backtrace())\n       end\n3-element Vector{Base.StackTraces.StackFrame}:\n sqrt at math.jl:582 [inlined]\n sqrt(x::Int64) at math.jl:608\n top-level scope at REPL[76]:2","category":"page"},{"location":"ch06datacollection/#数据集","page":"数据集","title":"数据集","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"每种编程语言都提供了一定的最小数量的数据结构集来将多个数据元素表示为容器。即数组、字典、集合和元组，等等。","category":"page"},{"location":"ch06datacollection/#预定义数据结构","page":"数据集","title":"预定义数据结构","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"1975年，Niklaus Wirth，一个著名的计算机专家和编程语言PASCAL的作者写了一本书：算法+数据结构=程序。明确强调了数据结构和算法在编程中的重要性。几乎没有任何现代编程语言不提供对数据结构的内建支持，Julia也不例外。许多数据结构是在Julia核心语言中定义的，而更广泛的数据结构是在像DataStrctures.jl这样的包中定义的。在本章中，我们重点介绍该语言在不需要使用任何附加包的情况下定义的数据结构，如：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"元组\n数组\n字典\n集合","category":"page"},{"location":"ch06datacollection/#元组","page":"数据集","title":"元组","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"元组在Julia中非常常见，以至于我们经常不把它们作为一种专门的数据结构来看待。在前面，我们介绍了元组的一些属性，下面将进行更详细的介绍。以下是它的功能概要：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"不变性\n异构性\n可在模式匹配中使用\n可通过索引访问元素","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"下面是一些例子：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"a = (1, \"string\", 1.0)\ntypeof(a)                   # 异构性\na[1]                        # 通过索引访问\na[1] = 6                    # 不变性\nb, c = a                    # 模型匹配\nb\nc","category":"page"},{"location":"ch06datacollection/#NTuple","page":"数据集","title":"NTuple","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"NTuple{N, T}是具有N个类型为T的元组的参数定义。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"NTuple{3, Int}","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"你可以像这样创建一个接受元组参数的方法：写成f(::NTuple{3, Int})而不要写成f(::Tuple{Int64, Int64, Int64})。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"当你希望创建一个包含特定模式的N个参数的元组时，可以使用函数ntuple。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"a = ntuple(x->4, 10)\ntypeof(a)\na = ntuple(i->i*1.0, 10)\ntypeof(a)","category":"page"},{"location":"ch06datacollection/#作为集的元组","page":"数据集","title":"作为集的元组","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Tuple可以作为元素集使用。这意味着它们可以被迭代，拥有集的典型函数，如length。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"length(a)\nfor i = 1:length(a)\n    println(a[i])\nend","category":"page"},{"location":"ch06datacollection/#作为类型参数的整数","page":"数据集","title":"作为类型参数的整数","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"观察NTuple类型的一个发现是，它有一个作为类型的整数参数。这同样适用于任何可变或不可变类型。让我们创建一个Point类型，它可以被用于2或3维情况。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"struct Point{N}\n    data::NTuple{N, Float32}\n    Point(d...)=new{length(d)}(d)\nend\nconst Point2D = Point{2}\nconst Point3D = Point{3}\nfunction dist(p1::Point2D, p2::Point2D)\n    dx, dy = (p1.data[1] - p2.data[1], p1.data[2] - p2.data[2])\n    return sqrt(dx*dx+dy*dy)\nend\nfunction dist(p1::Point3D, p2::Point3D)\n    dx, dy, dz = (p1.data[1] - p2.data[1],\n                  p1.data[2] - p2.data[2],\n                  p1.data[3] - p2.data[3])\n    return sqrt(dx*dx+dy*dy+dz*dz)\nend\ndist(Point(1, 2), Point(3, 4))\ndist(Point(1, 2, 3), Point(3, 4, 5))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"在前面的例子中，我们定义了Point{N}的别名Point2D和Point3D，为这两种类型定义了两个dist函数，并确保可以基于整数值2或3进行分派。Point{2}和Point{3}是两种不同的类型。由于NTuple是集类型，我们可以使用dist方法来处理Point{N}。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"struct Point{N}\n    data::NTuple{N, Float32}\n    Point(d...)=new{length(d)}(d)\nend\nfunction dist(p1::Point{N}, p2::Point{N}) where N\n    sumval = 0f0\n    for i=1:N\n        d = p1.data[i] - p2.data[i]\n        sumval += d*d\n    end\n    return sqrt(sumval)\nend\ndist(Point(1, 2), Point(3, 4))\ndist(Point(1, 2, 3), Point(3, 4, 5))\ndist(Point(1f0, 2f0, 3f0), Point(1, 2))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"如果我们不使用参数形式的Point{N}，而是使用Point，会是错误的吗？Point{2}和Point{3}是两种不同的类型。dist函数会为两种不同的类型分别编译吗？我们可以试一下。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"struct Point{N}\n    data::NTuple{N, Float32}\n    Point(d...)=new{length(d)}(d)\nend\nfunction dist(p1::Point, p2::Point)\n    N = length(p1.data)\n    sumval = 0f0\n    for i = 1:N\n        d = p1.data[i] - p2.data[i]\n        sumval += d*d\n    end\n    return sqrt(sumval)\nend\ndist(Point(1, 2),Point(3, 4))\ndist(Point(1, 2, 3), Point(3, 4, 5))\ndist(Point(1f0, 2f0, 3f0), Point(1, 2))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"现在，我们可以将Point{2}和Point{3}参数传递给同一个函数。这说明只创建了一个方法，没有为Point{2}和Point{3}版本编译两个方法。那个方式是正确的？这是一个设计决策，而不是编程语言的概念。Point2D和Point3D是可混合使用的吗？我们需要支持Point{N1}和Point{N2}的混合dist`方法吗？如果是，则下面是一种可能的实现方法。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"struct Point{N}\n    data::NTuple{N, Float32}\n    Point(d...)=new{length(d)}(d)\nend\nfunction dist(p1::Point{N}, p2::Point{N}) where N\n    sumval = 0f0\n    for i=1:N\n        d = p1.data[i] - p2.data[i]\n        sumval += d*d\n    end\n    return sqrt(sumval)\nend\nfunction dist(p1::Point{N1}, p2::Point{N2}) where {N1, N2}\n    N1 > N2 && return dist(p2, p1)\n    tp = Point(p1.data..., ntuple(i->0f0, N2-N1)...)\n    return dist(tp, p2)\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"我们为具有相同维数N的Point{N}创建了一个方法。\n然后我们创建了一个方法，可以输入不同维度的点。\n这里，我们假设第一个参数的维度小于第二个参数。\n如果第一个参数不小于第二个参数，我们通过翻转参数来调用方法。从而确保第一个参数的维数小于第二个(N1 < N2)。\n我们创建一个与p2维度相同的临时点(tp)，方法是向更高维度填充零，并调用dist(tp, p2)。","category":"page"},{"location":"ch06datacollection/#值参数","page":"数据集","title":"值参数","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"让我们看看下面的代码控制流：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"if val == 1\n    f1()\nelseif val == 2\n    f2()\nelseif val == 3\n    f3()\nelse\n    f4()\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"这些函数是否可以使用多分派而不是使用if...elseif...else？","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"struct MyVal{N}\n    MyVal(N)=new{N}()\nend\nf(::MyVal{N}) where N = N\nfunction f(::MyVal{1})\n    println(\"Called from 1\")\nend\nf(MyVal(2))\nf(MyVal(1))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"MyVal{N}基于N的值定义类型。\n方法f适用于MyVal{N}的所有值。\n仅为MyVal{1}定义了一个专用方法f。\n现在f(MyVal(2))调用一般方法，f(MyVal(1))调用特定方法。","category":"page"},{"location":"ch06datacollection/#单例","page":"数据集","title":"单例","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"当类型中没有属性时，只会为它创建一个对象。这样的对象称为单例。上面创建的值类型也是一个单例，因为该类型没有属性。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"MyVal(1) === MyVal(1)\nMyVal(1) === MyVal(2)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"MyVal{1}与MyVal{2}是不同的类型。因此，由初始化创建的对象是两个不同的对象。Julia虽然可以使用值参数，但它可能不是性能最优的方法。Julia内置提供了符合以上所有原则的Val{N}类型，我们将在Julia的性能管理一章中进一步讨论这个问题。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"note: Note\n不仅整数类型，即使符号也可以用作值类型参数。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"MyVal(:a)","category":"page"},{"location":"ch06datacollection/#范围","page":"数据集","title":"范围","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"有时我们需要增加或减少的具有连续或固定步长的数字。这称为范围。下面是一些例子：","category":"page"},{"location":"ch06datacollection/#UnitRange","page":"数据集","title":"UnitRange","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"a=1:5\ntypeof(a)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"a是一个UnitRange，这意味着它包含从1到5的所有数字。UnitRange的增量步长总是1。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"for i=a\n    println(i)\nend","category":"page"},{"location":"ch06datacollection/#StepRange","page":"数据集","title":"StepRange","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"b=1:2:5\ntypeof(b)\nfor i=b\n    println(i)\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"b是一个间隔为2的StepRange。","category":"page"},{"location":"ch06datacollection/#降序范围","page":"数据集","title":"降序范围","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"c=5:-1:1\ntypeof(c)\nfor i=c\n    println(i)\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"c是步长为-1的StepRange。所以在迭代时，我们按5到1的递减顺序输出。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"范围用于迭代、索引和初始化集。它们可以有更复杂的参数，也可以将浮点数用于初始值、步长和最终值。下面给出一个浮点值范围的例子。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"d=1:2.1:6.0\ntypeof(d)","category":"page"},{"location":"ch06datacollection/#数组","page":"数据集","title":"数组","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"数组可以被看作是将对象作为容器保存的具有特定类型的连续内存地址。它们可以通过索引和迭代访问。与元组不同，数组是可变的。可以添加、删除或修改数组中的元素。甚至其他数据结构(如队列和堆栈)也可以将数组作为容器来实现。本节将介绍数组的基础知识。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"数组表示为Array{T, N}，其中T为类型，N为维数。Array{T, 1}或一维数组的别名为Vector，Array{T, 2}的别名为Matrix。这两者在科学计算中都有特殊的意义。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"v = [1, 2, 3]\nm = [1 2 3]","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"v是一个Vector{Int64}或Array{Int64,1}。类似地，m是一个Matrix{Int64}或Array{Int64, 2}。多维数组可以由方括号([])内的空格()和分号(;)组合而成。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"m1 = [1 2 3; 4 5 6]\nm2 = [1 2; 3 4; 5 6]","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"可以看出，分号(;)在定义中充当行分隔符。","category":"page"},{"location":"ch06datacollection/#内存布局和索引","page":"数据集","title":"内存布局和索引","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"数组成员可以通过索引访问。下面是使用前面定义的矩阵m1和m2的一些例子：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"m1[1, 2]\nm1[2, 2]\nm2[1, 2]\nm2[2, 2]","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"因此，数组成员的访问方式为：array[row_index, column_index]。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"数组中的数据存储为分配给某个位置的连续内存块。索引根据索引值指向数组的特定位置。下图显示了m1和m2的内存布局：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"(Image: arraylayout)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"与C/C++中数据在这两种情况下都存储为1、2、3、4、5和6不同，Julia中的顺序与FORTRAN一样，以行为主顺序存储数据。这本质上意味着数据的存储方式是将一列中各行的所有元素都挨在一起，然后是下一列。这对于经常使用C/C++或Python编程的人来说，可能会有点不习惯。其次，Julia中的索引与FORTRAN一样从1开始，而不是0。","category":"page"},{"location":"ch06datacollection/#分页的效果","page":"数据集","title":"分页的效果","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"在行上运行内部循环，在列上运行外部循环这种内存分页，对于小数组可能无关紧要，但对于大到非常大的数组会带来很大的好处。在多维数组中，右边的维度必然构成外部循环，左边的维度必然指定为内部循环。推荐的伪码如下：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"for col=1:100000\n    for row=1:1000\n        do_something(m[row, col])\n    end\nend","category":"page"},{"location":"ch06datacollection/#构造函数","page":"数据集","title":"构造函数","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"下面是一些构造函数的示例：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Array{Int}(undef, 1, 2)\nArray{Int}(undef, 2)\nArray{Int, 2}(undef, (2, 3))\nArray{Float32}(undef, (2, 3))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"undef是一种特殊类型的对象，用于定义包含未定义值的数组。Julia通常是在实例化对象时对它们进行初始化的。数组是一种容器类型，有时需要在内部值还未知时就定义它们。数组的一般构造函数是Array{T,N}(undef, dims)，其中dims是一个大小为N的元组或一个有N个值的可变参数。在模板参数中指定N是可选的，人们也可以调用函数Array{T} (undef, dims)。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"对于Array{T,N}，当T是isbits类型时，数组被完全分配为未初始化的位模式。因此打印的值是不可预测的。例如：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"struct A\n    i::Int\n    f::Float64\nend\na = A(1, 1); isbits(a)\naar = Array{A}(undef,(2, 2))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"现在让我们看看以下非位类型数组的场景：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"struct T\n    a::A\n    b\nend\nb = T(A(1, 1), 1); isbits(b)\nbar = Array{T}(undef, (2, 2))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"当isbits为false时，虽然Array被分配为容器，但实际的对象还没被初始化。实际的对象需要在对数组进行适当的初始化时分配。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"bar[1, 1] = bar[2, 1] = bar[1, 2] = bar[2, 2] = b\nbar","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"你还可以发现数组的可变特性，元素在数组使用undef值初始化之后可以被赋值。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"就像N维的泛型Array{T,N}一样，Vector{T}和Matrix{T}也可以有类似的构造函数。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Vector{Int}(undef, 3)\nMatrix{Int}(undef, 3, 3)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"虽然构造函数是初始化Array的一种方法，但还有其他方便的方法，我们将在下面介绍。","category":"page"},{"location":"ch06datacollection/#zeros和ones","page":"数据集","title":"zeros和ones","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"zeros(Float32, (2, 3))\nones(Float32, (2, 3))\nones(UInt8, (2, 3))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"给定类型和维数，该函数创建一个数组，以指定的类型填充0或1。","category":"page"},{"location":"ch06datacollection/#trues和falses","page":"数据集","title":"trues和falses","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"让我们看看下面的两段代码：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"zb = zeros(Bool, (8, 8))\nsizeof(zb)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"可以看到，Bool变量占用一个字节的存储空间，而这个数组需要64个字节的数据。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"z = falses(8, 8)\nsizeof(z)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"因为所有的元素都用一个位表示，z的大小只有8个字节(64位)，它创建了一个BitArray，而不是Array。因为使用一个位来存储一个字节的信息，当元素为布尔值时，BitArray是一种高效的数组存储方式。与falses类似，trues(dims)用true位值初始化BitArray。","category":"page"},{"location":"ch06datacollection/#fill和similar","page":"数据集","title":"fill和similar","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"fill(val, dims)创建一个val值数组。数组的类型取决于val值的类型。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"a = fill(5.0, (2, 2))\na = fill(5, (2, 2))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"similar(a, elem_type, dims)通过使用数组a的元素默认类型和/或dims尺寸，创建一个未初始化的elem_type数组。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"b = similar(a, Int)","category":"page"},{"location":"ch06datacollection/#collect","page":"数据集","title":"collect","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"collect(elem_type, collection)是一个从数据集创建数组的实用方法。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"collect(1:3)\ncollect(Float64, 1:2:3)","category":"page"},{"location":"ch06datacollection/#reshape","page":"数据集","title":"reshape","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"数组在内存中是线性连续分配的，索引以行为主的格式指向它们。reshape是创建数组的另一种方便的方法。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"a = collect(1:16)\nb = reshape(a, (4, 4))\nc = reshape(b, (2, 8))\nd = reshape(c, (8, 2))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"虽然数组的形状改变了，但以行为主的数据排序仍然保持。","category":"page"},{"location":"ch06datacollection/#hcat,-vcat,-hvcat","page":"数据集","title":"hcat, vcat, hvcat","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"这些方法将输入数组组合起来创建一个新的数组对象。vcat创建一个数组，其中输入数组沿着维度1放置。在一组矩阵上，其效果是数组一个接一个地向下放置。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"vcat([1 2; 3 4], [5 6; 7 8], [9 10; 11 12])","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"hcat创建一个数组，其中输入数组沿着维度2放置。在一组矩阵上，其效果是数组一个接一个地向右放置。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"hcat([1 2; 3 4], [5 6; 7 8], [9 10; 11 12])","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"hvcat(rows::Tuple{Int}, arrays...)通过使用在第一个参数中给出的rows元组数据来指定每行中连接的参数个数，这样形成的行一个接一个地堆叠起来，形成最终的数组。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"hvcat((2, 2, 2), [1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12])","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"在前面的例子中，向量以2个为一组并排放置。这样就产生了3个中间矩阵。它们是：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"beginbmatrix\n1  3 \n2  4\nendbmatrix \nbeginbmatrix\n5  7 \n6  8\nendbmatrix和\nbeginbmatrix\n9  11 \n10  12\nendbmatrix","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"现在，把它们一个叠一个，就得到了最终的输出。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"hvcat(6, [1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12])","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"同样，在上面的例子中，将6个向量相邻放置，形成一个矩阵。","category":"page"},{"location":"ch06datacollection/#关联集","page":"数据集","title":"关联集","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"在关联集中，集的元素以键/值对的形式存储。可以通过索引键或对键进行高效搜索来访问这些值。常用的有字典、多维字典、集合(尽管集合只保留键而忽略值)。大多数关联集都派生自抽象类型AbstractDict{K, V}。","category":"page"},{"location":"ch06datacollection/#字典","page":"数据集","title":"字典","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Dict{K,V}是Julia中使用的一个简单的关联集。参数类型K用作键，类型V用作值。唯一的要求是必须为类型K定义一个哈希函数。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"d = Dict(\"a\"=>1, \"c\"=>2, \"b\"=>3)\nd[\"b\"]\nd[\"a\"]\nprintln(d)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Dict{K,V}不能为同一个键保存多个值。定义中重复的键将覆盖先前定义的值。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"d = Dict(\"a\"=>1, \"c\"=>2, \"b\"=>3, \"a\"=>4)","category":"page"},{"location":"ch06datacollection/#get方法","page":"数据集","title":"get方法","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"get(dict, key, defval)方法用于从字典对象中提取信息。下面是一些例子：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"get(d, \"a\", 3)\nget(d, \"e\", 0)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"当该键是字典的一部分时，将返回与该键相关的值。然而，当该键不存在时，将返回函数中指定的默认值。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"大多数情况下，Dict{K,V}对象被像数组一样使用，只不过索引是键。使用getindex或它的别名([])从字典中获取值。与get方法不同的是，当在字典中找不到键时，getindex会抛出一个错误异常。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"getindex(d, \"e\")\ngetindex(d, \"a\")\nd[\"e\"]","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"get!(dict, key, value)方法类似于get(dict, key, defval)方法，但是会在字典中键不可用的位置插入键值对。在前面的例子中：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"get!(d, \"a\", 0)\nget!(d, \"e\", 0)\nd","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"note: Note\n在Julia中，通常的惯例是在函数名的末尾添加一个叹号(!)字符来表示要改变函数的参数值。由于get!(dict, key, value)方法更改对象字典, 叹号字符被添加到末尾。","category":"page"},{"location":"ch06datacollection/#setindex!方法","page":"数据集","title":"setindex!方法","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"就像get方法类似，setindex!方法或其别名([])用作给左侧赋值。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"d[\"e\"] = 10","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"或比较不常用的用法：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"setindex!(d, 11, \"e\")","category":"page"},{"location":"ch06datacollection/#哈希化","page":"数据集","title":"哈希化","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"要使Dict{K,V}正常工作，需要实现hash(k::K, h::Int)。对于k的每个实例，函数返回一个唯一的整数。这种唯一性确保在Dict{k,V}中只存储一个键。","category":"page"},{"location":"ch06datacollection/#集合","page":"数据集","title":"集合","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Set是一个集，其中每个元素只能保留一个实例。集合中元素的顺序不重要。下面的示例给出了一些集合方法。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"s = Set([2 3 4 5 1 2 3])\n6 in s\n5 in s\nt = Set([4 5 7 8 9])","category":"page"},{"location":"ch06datacollection/#并和交","page":"数据集","title":"并和交","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"union(s, t)\nintersect(s, t)\nunion!(s, t)\ns","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"union!类似于union，但会更新第一个参数。类似于union，symdiff和setdiff方法被定义为对称差和集合差。issubset方法提供判断一个集合与另一个集合的子集关系。","category":"page"},{"location":"ch06datacollection/#迭代","page":"数据集","title":"迭代","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"迭代是集的基本操作之一。我们将介绍如何在集中使用各种迭代操作。","category":"page"},{"location":"ch06datacollection/#for循环","page":"数据集","title":"for循环","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Julia中经典的for循环是将一个索引变量映射到一个范围对象并遍历它。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"for i=5:-2:1\n    println(i)\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"循环不仅仅局限于范围对象。也可以使用其他类型的集。下面是一些例子：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"b = [1.0 2 3; 4 5 6; 7 8 9];\nfor i=b\n    println(i)\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"除了for...=以外，for...in也可以被使用。for循环的这种表示与前面类似，只是语法看起来更适合于集。让我们看看它在字典对象上的用法。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"for p in d\n    println(p)\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Dict{K,V}元素存储为Pair{K,V}，并默认打印为：K => V。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"for (k, v) in d\n    println(\"Key: \", k, \" Value: \", v)\nend","category":"page"},{"location":"ch06datacollection/#function...do","page":"数据集","title":"function...do","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"让我们来看一个函数，它以数组作为输入，并以数组的形式返回所有值的平方。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"function collect_square(v)\n    a = similar(v)\n    for i=1:length(v)\n        a[i] = v[i]*v[i]\n    end\n    return a\nend\ncollect_square(1:4)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"如果我们要扩展这个函数，使其在计算任意函数而不仅仅是平方后返回值，我们可以按以下方式扩展它：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"function collect_function(f::Function, v)\n    a = similar(v)\n    for i=1:length(v)\n        a[i] = f(v[i])\n    end\n    return a\nend\ncollect_function(x->x^3, 1:4)","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"另一种调用相同方法的方式是使用function...do符号。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"collect_function(1:4) do x\n    return x^3\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"map是一个具有类似符号的函数。它将集元素的每个值映射给函数，并将函数求值的结果作为集返回。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"map(1:4) do x\n    return x^3\nend","category":"page"},{"location":"ch06datacollection/#迭代框架","page":"数据集","title":"迭代框架","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"我们看到了几个使用for循环遍历序列和集的例子。这实际上是通过完成迭代框架实现的。如果要编写自定义的迭代器，就需要实现这个框架。下面介绍了一些基本的思想。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"v = collect(3:2:10);\nfor i=v\n    println(i)\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"同样的可以写成以下形式：","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"next = iterate(v)\nwhile next !== nothing\n    value, state = next\n    println(value)\n    next = iterate(v, state)\nend","category":"page"},{"location":"ch06datacollection/#迭代方法","page":"数据集","title":"迭代方法","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"iterate(collection)返回第一个元素和初始状态，如果不存在值则返回nothing。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"在前面示例的返回值(3,2)中，3是第一个元素的值，2是表示状态的内部参数。尽管它看起来像是下一个值的索引，但我们不应该有这种假设，因为它完全是由特定的实现来定义的。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"iterate(collection，state)返回下一个元素和状态，如果不存在额外的元素则返回nothing。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"必须为所有的迭代器类型实现迭代方法。","category":"page"},{"location":"ch06datacollection/#可选方法","page":"数据集","title":"可选方法","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"这些方法需要由迭代器作者选择性地定义。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"IteratorSize(IterType)是一个辅助方法，它表明迭代器是否具有长度或形状。基于此确定必须为集迭代器定义尺寸或/和长度方法。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Base.IteratorSize(Vector{Int})","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"IteratorEltype(IterType)是一个辅助方法，它决定迭代器是否具有特定的元素类型。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Base.IteratorEltype(Vector{Int})","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"eltype(IterType)返回迭代方法第一个参数的类型。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"eltype(Vector{Int})","category":"page"},{"location":"ch06datacollection/#实例","page":"数据集","title":"实例","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"我们创建一个Squares类型，它将提供一组直到类型中存储值为止的数字的平方序列。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"struct Squares\n    value::Int\nend\nBase.iterate(s::Squares) = s.value <= 0 ? nothing : (1, 2)\nBase.iterate(s::Squares, state) = s.value < state ? nothing : (state*state, state+1)\nfor i=Squares(3)\n    println(i)\nend","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"上面的例子只适用于简单的for循环。使用collect方法创建数组还无法工作。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"collect(Squares(3))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"所以我们添加一个length方法来实现这个目的。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Base.length(s::Squares)=s.value\ncollect(Squares(3))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"数组可以被正确填充时，但类型是Any。定义eltype(IteratorType)方法将确保创建正确的数组类型。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"Base.eltype(::Type{Squares}) = Int\neltype(Squares)\ncollect(Squares(3))","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"note: Note\nType{Squares}是一种特殊类型，它的唯一实例对象是Squares。这是必需的，因为eltype是该类型本身而不是该类型实例的函数。","category":"page"},{"location":"ch06datacollection/#生成器和推导","page":"数据集","title":"生成器和推导","text":"","category":"section"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"在Julia中，数组和集在科学计算中被广泛使用。语言必须提供创建和操作数组的方便途径。推导表示为创建这样的数组提供了便利。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"[i*i for i=1:3]\n[i*j for i=1:3, j=1:3]","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"在前面的示例中，推导式用于创建单维和多维数组。下面是一个索引可能依赖于另一个索引的示例。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"[i*j for i=1:3 for j=i:3]","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"推导式计算完整的数组，使用延迟执行迭代器(在需要时计算值，而不是所有元素)也会有所帮助。这被称为生成器。","category":"page"},{"location":"ch06datacollection/","page":"数据集","title":"数据集","text":"gen=(i*j for i=1:3 for j=i:3)\nfor v=gen\n    println(v)\nend","category":"page"},{"location":"ch02dadatypes/#数据类型","page":"数据类型","title":"数据类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"类型是Julia语言的核心。尽管在语法上不需要显式地定义数据的类型，但Julia在编译过程中会对类型进行推断。Julia语言有预定义的类型。用户也可以定义自己的类型。有些类型可以通过参数进行修改。","category":"page"},{"location":"ch02dadatypes/#数据的表现形式","page":"数据类型","title":"数据的表现形式","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"通常，动态类型编程语言没有开发良好的类型系统，如Python中的数据类型就是非强制的。Julia类型系统是动态的，但总是在对象实例化时进行推断。这样，Julia在执行代码段或对代码进行即时(JIT)编译之前，数据类型就是已知的了。简而言之，Julia原生支持在使用前定义或推断任意对象或字面量的数据类型。在深入介绍数据类型之前，让我们先了解一下数据在Julia中的表现形式：变量、常量和字面量。","category":"page"},{"location":"ch02dadatypes/#变量","page":"数据类型","title":"变量","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia中的变量将名称与值关联起来。名称通常以字母开头的字母数字表示。下面给出了一些在Julia中变量名的例子。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"abc = 1\nπi = 30\na1 = 1\n1abc = 2\nsin = 1.0\ncos(0.0)\ncos = 0.0","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"从上面的结果可以看出，变量名可以包含Unicode字符；可以包含数字，但不能以数字开头；以函数名做为变量名时要特别慎重。变量名的另外一个限制是不能使用特殊字符和Julia的关键字，如下面的例程所示。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"julia> a@ = 1\nERROR: syntax: extra token \"@\" after end of expression\n\njulia> struct = 10\nERROR: syntax: unexpected \"=\"","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia的关键字很少。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"baremodule  begin   break       catch   const   continue\ndo          else    elseif      end     export  false \nfinally     for     function    global  if      import \nlet         local   macro       module  quote   return\nstruct      true    try         using   while ","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia还具有两字关键字(mutable struct、abstract type等)和中缀操作符(in、isa等)关键字。","category":"page"},{"location":"ch02dadatypes/#定义与初始化","page":"数据类型","title":"定义与初始化","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"大部分静态语言，如C，变量的定义和初始化是独立的。定义声明变量的类型，其底层操作是向内存申请一块相应类型的地址空间并命名（变量名）。初始化则在地址空间中存入规定类型的具体值。变量和值的关系是：变量是主体，值是变量的附属。如下面C代码片段所示。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"int i;  /* 将i定义为整数类型 */\ni = 10; /* 初始化i */\nint j = 20; /* 在一条语句中定义并初始化变量 */","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia则将变量和值的关系翻转过来：值是主体，变量是值的附属。大多数Julia变量是在对类型进行初始化时定义的。事实上，类型是作为初始化过程的一部分赋给变量的。也可以显式地声明变量将要绑定的值的类型，Julia会尝试将值转换成相应的类型，不成功则会报错。对于REPL中的全局变量，不允许声明变量的类型。例程如下所示。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a = 1\ntypeof(a)\na = 1.0\ntypeof(a)\nlet a::Int = 1.0\n    println(typeof(a))\nend\nlet a::Int = 1.1\n    println(typeof(a))\nend\na::Int = 1","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"从上面的介绍可以判断，Julia中的一般变量是没有固定地址的，事实也是如此。Julia甚至没有为我们开放变量地址的查询功能（后面会介绍可查询地址的变量类型），这一切都交给了底层程序自动处理。在Julia中，没有初始化的变量是无效的（后面会介绍例外的情况）:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"i","category":"page"},{"location":"ch02dadatypes/#常量","page":"数据类型","title":"常量","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"常量可以看作是不能修改的变量。然而，Julia并没有严格地遵循常量不变的条件。在类型不变的情况下修改常量的值，它会发出警告，但改变常量类型的情况是不允许的。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"const ICONSTANT = 1\nICONSTANT = 5\nICONSTANT = 5.0","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在使用中，尽管常量的值是可以修改的，但我们应该严格遵守常量不变的特性，以避免程序在执行中产生不可预见的错误。","category":"page"},{"location":"ch02dadatypes/#字面量","page":"数据类型","title":"字面量","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"字面量是表示一个值的常表达式。因为它们出现在变量定义的右边，因此常被称为右首值。它们也是一个值的本质表示形式。下面是一些不同类型的字面表达式。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"2           # Integer\n2.0         # Double precision Float (Float64)\n2f0         # Single precision Float (Float32)\n'a'         # Char\n\"string\"    # String","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"当我们深入研究类型时，我们将根据特定类型的上下文含义更详细地回顾字面量。通常，变量初始化为var = <literals>。","category":"page"},{"location":"ch02dadatypes/#内置数据类型","page":"数据类型","title":"内置数据类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia语言自身定义了许多内置类型。而更多的类型则是在Julia库中定义的。Julia语言提供了扩展这些功能的灵活性。此外，定义的类型不作为保留的关键字存在。下面是该语言中一些常用的类型。","category":"page"},{"location":"ch02dadatypes/#Nothing","page":"数据类型","title":"Nothing","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Nothing是值nothing的类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(nothing)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof函数可用于查询值所属类型的信息。当代码中确实需要未初始化的变量条件时，可以使用nothing来初始化这个变量。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a = nothing\ni = 6\nif i < 5\n    a = 5\nend\ntypeof(a)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"这里，如果i小于5 a就被赋值为5。否则，它仍保持未初始化。Nothing和nothing在函数参数和返回类型中也被广泛使用。","category":"page"},{"location":"ch02dadatypes/#数值类型","page":"数据类型","title":"数值类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"下面是在Julia中定义为数值数据类型的一些数据类型。","category":"page"},{"location":"ch02dadatypes/#Bool","page":"数据类型","title":"Bool","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"true和false在Julia中属于Bool类型。数值上，true的值为1,false的值为0。","category":"page"},{"location":"ch02dadatypes/#整数","page":"数据类型","title":"整数","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"整型数字类型分为具有不同字节大小的无符号和有符号类型。有符号数字类型有:Int8、Int16、Int32、Int64和Int128。对应的无符号数字类型分别为:UInt8、UInt16、UInt32、UInt64和UInt128。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(1)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"数字字面量的默认数值类型是Int，根据机器的体系结构，它映射到Int32或Int64。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"对于无符号数字，字面量由0<表示说明符><数字>指定。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(0b1), typeof(0o7), typeof(0xff)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"这些由二进制、八进制和十六进制表示的数字都被映射到UInt8。数字的尺寸由满足字面量所需的最小字节大小决定。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(0xf), typeof(0xfff),typeof(0xfffff), typeof(0xfffffffff), typeof(0xfffffffffffffffff)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"无符号整数的前面也是可以加+/-号的，但加-号的含义不是得到一个负的整数，而是得到该整数的二进制补码（后续将介绍相关知识）。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"-0x2\nInt(ans)","category":"page"},{"location":"ch02dadatypes/#浮点数","page":"数据类型","title":"浮点数","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"根据IEEE 754规范，Julia使用Float16、Float32和Float64来表示半精度、单精度和双精度浮点数。使用字面量f和e作为Float32和Float64的指数分隔符。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(1.0), typeof(1e0),typeof(1.e4)\ntypeof(1.0f0), typeof(1f-6), typeof(1.f4)","category":"page"},{"location":"ch02dadatypes/#抽象类型","page":"数据类型","title":"抽象类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia中的类型可以从抽象类型派生出来。大多数面向对象语言将这种关系视为在类层次结构中描述对象的一种方法。在Julia中，抽象类型仅仅是像接口一样的概念性表示，内部没有数据元素。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"abstract type MyAbstractType end\nstruct MyConcreteType <: MyAbstractType\n    member\nend\na = MyConcreteType(5)\na isa MyAbstractType","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"虽然我们将在后面详细讨论这个概念，但类型只能从一个抽象类型派生出来。中缀运算符isa用于判断特定对象是否属于特定类型。这里类型可以是具体类型也可以是抽象类型。下面是Julia中数字类型的类型层次结构。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: numerictypes)","category":"page"},{"location":"ch02dadatypes/#基本类型","page":"数据类型","title":"基本类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"基本类型是使用固定字节数表示数据的一种具体类型。基本类型的经典例子是整数和浮点数。与大多数语言不同，除了一组固定的内置类型外，Julia允许声明自己的基本类型。实际上，Julia的基本类型都是在语言本身中定义的:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"primitive type Float16 <: AbstractFloat 16 end\nprimitive type Float32 <: AbstractFloat 32 end\nprimitive type Float64 <: AbstractFloat 64 end\n\nprimitive type Bool <: Integer 8 end\nprimitive type Char <: AbstractChar 32 end\n\nprimitive type Int8    <: Signed   8 end\nprimitive type UInt8   <: Unsigned 8 end\nprimitive type Int16   <: Signed   16 end\nprimitive type UInt16  <: Unsigned 16 end\nprimitive type Int32   <: Signed   32 end\nprimitive type UInt32  <: Unsigned 32 end\nprimitive type Int64   <: Signed   64 end\nprimitive type UInt64  <: Unsigned 64 end\nprimitive type Int128  <: Signed   128 end\nprimitive type UInt128 <: Unsigned 128 end","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"声明基本类型的一般语法是:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"primitive type «name» «bits» end\nprimitive type «name» <: «supertype» «bits» end","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"虽然用户可以定义自己的基本类型，但建议只有在现有的基本类型不能满足要求时再定义新的基本类型。相同位值的基本类型本质上是不可互换的，也不能无缝转换。类型层次结构在这类类型的行为中扮演着重要的角色。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"UInt32(3f-1)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"尽管它们都是32位实体，但单精度浮点数不能在每种情况下都表示为无符号整数。不能创建任意大小位的基本类型，目前仅支持8位倍数的位大小。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"primitive type MyType1 40 end\nprimitive type MyType2 4 end","category":"page"},{"location":"ch02dadatypes/#位类型","page":"数据类型","title":"位类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia可以在二进制接口层面上与编译完成的语言，如C/C++、FORTRAN等进行无缝地交互，得益于Julia中定义的某些数据类型同这些本地编译语言所使用的类型在二进制布局中是一致的。这种类型被称为位类型。Julia中的基本类型都是位类型的数据类型。某些复合数据类型也是位类型。我们将在遇到他们时进一步讨论。位类型可以通过在实例上调用isbits函数或在类型上调用isbitstype函数进行查询。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a = 10\nisbits(a)\nisbitstype(Int)","category":"page"},{"location":"ch02dadatypes/#有理数和复数","page":"数据类型","title":"有理数和复数","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"虽然有理数和复数是数字类型，但它们不是基本类型。它们是使用复合数据类型创建的，我们将把复合数据类型作为用户定义类型的一部分来介绍。","category":"page"},{"location":"ch02dadatypes/#字符","page":"数据类型","title":"字符","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Char是由32位值表示的字符。它是Unicode字符的一个有效UCS-4表示。我们将在String一章详细讨论Char及其与String的关系。AbstractChar抽象类型可方便用户开发自己的类Char数据类型。","category":"page"},{"location":"ch02dadatypes/#字符串","page":"数据类型","title":"字符串","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"字符串是字符的集合。虽然大多数字符串是由Unicode字符编码组成的，但它们也可以存储其他类型的二进制数据。AbstractString抽象类型方便用户定义自己的字符串类型。","category":"page"},{"location":"ch02dadatypes/#用户定义类型","page":"数据类型","title":"用户定义类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"虽然Julia提供了相当多的内置类型，但仍需要将各种属性组合在一起的数据类型。","category":"page"},{"location":"ch02dadatypes/#结构","page":"数据类型","title":"结构","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia用struct表示一旦被初始化，其内部属性就不能被修改的自定义复合类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"struct Rectangle\n    h::Float64\n    w::Float64\nend\nr = Rectangle(10.0, 20.0)\nr.h = 15","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Rectangle是一个struct，初始化值为10.0和20.0。属性值不能被修改。函数Rectangle(10.0, 20.0)用来执行初始化。它是一个特殊的函数。当我们讨论函数和方法时，将进行深入介绍。","category":"page"},{"location":"ch02dadatypes/#可变结构","page":"数据类型","title":"可变结构","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"假设我们需要Rectangle是可修改的，则可以创建一个可变结构，如下所示:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"mutable struct MRectangle\n    h::Float64\n    w::Float64\nend\nmr = MRectangle(10.0, 20.0)\nmr.h = 15.0\nmr","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"可以看到，属性值在实例化对象之后是可以被修改的。Julia中的复合数据类型也可以从抽象类型派生出来。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"abstract type Shape end\nstruct Rectangle <: Shape\n    w::Float64\n    h::Float64\nend\nstruct Square <: Shape\n    l::Float64\nend","category":"page"},{"location":"ch02dadatypes/#成员","page":"数据类型","title":"成员","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia中的复合类型具有成员属性，但没有成员函数或方法。Julia的多分派体系结构使函数的行为类似于特定类型的方法，但它们与面向对象语言中的方法不同。有一类特殊的函数，它可以是类型的成员。这些函数被称为构造函数。我们将在讨论函数时详细讨论构造函数。成员的类型信息并不总是在复合类型中被指定。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"mutable struct A\n    member\nend\na = A(5)\ntypeof(a.member)\na1 = A(\"string\")\ntypeof(a1.member)","category":"page"},{"location":"ch02dadatypes/#Any","page":"数据类型","title":"Any","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"虽然在前面的例子中，模糊性问题在对对象进行实例化时得到了解决，但我们永远不能确定动态成员属性未来将被赋予哪种数据类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a.member = \"julia\"\ntypeof(a.member)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a.member之前的类型是Int64，现在是String。Julia假定这种未指明的类型为Any。在不能确定类型的情况下，Julia将假定类型为Any。从性能的角度来看，使用Any是不可取的。每次访问Any类型的对象时，它都会重定向到另一个实际的对象。我们不可能事先知道Any对象的大小。实际上，它是一个指向内存中实际对象所在的另一个位置的指针:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: anytype)","category":"page"},{"location":"ch02dadatypes/#参数数据类型","page":"数据类型","title":"参数数据类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Any作为类型会引入不必要的跳转，因此效率很低。有时，类型不一定会影响算法，但会引入不同的数据位大小。例如，前面介绍的Rational数据类型，分子和分母可以是任何整数类型，如Int8、Int16、Int32、Int64或Int128。Rational数据类型的定义如下:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"struct Rational{T<:Integer} <: Real\n    num::T\n    den::T\nend","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"两个属性num和den的类型为T，其中T是Integer的子类型。Rational是Real的一个子类型。以下是参数数据类型的一些特性。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Rational{Any}\nRational{Int32} <: Rational\nRational{Int32} <: Rational{Integer}","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"理解这种行为尤其重要。尽管Int32是Integer的子类型，但参数表示Rational{Int32}不是Rational{Integer}的子类型。然而，Rational{Int32}是Rational的子类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a = Rational{Int32}(1,UInt32(2))\ntypeof(a.num), typeof(a.den)\nb = Rational{Integer}(1,UInt32(2))\ntypeof(b.num), typeof(b.den)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"与具体数据类型一样，抽象数据类型也可以参数化。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"abstract type Shape{T<:AbstractFloat} end\nstruct Rectangle{T<:AbstractFloat} <: Shape{T}\n    w::T\n    h::T\nend\nstruct Square{T<:AbstractFloat} <: Shape{T}\n    s::T\nend","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"根据上面的方案，针对T可以开发不同的功能，如将T设为Float32或Float64，构建的Rectangle{Float32}类型与Rectangle{Float64}类型完全不同，它们是在编译过程中实例化具体类型时生成的。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"类型的参数化是Julia语言一个非常有用的特性，除此以外，也可以对整数值进行参数化。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"struct Point{T<:AbstractFloat,N}\n    x::Vector{T}\nend\nnum_coor(::Point{T,N}) where {T<:AbstractFloat,N} = N\np2 = Point{Float32,2}([1f0,2f0])\np3 = Point{Float32,3}([1f0,2f0,3f0])\nnum_coor(p2)\nnum_coor(p3)\npush!(p2.x,3)\np2\nnum_coor(p2)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"可以看出，类型中使用的N是用作类型参数的整数。","category":"page"},{"location":"ch02dadatypes/#类型上的运算","page":"数据类型","title":"类型上的运算","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"某些操作适用于类型。在前面，我们已经看到了一些，本节将详细介绍它们。","category":"page"},{"location":"ch02dadatypes/#typeof","page":"数据类型","title":"typeof","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"此函数提供与类型的实例相关联的具体类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a = 1 // 2\ntypeof(a)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"类型本身也有类型，它们都是DataType类型的实例。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typeof(Int)\ntypeof(Any)\ntypeof(DataType)","category":"page"},{"location":"ch02dadatypes/#别名","page":"数据类型","title":"别名","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"与任何其他实例对象一样，类型可以进行比较和赋值。下面是来自base/boot.jl的代码片段。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"if Int === Int64\n    const UInt = UInt64\nelse\n    const UInt = UInt32\nend","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Int对象与Int64对象进行比较，如果相同则UInt初始化为UInt64，否则初始化为UInt32。因此根据机器架构，UInt成为UInt64或UInt32的别名。","category":"page"},{"location":"ch02dadatypes/#isa","page":"数据类型","title":"isa","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"判断实例是否属于特定类型。isa也可以用作中缀运算符。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"isa(1,Number)\nisa(1,Matrix)\nisa(1,Int)\n\"julia\" isa String","category":"page"},{"location":"ch02dadatypes/#supertype","page":"数据类型","title":"supertype","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"这个函数返回一个类型的直接超类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"supertype(Int32)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":">:用于指定（在结构或函数定义阶段）或判断一个类是否是另一个类的超类。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Integer >: UInt8\nFloat64 >: Float16","category":"page"},{"location":"ch02dadatypes/#:","page":"数据类型","title":"<:","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"此操作符用于表示一个类型是否是另一个类型的子类型。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Int32 <: Integer\nInt32 <: AbstractFloat\nInt32 <: Real\nInt32 <: Signed","category":"page"},{"location":"ch02dadatypes/#打印数据类型","page":"数据类型","title":"打印数据类型","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在定义了复杂的数据类型后，常需要以有意义的方式表示数据。默认情况下，所有成员都将作为元组打印。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"struct A \n    a1::Int32\n    a2::Float64\nend\na = A(1,2)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"其次，数据经常打印在REPL上。要禁止在REPL上打印数据，可以用分号(;)结束语句。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"a;\na","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"默认情况下，Nothing不会标记输出。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"nothing","category":"page"},{"location":"ch02dadatypes/#show","page":"数据类型","title":"show","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"默认情况下，为了在REPL上显示输出，会在数据类型上调用相关的show方法。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"struct A\n    a1::Int32\n    a2::Float64\nend\na = A(1, 2)\nfunction Base.show(io::IO, a::A)\n    println(io, \"a1: \", a.a1, \" a2: \", a.a2)\nend\na","category":"page"},{"location":"ch02dadatypes/#print","page":"数据类型","title":"print","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"show用于在任何类型的输出设备上显示数据，而print只能用于输出文本信息。如果没有引入特定的打印例程，则在调用print时在内部使用show。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"print(a)","category":"page"},{"location":"ch02dadatypes/#string","page":"数据类型","title":"string","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"此函数可用于将任何类型转换为其字符串表示形式。当没有提供适当的转换方法时，将在内部调用print函数以获取数据类型的文本表示。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"string(a)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在前面的代码中可以清楚地看到print或底层show的用法。而字符串中额外的行尾则归因于println的使用，它向语句添加了一个EOL。如果想去掉它，只需要将show中的println换为print即可。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"function Base.show(io::IO, a::A)\n    print(io, \"a1: \", a.a1, \" a2: \", a.a2)\nend\nstring(a)","category":"page"},{"location":"ch02dadatypes/#数字在计算机中的存储与运算","page":"数据类型","title":"数字在计算机中的存储与运算","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在Julia中，如果你输入(sqrt3)^2，结果将是2.9....96，其中9重复了15次。相比与传统的数学运算，计算机的运算方式有两个明显且本质的区别:","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"计算机只能表示有限数量的数字;\n计算机中表示的数字只能有有限多个有效数字。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"因此，能够在计算机中精确表示的数字只是有理数的一个子集。每当计算机执行一个运算，当结果不是一个可以在计算机中精确表示的数字时，就会用一个近似值来代替这个数字。这被称为舍入误差：用计算机进行实数计算时产生的错误。","category":"page"},{"location":"ch02dadatypes/#实数的浮点表示方法","page":"数据类型","title":"实数的浮点表示方法","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"下面是在计算机中表示实数的一般模型：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"x=s(a_1a_2a_t)_betatimesbeta^e tag1","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"其中","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"beginalign*\ns   x=1 的符号 2ex \ne   指数范围为LeU 2ex \n(a_1 a_t)_beta  = dfraca_1beta+dfraca_2beta^2+cdots+dfraca_tbeta^t尾数 2ex\nβ   基数 2ex\nt   有效数字个数精度 \nendalign*","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在浮点表示法(1)中，如果我们以这样一种方式指定e，即a_1 0，那么表示将是唯一的。这称为规格化的浮点表示法。例如，如果β = 10，在规格化的浮点数中，我们将把0012写成012  10^1，而不是0012  10^0或00012  10^1。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在当今大多数计算机中，基数是β = 2。过去老式的IBM大型机中曾使用过基数8和16。一些手持计算器使用基数10。莫斯科国立大学开发的Setun计算机，使用的基数是3，但并没有得到广泛推广。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"对于s，β，t，e的值，在一般浮点模型(1)中有多种选择。IEEE 64位浮点表示是当今大多数计算机中使用的特定模型：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"x=(-1)^s(1a_2a_3 a_53)_2 2^e-1023 tag2","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"注意在方程(1)和(2)中s的不同表现形式。在(2)中，s为0或1。s = 0，x是正的；s = 1, x是负的。\n由于β = 2，在x的规格化浮点表示中，小数点后的第一个(非零)位必然是1。因此我们不需要存储这个数字。这就是为什么在(2)中我们把x写成从1开始的小数。即使精度是t = 52，我们也能够访问到第53位有效数字a_53。\n指数的范围是:0e2047。稍后会讨论2047的来源。但首先，我们讨论一下为什么在(2)表示法中我们用e - 1023作为指数，而不是简单地用e(在(1)表示法中)作为指数。如果最小的可能指数是e = 0，那么计算机能生成的最小正数将是(1000)_2 = 1：当然，我们需要计算机来表示小于1的数字！这就是为什么我们在表示(2)中使用称为有偏指数的移位表达式e - 1023。注意，有偏指数的范围是- 1023e - 10231024。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"下图说明了计算机的物理位如何与上面的表示相对应。下表中编号为1到64的每个单元对应于计算机内存中的物理位。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: Physical bits)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"第一位是符号位：它存储s的值，0或1。\n蓝色的2到12位存储指数e(不是e1023)。使用11位，可以生成从0到2^111 = 2047的整数。下面是如何得到e的最小值和最大值：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"e=(000)_2=0 1ex \ne=(111)_2 =2^0+2^1++2^10=dfrac2^11-12-1=2047","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"红色的52位，存储有效数字a_2到a_53。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"例1：求10.375的浮点表示形式。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"解： 通过计算 10=0times2^0+textcolorblue1 2^1 + textcolorgreen0times2^2+textcolorred1times2^3 和 0375=0times2^-1+textcolorblue1times2^-2+textcolorgreen1times2^-3 可以得到 10=(textcolorred1textcolorgreen0textcolorblue10)_2 和 0375=(0textcolorblue1textcolorgreen1)_2。最终得到：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"10375=(1010011)_2=(1010011)_2times2^3","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"式中(1010011)_2  2^3为该数字的规格化的浮点表示。现在我们将其改写为式(2)的表示形式：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"10375=(-1)^0(1010011)_2times2^1026-1023","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"由于1026 =(10000000010)_2，按位表示的最终结果为：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: 基于10的数)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"注意因为数字是正数，第一个符号位是0。接下来的11位(蓝色)代表指数e = 1026，下一组红色的位是尾数，尾数的最末一位有效数字以后用0填充。在Julia中，我们可以通过输入bitstring(10.375)来逐位表示：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"bitstring(10.375)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"特殊情况：0，无穷，非数","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在浮点算术中有两个零：+00和00，它们有特殊的表示。在表示0时，所有的指数位和尾数位都设置为0。符号位是0的代表+00，1的代表00：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: zeros)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"当指数位设置为0时，我们有e = 0，因此e1023 =1023。这种将所有指数位设置为零的情况，是为00和非规格化数字保留的。非规格化数用来表示靠近0的数或0。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"下面是计算机中正负无穷数的表示方法：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(Image: 正负无穷数)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"当指数位全设置为1时，我们有e = 2047，因此e1023 = 1024。这种安排是专门为以及其他特殊值，如NaN(非数)保留的；当尾数等于0时表示无穷大，尾数不等于0时表示非数。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"综上所述，尽管(2)中的1023e10231024，但在表示非零实数时，我们只能访问1022e10231023的指数范围。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"因此，计算机可以表示的最小正实数（非规格化）为：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"x=(-1)^0(0001)_2times2^-1022=2^-52times2^-1022=50times10^-324","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"最大正实数（规格化）为：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"x=(-1)^0(1111)_2times2^1023=left(1+dfrac12+dfrac12^2++dfrac12^52 right)times2^1023=(2-2^-52)times2^1023018times10^309","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在计算过程中，如果得到一个小于最小浮点数的数字，则会产生下溢错误。大于最大值的数字会产生上溢错误。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"Julia中上溢和下溢错误分别是正负无穷：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"nextfloat((2.0-2^(-52))*2.0^1023)\nprevfloat(-(2.0-2^(-52))*2.0^1023)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"其运算方式与水银式温度计类似。","category":"page"},{"location":"ch02dadatypes/#整数的表示方法","page":"数据类型","title":"整数的表示方法","text":"","category":"section"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在前一节中，我们讨论了计算机中实数的表示方法。这里我们将简要讨论整数的表示方法。计算机如何表示整数n？与实数类似，我们以2为基数开始写n。我们有64位来表示它的有效数字和符号。与浮点数一样，我们为符号分配一位，将其余的63位用于有效数字。当对整数进行加法运算时，这种方法有一些缺点。另一种方法被称为二进制补码，它更常用，包括在Julia中。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"举个例子，假设我们的计算机是8位的。要用二进制补码表示12(或任何正整数)，只需将它写成以2为基数展开的形式：(00001100)_2。为了表示−12，我们做如下操作：翻转所有数位，用0替换1，用1替换0，然后在结果上加1。翻转数字12，我们得到(11110011)_2，加上1（二进制）得到(11110100)_2。因此，−12在二进制补码法中被表示为(11110100)_2。为了表示-12，费了那么大的功夫，感觉有点奇怪，但当把12和-12二进制表示相加时，这种表示方法的优势立刻显现：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(00001100)_2+(11110100)_2=(textcolorred100000000)_2","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"这个和的前8位(从右到左)，也就是计算机能表示的(忽略红色数字1)，是(00000000)_2。所以就像以10为基数的12 +(- 12)= 0一样，这些数的表示形式的和也是0。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"我们可以用Julia实现64位的计算。函数bitstring输出一个整数的数位，对于负数使用二进制补码：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"bitstring(12)\nbitstring(-12)","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"你可以验证当截断到64位时，这些表示的和为0。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"下面是另一个说明二进制补码优点的例子。考虑−3和5的表现，","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"-3=(11111101)_2 和 5 =(00000101)_2","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"−3和5的和是2；那么它们表示形式的二进制和呢？我们有：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"(11111101)_2+(00000101)_2=(textcolorred100000010)_2","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"如果我们忽略红色的第9位，结果是(10)_2，结果也确实是2。注意，如果我们遵循浮点表示中使用的相同方法，并将最左边的位分配给整数的符号，就不会有这个属性。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"还记得对无符号整数取负的例子吧，它实际上返回的就是原整数的二进制补码。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"0xc\n-0xc","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"在二进制补码中，使用64位，可以表示2^63 =9223372036854775808和2^631 =9223372036854775807之间的整数。小于或大于这个范围的任何整数都会产生下溢或上溢错误。","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"整数的溢出与浮点数有所不同，如下所示：","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"typemax(Int64)\ntypemin(Int64)\ntypemax(Int64) + 1\ntypemin(Int64) - 1","category":"page"},{"location":"ch02dadatypes/","page":"数据类型","title":"数据类型","text":"当获得一个超过最大（或最小）可能值的整数时，Julia绕到最小（或最大）的整数，并继续计算。其运算方法与指针式钟表完全一样。","category":"page"},{"location":"ch05scope/#变量的作用域","page":"变量的作用域","title":"变量的作用域","text":"","category":"section"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"变量的作用域是变量在代码中可见的范围。变量作用域有助于避免变量命名冲突。这个概念很直观:两个函数都可以有称为x的参数，但这两个x所指的不是同一件事。类似地，在许多其他情况下，不同的代码块可以使用相同的名称而不引用相同的东西。当相同的变量名指向或不指向同一事物时，这种规则称为作用域规则。本章将对它们进行详细说明。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"语言中的某些构造引入了范围块，在这些范围块内，规定了某些变量集的作用域。变量的作用域不能是源代码的任意一组集合，相反，它将总是与这些块中的一个相关。在Julia中有两种主要类型的作用域，全局作用域和局部作用域。后者可以嵌套。在Julia中，构造的“硬作用域”和“软作用域”之间也有区别，它们会影响是否允许使用同名变量隐藏一个全局变量。","category":"page"},{"location":"ch05scope/#作用域构造","page":"变量的作用域","title":"作用域构造","text":"","category":"section"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"引入作用域块的构造有：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"构造 作用域类型 允许的位置\nmodule，baremodue 全局 全局\nstruct 局部（软） 全局\nfor，while，try 局部（软） 全局，局部\nmacro 局部（硬） 全局\n函数，do块，let块，推导，生成器 局部（硬） 全局，局部","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"值得注意的是，这个表中没有begin块和if块，它们没有引入新的作用域。这三种类型的作用域遵循不同的规则，下面将对此进行解释。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"Julia使用词法作用域，这意味着函数的作用域不是继承自调用者的作用域，而是继承自定义函数的作用域。例如，在以下代码中，foo中的x引用了其模块Bar的全局作用域中的x：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"module Bar\n    x = 1\n    foo() = x\nend;","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"而不是使用foo的作用域中的x：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"import .Bar\nx = -1;\nBar.foo()","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"因此，词法作用域意味着特定代码段中的变量所引用的内容可以单独从其出现的代码中推断出来，而不依赖于程序的执行方式。嵌套在另一个作用域中的作用域可以“看到”包含它的所有外部作用域中的变量。但是，外部作用域不能看到内部作用域中的变量。","category":"page"},{"location":"ch05scope/#全局作用域","page":"变量的作用域","title":"全局作用域","text":"","category":"section"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"每个模块都引入一个新的全局作用域，它与所有其他模块的全局作用域分开——不存在包含所有全局作用域的全局作用域。模块可以通过using或import语句，或通过使用点表示法的授权访问，将其他模块的变量引入其作用域，即每个模块都是一个所谓的命名空间，也是一个将名称与值关联起来的一级数据结构。注意，虽然可以在外部读取变量绑定的值，但只能在它们所属的模块内更改它们。作为一个安全门，你总是可以在模块内执行代码来修改一个变量。这避免了模块绑定在外部不通过调用eval而直接对代码进行修改。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"module A\n    a = 1 # a global in A's scope\nend;\nmodule B\n    module C\n        c = 2\n    end\n    b = C.c    # can access the namespace of a nested global scope \n               # through a qualified access\n    import ..A # makes module A available\n    d = A.a\nend;\nmodule D\n    b = a  # errors as D's global scope is separate from A's\nend;\nmodule E\n    import ..A  # make module A available\n    A.a = 2     # throws an error\nend;","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"注意，交互提示符(又名REPL)位于模块Main的全局作用域内。","category":"page"},{"location":"ch05scope/#局部作用域","page":"变量的作用域","title":"局部作用域","text":"","category":"section"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"大多数代码块都会引入一个新的局部作用域(完整列表见上表)。一些编程语言要求在使用新变量之前会显式地声明它们。在Julia中也可以使用显式声明：在任何局部作用域中，不管外部作用域中是否已经存在名为x的变量，写入local x就在该作用域中声明了一个新的局部变量。然而，像这样声明每个新的局部变量有点冗长和乏味，因此，与许多其他语言一样，Julia通过在局部作用域中对新变量赋值，从而隐式地将该变量声明为一个新的局部变量。大多数情况下，这是相当直观的，但与许多凭直觉行事的事情一样，细节要比从表面看起来的要微妙得多。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"当x = <value>发生在局部作用域中时，Julia应用以下规则，根据赋值表达式发生的位置和x在该位置已经引用的内容来决定表达式的含义：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"现有的局部变量：如果x已经是一个局部变量，则对现有的局部变量x赋值。\n硬作用域：如果x还不是一个局部变量，并且赋值发生在硬作用域构造中(例如，在let块、函数或宏体、推导或生成器中)，则在赋值的作用域中创建一个名为x的新局部变量。\n软作用域：如果x还不是一个局部变量，并且所有包含赋值的作用域结构都是软作用域(循环、try/catch块或struct块)，则行为取决于是否定义了全局变量x：\n如果全局x未定义，则在赋值范围内创建一个名为x的新局部变量。\n如果定义了全局x，赋值被认为是歧义的：\n在非交互式环境中(文件，eval)，会打印一个歧义警告，并创建一个新的局部变量。\n在交互式环境中(REPL, notebook)，全局变量x被赋值。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"你可能会注意到，在非交互式环境中，硬作用域和软作用域的行为是相同的，只不过在软作用域中，当一个隐式局部变量(即没有使用local x声明)对全局变量造成屏蔽时，会打印一个警告。在交互式环境中，为了方便起见，规则遵循更复杂的启发式。下面的示例将深入讨论这一点。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"既然已经知道了规则，让我们看一些例子。假设每个示例都是在一个全新的REPL会话中计算的，这样每个代码段中的惟一全局变量就是在该代码块中分配的全局变量。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"我们将从一个优雅而明确的情况开始——在硬作用域内赋值，在本例中是一个函数体，此时不存在同名的局部变量：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"function greet()\n    x = \"hello\"  # new local\n    println(x)\nend\ngreet()\nx  # global","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"在greet函数内部，赋值x = \"hello\"使x成为函数作用域中的一个新的局部变量。有两个相关的事实：赋值发生在局部作用域中，并且没有现有的局部x变量。因为x是局部的，所以是否存在一个全局变量x并不重要。例如，在定义和调用greet之前，我们先定义了x = 123：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"x = 123  # global\nfunction greet()\n    x = \"hello\"  # new local\n    println(x)\nend\ngreet()\nx  #global","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"由于greet中的x是局部的，全局x的值(或不存在这样的值)不受调用greet的影响。硬作用域规则并不关心名为x的全局变量是否存在：在硬作用域中对x的赋值是局部的(除非x在其中被显示地声明为全局的)。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"我们要考虑的下一个明确的情况是，已经有一个名为x的局部变量，在这种情况下，x = <value>总是赋值给这个已经存在的局部变量x。下面的函数sum_to计算从1到n的数字之和：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"function sum_to(n)\n    s = 0  # new local\n    for i = 1:n\n        s = s + i  # assign existing local\n    end\n    return s    # same local\nend","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"与前面的示例一样，在sum_to的顶部对s的第一次赋值将导致s成为函数体中的一个新的局部变量。for循环在函数作用域中有自己的内部局部作用域。当s = s + i出现时，s已经是一个局部变量，因此赋值更新了现有的s，而不是创建一个新的局部变量。我们可以通过调用REPL中的sum_to来测试：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"sum_to(10)\ns","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"因为s是sum_to的本地函数,调用函数对全局变量s没有影响。我们也可以看到在for循环中更新s = s + i必定更新了由初始化s = 0创建的s，因为我们得到了从整数1到10的正确的和55。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"让我们先深入了解一下for循环体有它自己的作用域这一事实，我们可以写一个稍微更复杂的变体sum_to_def，在更新s之前将和s + i保存在变量t中：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"function sum_to_def(n)\n    s = 0   # new local\n    for i = 1:n\n        t = s + i   # new local `t`\n        s = t       # assign existing local `s`\n    end\n    return s, @isdefined(t)\nend\nsum_to_def(10)","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"这个版本像以前一样返回s，但它也使用@isdefined宏返回一个布尔值，显示函数的最外层局部作用域中是否定义了一个名为t的局部变量。如你所见，在for循环体之外没有定义t。这还是因为硬作用域规则：由于对t的赋值发生在函数内部，这引入了硬作用域，赋值导致t在它出现的局部作用域内成为一个新的局部变量，即在循环体内部。即使有一个名为t的全局变量，也不会有什么区别——硬作用域规则不会受到全局作用域中情况的影响。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"让我们来看看软作用域规则所涵盖的一些更模糊的情况。我们将通过将greet和sum_to_def函数的主体提取到软作用域环境中来研究这个问题。首先，让我们把greet的主体放到for循环中——它是软的，而不是硬的——然后在REPL中计算它：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"for i = 1:3\n    x = \"hello\" # new local\n    println(x)\nend\nx","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"由于在执行for循环时没有定义全局x，因此软作用域规则的第一种情况将被应用，x将被创建为for循环的局部变量，因此在循环执行后全局x仍未定义。接下来，让我们考虑将sum_to_def的主体提取到全局作用域，将其参数固定为n = 10：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"s = 0\nfor i = 1:10\n    t = s + i\n    s = t\nend\ns\n@isdefined(t)","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"这段代码做了什么的？这是个棘手的问题。答案是“视情况而定”。如果以交互方式输入此代码，则其行为与在函数体中相同。但是，如果代码出现在文件中，它会打印一个歧义警告，并抛出一个未定义变量的错误。让我们先看看它在REPL中的工作情况：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"s = 0   # global\nfor i = 1:10\n    t = s + i   # new local `t`\n    s = t       # assign global `s`\nend\ns   # global\n@isdefined(t)   # global","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"REPL通过判断是否定义了同名的全局变量来确定循环内的赋值是赋值给全局变量还是创建新的局部变量，这种行为近似于函数体内的行为。如果存在同名的全局变量，则赋值操作会更新它。如果不存在全局变量，则赋值将创建一个新的局部变量。在这个例子中，我们看到了这两种情况：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"没有全局变量t，所以t = s + i创建一个新的t，它是for循环的局部变量。\n有一个全局变量s，所以s = t赋值给它。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"第二条解释了为什么循环的执行会改变s的全局值，第一条解释了为什么在循环执行后t仍然是未定义的。现在，让我们对相同的代码进行改造，模拟代码在文件中的情况，然后执行：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"code = \"\"\"\ns = 0   # global\nfor i = 1:10\n    t = s + i   # new local `t`\n    s = t   # new local `s` with warning\nend\ns,  # global\n@isdefined(t)   # global\n\"\"\";\ninclude_string(Main, code)","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"这里我们使用include_string来执行代码，就好像它是文件的内容一样。我们也可以将代码保存到文件中，然后在该文件上调用include——结果将是相同的。如你所见，这与在REPL中的结果有很大的不同。让我们来分析一下这里发生了什么：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"在执行循环之前，全局变量s被定义为值0。\n赋值s = t发生在软作用域中——任何函数体或其他硬作用域构造之外的for循环中。\n因此，适用于软作用域规则的第二种情况，并且赋值是不明确的，因此会发出警告。\n继续执行，使s成为for循环体的局部变量。\n由于s是for循环的局部变量，当t = s + i被求值时，它是未定义的，从而导致错误。\n计算到此结束，但如果到达s和@isdefined(t)，它将返回0和false。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"这演示了作用域的一些重要方面：在作用域中，每个变量只能有一种含义，并且该含义与表达式的顺序无关。在循环中表达式s = t的存在导致s是循环的局部变量，这意味着当它出现在t = s + i的右边时，它也是局部变量，即使该表达式首先出现并首先执行。你或许会认为循环第一行的s可以是全局的，循环第二行的s可以是本地的，但实际上是不可能的，因为这两行在同一个作用域块，在给定的作用域，每个变量只能有一种含义。","category":"page"},{"location":"ch05scope/#关于软作用域","page":"变量的作用域","title":"关于软作用域","text":"","category":"section"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"现在，我们已经介绍了所有的局部作用域规则，但是在结束本节之前，应该说明一下为什么在交互和非交互环境中处理模糊的软作用域情况是不同的。人们可能会问两个明显的问题：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"为何不在所有地方都像在REPL中那样的工作呢？\n为和不在所有地方都像在文件中那样工作并去掉警告呢？","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"在Julia≤0.6,所有全局作用域的工作方式都如同当前的REPL一样：当x = <value>发生在一个循环(或try/catch，或struct体)内，但在函数体(或let块或推导)以外，x在循环内是否为局部的取决于是否定义了全局变量x。这种行为具有直观和方便的优点，因为它尽可能接近函数体内部的行为。特别地，当调试函数的行为时，它使得在函数体和REPL之间来回移动代码变得很容易。然而，它也有一些缺点。首先，这是一种相当复杂的行为：多年来，许多人对这种行为感到困惑，并抱怨它既复杂又难以解释和理解。其次，可以说更糟糕的是，它不利于“大规模”编程。当你在一个地方看到像这样的一小段代码时，很清楚会发生什么：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"s = 0\nfor i = 1:10\n    s += i\nend","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"显然，其目的是修改现有的全局变量s，不然会是什么呢？然而，并非所有现实世界的代码都是如此简短或清晰。我们发现像下面这样的代码经常大量的出现：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"x = 123\n\n# much later\n# maybe in a different file\n\nfor i = 1:10\n    x = \"hello\"\n    prinntln(x)\nend\n\n# much later\n# maybe in yet another file\n# or maybe back in the first one where `x = 123`\n\ny = x + 234","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"现在就不是很明确应该发生什么。因为x + \"hello\"是一个方法错误，它的意图似乎是让x在for循环中是局部的。但是运行时的值和当时存在的方法不能用来确定变量的作用域。在Julia≤0.6的行为方式下，会存在有人先写了for循环，它可以很好的工作，但后来当别人在远处（可能在不同的文件中）添加了一个新的全局变量，代码突然改变了含义，它可能会显式地终止，更糟的是，有可能默默地做错误的事情。这种“幽灵般的远距离行动”是优秀的程序语言设计应该避免的。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"因此，在Julia 1.0中，简化了作用域规则：在任何局部作用域中，对一个不属于局部变量的名称赋值将创建一个新的局部变量。这完全消除了软作用域的概念，并消除了幽灵行动的可能性。软作用域的删除使大量的bug得到了暴露和修复，这也证明了选择删除它是正确的。但也存在一些不便，如下面的代码所示：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"s = 0\nfor i = 1:10\n    global s += i\nend","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"看到全局注释了吗？显然，这种情况是不能容忍的。但严格地说，这种需要global的顶层代码存在两个主要问题：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"不方便将函数体中的代码复制并粘贴到REPL中进行调试——你必须在调试时添加global注释，然后在拷回函数时删除它们。\n初学者会在编写这类代码时漏掉global，并对代码不能工作感到莫名其妙——他们得到的错误是s未被定义，这似乎对碰巧犯这种错误的人没有任何启发效果。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"从Julia 1.5开始，这段代码在交互式环境中(如REPL或Jupyter笔记本)不需要global注释(就像Julia 0.6)，在文件和其他非交互式环境中，它打印出非常直接的警告：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"在软作用域中对s的赋值是不明确的，因为存在同名的全局变量：s将被视为一个新的局部变量。通过使用local s来消除该警告，或使用global s来赋值给现有的全局变量来消除歧义。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"这既解决了上述两个问题，又保留了1.0中“大规模编程”好处的行为：全局变量对可能遥远的代码含义没有幽灵影响。在REPL中复制粘贴调试工作良好，初学者也不会遇到任何问题，任何时候，如果有人忘记了一个global注释，或者不小心在一个软作用域中用一个局部隐藏了一个现有的全局变量（虽然听起来很奇怪），他们就会得到一个清晰的警告。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"这种设计的一个重要属性是，任何在文件中执行而没有警告的代码在新的REPL中都将以相同的方式执行。另一方面，如果你使用一个REPL会话并将其保存到文件中，如果它的行为与在REPL中不同，那么你将得到一个警告。","category":"page"},{"location":"ch05scope/#Let块","page":"变量的作用域","title":"Let块","text":"","category":"section"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"与对局部变量的赋值不同，let语句在每次运行时分配新的变量绑定。赋值会修改现有值的位置，let会创建新的位置。这种差异通常并不重要，只有在变量通过闭包存活的时间超过其作用域的情况下才会显现。let语法接受逗号分隔的一系列赋值和变量名：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"x, y, z = -1, -1, -1;\nlet x = 1, z\n    println(\"x: $x, y: $y\") # x is local variable, y the global\n    println(\"z: $z\") # errors as z has not been assigned yet but is local\nend","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"赋值是按顺序执行的，在左边的新变量被引入之前，右边的每个变量都在作用域内求值。因此，写let x = x是有意义的，因为两个x变量是不同的，有不同的存储空间。下面是一个需要let行为的例子：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"Fs = Vector{Any}(undef, 2); i = 1;\nwhile i <= 2\n    Fs[i] = () -> i\n    global i += 1\nend\nFs[1]()\nFs[2]()","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"在这里，我们创建并存储了两个返回变量i的闭包。然而，它始终是同一个变量i，因此两个闭包的行为是相同的。我们可以使用let为i创建一个新的绑定：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"Fs = Vector{Any}(undef, 2); i = 1;\nwhile i <= 2\n    let i = i\n        Fs[i] = () -> i\n    end\n    global i += 1\nend\nFs[1]()\nFs[2]()","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"由于begin构造不引入新的作用域，所以使用零参数let只引入一个新的作用域块而不创建任何新绑定是很有用的：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"let\n    local x = 1\n    let\n        local x = 2\n    end\n    x\nend","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"因为let引入了一个新的作用域块，所以内部的局部变量x与外部的局部变量x是不同的。","category":"page"},{"location":"ch05scope/#循环和推导","page":"变量的作用域","title":"循环和推导","text":"","category":"section"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"在循环和推导式中，在其主体作用域中引入的新变量会在每次循环迭代时重新分配，就像循环主体被一个let块包围一样，如下例所示：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"Fs = Vector{Any}(undef, 2);\nfor j = 1:2\n    Fs[j] = ()->j\nend\nFs[1]()\nFs[2]()","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"for循环或推导迭代变量总是一个新变量：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"function f()\n    i = 0\n    for i = 1:3\n        # empty\n    end\n    return i\nend;\nf()","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"然而，有时可以重用现有的局部变量作为迭代变量。这可以通过添加关键字outer方便地完成：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"function f()\n    i = 0\n    for outer i = 1:3\n        # empty\n    end\n    return i\nend;\nf()","category":"page"},{"location":"ch05scope/#常量","page":"变量的作用域","title":"常量","text":"","category":"section"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"变量的一个常见用法是给特定的、不变的值命名。这样的变量只被赋值一次。这个意图可以通过使用const关键字传递给编译器：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const e = 2.718;\nconst pi = 3.142;","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"可以在一个const语句中声明多个变量：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const a, b = 1, 2","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const声明只能在全局作用域中的全局变量上使用。编译器很难优化涉及全局变量的代码，因为它们的值(甚至它们的类型)几乎在任何时候都可能发生改变。如果全局变量不变，添加const声明就可以解决这个性能问题。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"局部常量则不同的。编译器能够自动确定局部变量何时为常量，因此不需要声明局部常量，实际上目前也不支持局部常量。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"特殊的顶层赋值，例如由function和struct关键字执行的赋值，默认情况下是常量。","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"注意，const只影响变量绑定。变量可以绑定到一个可变对象(比如数组)，并且该对象仍然可以被修改。另外，当试图给一个被声明为常量的变量赋值时，可能会出现以下情况：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"如果新值的类型与常量的类型不同，则抛出一个错误：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const x = 1.0\nx = 1","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"如果新值的类型与常量相同，则会打印警告：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const y = 1.0\ny = 2.0","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"如果赋值不会导致变量值的改变，则不会给出消息：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const z = 100\nz = 100","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"最后一条规则适用于不可变对象，只要值不发生改变，变量的重新绑定实际上是被忽略的，例如：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const s1 = \"1\"\ns2 = \"1\"\npointer.([s1, s2], 1)\ns1 = s2\npointer.([s1, s2], 1)","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"然而，对于可变对象，会按预期打印警告：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const a = [1]\na = [1]","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"请注意，尽管有时可以，但强烈建议不要更改const变量的值，除非在交互使用时为了方便而故意为之。更改常量可能会导致各种问题或意外行为。例如，如果一个方法引用了一个常量，并且在更改该常量之前已经编译过了，那么它将会继续使用原来的值：","category":"page"},{"location":"ch05scope/","page":"变量的作用域","title":"变量的作用域","text":"const x = 1\nf() = x\nf()\nx = 2\nf()","category":"page"},{"location":"ch07array/#数组","page":"数组","title":"数组","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"在前一章中，我们了解了简单数组以及其他形式的集。我们还遍历了集。然而，在Julia中，数组在提供高性能容器方面扮演着重要的角色，这些容器是由内存管理的，能够在本机应用程序之间传输数据。本章，我们将看看数组的一些高级应用。有时，操作是在数组上定义的，或者通过简单的语法修改可以执行复杂的数组操作。","category":"page"},{"location":"ch07array/#容器","page":"数组","title":"容器","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"数组是用于各种操作的最常见集，因为它们是可变的、可扩展的，并且在正确使用时是高效的。本章讨论的一些主题对于新手来说可能是高级的。因此，在你积累语言经验的同时，建议你稍后再复习本章的部分内容。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"向量作为容器是一种非常常见的用例。一些数据结构，如堆栈、队列、二进制堆通常使用一维数组或向量来实现。Julia提供了简单的函数来处理这些情况。下面展示了将向量用作堆栈的示例。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = []\npush!(a, 5)\npush!(a, 5, 6, 7, 8)\npop!(a)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"上述方法对向量按照堆栈的方式进行修改。在操作结束时，还可以使用empty!(vector)方法清空容器。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"length(a)\nisempty(a)\nempty!(a)\nisempty(a)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"让我们看看数组作为队列的操作方式。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"push!(a, 1, 2, 3, 4, 5)\npopfirst!(a)\npushfirst!(a, 1)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"pushfirst!(v, value)是一种将值添加到向量开头的方法。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"note: Note\n尽管pushfirst!和popfirst!方法是存在的，但它们不是最有效的，因为插入和删除第一个元素可能需要复制或移动元素。","category":"page"},{"location":"ch07array/#维度","page":"数组","title":"维度","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"数组可以是任意维度的。虽然我们在前面主要学习了向量(1维)和矩阵(2维)，我们将在本章更多地了解一些高维数组。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:24), 4, 3, 2)\nndims(a)\nsize(a)\nsize(a, 3)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"reshape接受一个集并创建指定形状的数组。ndims给出数组的维数，而size给出每个维中的元素数。size(array, dim)给出在特定维度的大小。数组的内存布局如下图所示：","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"(Image: 3D Array)","category":"page"},{"location":"ch07array/#索引","page":"数组","title":"索引","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"数组使用表达式A[I_1, I_2, ..., I_n]索引。I_i是我们将在本节中探讨的各种类型的索引。","category":"page"},{"location":"ch07array/#常量","page":"数组","title":"常量","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"索引表达式的最简单形式是标量或数字。下面是一些例子：","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:24), 4, 3, 2, 1)","category":"page"},{"location":"ch07array/#范围","page":"数组","title":"范围","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"索引表达式也可以是范围。冒号(:)表示维度中的所有索引。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a[:, 1, 1, 1]\na[2:3, 1, 1, 1]\na[1:2:3, 1, 1, 1]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"可以看到，范围对象可以是任何整数范围类型，如UnitRange、StepRange等。索引表达式也可以使用多个范围索引。这会产生多维数组，其中的元素是从范围中指定的位置提取的。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a[1:2:3, 1:2:3, 1, 1]","category":"page"},{"location":"ch07array/#向量","page":"数组","title":"向量","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"当索引表达式是向量或非标量时，输出将引入额外的维度。下面是一些例子：","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a[1:2:3, 1:2:3, [1], [1]]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"如上例所示，创建的是2×2×1×1数组，而不是2×2数组。默认情况下，索引向量是一维行向量。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a[1:2:3, [1; 3], 1, 1]\na[1:2:3, [1, 3], 1, 1]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"当索引不是按行顺序排列时，输出将无法合并为2×2矩阵：","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"b = a[1:2:3, [1 3], 1, 1]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"生成了一个2×1×2的矩阵。类似地，可以通过提供多维索引来创建更复杂的矩阵。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a[:, [2], [1], [1]]\na[[1 2; 3 4], [2], [1], [1]]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"这里，在第一个索引中引入多维索引为矩阵增加了一个额外维度。矩阵具有2×2×1×1×1维度。前2列是对第二列a[:, [1], [1], [1]]基于索引参数[1 2; 3 4]的重排列。","category":"page"},{"location":"ch07array/#线性索引","page":"数组","title":"线性索引","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"我们在前一章讨论过，数组以行为主的方式存储在一个连续的内存位置，索引指向底层数据。底层数据可以用单个整数索引访问。这种索引称为线性索引。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:6), (2, 3))\na[5]\na[1, 3]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"有一个叫做LinearIndices的类型可以帮助创建这种映射。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"LinearIndices(a)","category":"page"},{"location":"ch07array/#笛卡尔索引","page":"数组","title":"笛卡尔索引","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"笛卡尔索引是一个数字元组，作为数组的维数，代表一个元素。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"A = reshape(collect(1:6), 3, 2)\nci = CartesianIndices(A)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"使用笛卡尔或线性索引取决于对象和数据的组织。稍后，我们将通过查看视图和子数组来进一步了解这些主题的细节。","category":"page"},{"location":"ch07array/#布尔索引","page":"数组","title":"布尔索引","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"布尔索引的作用更像是数据的过滤器。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"x = reshape(collect(1:16), 4, 4)\nfilter = map(ispow2, x)\nx[filter]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"虽然逻辑索引似乎只是为了挑选筛选器值为真的特定值，但与范围索引组合，可以观察到有趣的变化。例如，下面的例子完全选取了第2行和第3行。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"x[[false, true, true, false], :]","category":"page"},{"location":"ch07array/#赋值","page":"数组","title":"赋值","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"我们使用索引的大多数例子都与从数组中提取信息有关。不过，也可以使用类似的表达式为数组元素赋值。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:24), 4, 3, 2, 1);\na[:, 2, 1, 1] = fill(25, 4)\na","category":"page"},{"location":"ch07array/#特殊索引","page":"数组","title":"特殊索引","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"为了便于在集中遍历，可以使用begin和end等特定的关键字作为索引。这些索引也可以与一些数值运算一起使用。前一个数组的元素可以像这样访问：","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a[begin, :, 2, 1], a[begin+1, :, 2, 1]\na[end, :, 2, 1], a[end-1, :, 2, 1]","category":"page"},{"location":"ch07array/#接口","page":"数组","title":"接口","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"以下方法适用于数组或所有支持元素索引访问的集(如Dict)。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"访问X[i]时调用getindex(X, i)返回位于i的元素的值。在多维数组中，访问X[I_1, I_2，..., I_n]时调用扩展的表达式getindex(X, I_1, I_2，..., I_n]。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"setindex!(X, v, i)将值v赋给位置i的数组元素。在多维数组中，表达式X[I_1, I_2，..., I_n] = v内部调用setindex!(X, v, I_1, I_2, ..., I_n)。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"表达式X[begin]调用firstindex(X)来获得第一个索引。firstindex(X, dim)用来获得指定维度的第一个索引。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"表达式X[end]调用lastindex(X)来获得最后一个索引。与firstindex一样，lastindex也可以将维度作为参数。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"firstindex(a)\nlastindex(a)\nlastindex(a, 1)\nlastindex(a, 2)\nlastindex(a, 3)\nlastindex(a, 4)","category":"page"},{"location":"ch07array/#切片","page":"数组","title":"切片","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"切片是通过指定索引来使用数组的一部分。以下是一些例子：","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:9), 3, 3)\na[:, 1]\na[1, :]\na[1, 2:3]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"大多数示例都相当直观，但请注意a[1，:]和a[1, 2:3]，这两个都应该是行矩阵。但是，Julia将返回一个单维列向量。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"b = a[1:2, :]\nb[1, 2] = 10\nb\na","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"使用索引获得切片的最终结果是分配一个新数组。可以看到，修改数组b并不影响a中的数据。这将导致大量的分配，并可能使应用程序的内存池碎片化。其次，这种无价值的增加分配会影响性能。让我们重写这个例子：","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"v = @view a[1:2, :]\nv[1, 2] = 10\nv","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"宏@view围绕数组创建一个视图，其引用数组a中的相同对象。由于视图没有自己的数据，修改视图也会导致底层容器数组中的数据被修改。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a","category":"page"},{"location":"ch07array/#广播","page":"数组","title":"广播","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"让我们看一些矩阵运算。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:9), 3, 3)\nb = reshape(collect(9:-1:1), 3, 3)\na + b","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"将a的每个元素与b的相应元素相加，最终得到一个与输入数组维数相同的数组。由于运算符+被定义为元素类型的运算，因此它可以直接应用于矩阵或数组。让我们看看乘法运算(*)。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a * b","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"返回的结果不是基于元素的乘法，而是矩阵乘法，也称为数组内积。如果要对数组进行元素运算，可以使用广播方法进行同样的操作。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"broadcast(*, a, b)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"可以使用行内点符号(.*)实现同样的效果。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a .* b","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"如果数组a和b的尺寸不同呢？它们能在元素级别上交互吗？保持a不变，让b分别为行向量和列向量，观察结果。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:9), 3, 3)\nb = [1 2 3]\na .+ b","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"同样，当b是列向量时：","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"b = [1, 2, 3]\na .+ b","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"当其中一个数组是行向量或列向量时，如果维数与该方向上的另一个向量匹配，那么它们将沿着该向量的长度广播。尽管广播是以数组为例介绍的，但它可以应用于任何集类型。下面是一个展示了字符串在集中按元素进行连接的示例。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"broadcast(string, (\"one\", \"two\", \"three\", \"four\"), \": \", 1:4)\nstring.((\"one\", \"two\", \"three\", \"four\"), \": \", 1:4)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"“: ”只有一个条目，它重复4次以保证与正在广播的其他集的映射一致。","category":"page"},{"location":"ch07array/#性能","page":"数组","title":"性能","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"有人可能会想，broadcast的效果可以很容易地用repeat来模拟。repeat获取数组的元素，并沿着指定的每个维度重复它们。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"v = [1, 2]\nrepeat(v, 2, 3) # Repeats twice in dim 1 and thrice in dim 2\na + repeat(b, 1, 3)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"这种说法并非完全不正确。但是，每次调用repeat都会分配数组并增加性能损失。broadcast消除了这种额外分配数组的需要。","category":"page"},{"location":"ch07array/#broadcast-vs.-map","page":"数组","title":"broadcast vs. map","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"在讨论broadcast时，有必要回顾前面讨论的map函数。不像broadcast那样在需要时重复元素，map函数执行一对一的映射。从下面的示例中可以看出，map函数只返回一个长度为3的数组，该数组与a和b的最小尺寸相匹配。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a\nb\nmap(+, a, b)","category":"page"},{"location":"ch07array/#归约","page":"数组","title":"归约","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"数组上的归约运算类似于求和。可以对数组沿行和列进行聚合。将数组元素映射到特定函数并按行和列归约结果是相当常见的输出。与broadcast类似，map和reduce方法确保中间分配最小化。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:16), (2, 2, 2, 2))\nreduce(+, a)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"给定集a, reduce方法对所有元素应用二元运算(+)并返回所有元素的和。","category":"page"},{"location":"ch07array/#结合性","page":"数组","title":"结合性","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"让我们将前面的运算符+替换为-。从左到右的结合律与从右到左的结合律会有完全不同的结果。Julia提供了foldl和foldr两个方法，这两个方法实际上是reduce方法左、右结合性的表示。我们可以使用结合运算符(=>)来仔细研究它们的区别。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"foldl(=>, [1, 2, 3, 4])\nfoldr(=>, [1, 2, 3, 4])\nreduce(=>, [1, 2, 3, 4])","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"用运算符(-)替换(=>)，可以看到结果的差异。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"foldl(-, [1, 2, 3, 4])\nfoldr(-, [1, 2, 3, 4])\nreduce(-, [1, 2, 3, 4])","category":"page"},{"location":"ch07array/#映射和归约","page":"数组","title":"映射和归约","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"集可以映射到特定的函数，结果可以归约为聚合结果。一个叫做mapreduce的专门函数同时结合了这两种运算。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"mapreduce(x->x*x, +, [1, 2, 3, 4])","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"前面的示例计算了集的平方和。","category":"page"},{"location":"ch07array/#切片-2","page":"数组","title":"切片","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"我们所研究的映射和归约方法同样适用于其他集。mapslices是一种特殊的函数，它与数组和数组切片密切相关。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = reshape(collect(1:16), 2, 2, 2, 2)\nmapslices(sum, a, dims=[1, 2])","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"该函数对数组的前2维应用sum函数并返回结果。","category":"page"},{"location":"ch07array/#抽象数组类型","page":"数组","title":"抽象数组类型","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"到目前为止，我们观察到数组有两个不同的操作。首先，它提供了一个存储数据的容器，其次，它提供了访问和修改数据的各种方法。可以将迭代、索引和切片视为数据的各种访问方法。像Array{T,N}这样的具体类型满足这两种需求，但在存储方面是死板的。例如，一个只有对角元素的矩阵只需要N个元素来存储数据。一个三对角矩阵（对角和与其平行的前、后对角元素）只需要3N-2个元素来存储数据。使用Array{T, 2}或矩阵来存储这些数据是浪费的，因为它需要N*N的存储空间。AbstractArray{T, N}是满足这种需求的接口。以下是期望由派生类型实现的一些功能，以便它们与其他数组类型无缝地工作。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"size接口提供定义数组所有维度的大小。\n索引接口getindex和setindex!访问和修改数组的数据。\n数组的迭代器接口，使其行为像一个集。\n当需要时，一个类似的接口可以将专门化的数组转换为等效的array{T, N}类型。\n最后，axis方法支持非标准索引，比如从0而不是1开始索引。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"虽然我们建议读者阅读Julia文档以完全理解这个概念，但我们使用示例代码展示了一些实现。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"note: Note\nAbstractVector{T}和AbstractMatrix{T}分别是AbstractArray{T,1}和AbstractArray{T,2}的别名。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"让我们实现一个单位矩阵。单位矩阵的对角元素定义为1，其他元素定义为0。因为它们有固定的模式，所以不需要setindex!方法。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"struct MyIdentity{T} <: AbstractMatrix{T}\n    l::Int\nend\nBase.size(m::MyIdentity)=(m.l, m.l)\nBase.size(m::MyIdentity, d)=(d == 1 || d == 2) ? m.l : error(\"Invalid dimensions\")\nfunction Base.getindex(m::MyIdentity{T}, i, j) where {T}\n    1 <= i <= m.l && 1 <= j <= m.l || error(\"Invalid indices\")\n    i == j && return one(T)\n    return zero(T)\nend","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"仅仅是这个简单的定义就可以给出一个具有几乎所有必要功能的单位矩阵。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a = MyIdentity{Int}(3)\na[2, 1]\na = MyIdentity{Float32}(3)\nsize(a)\nsize(a, 2)\nlength(a)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"只需定义size和getindex方法就可以定义矩阵的大部分行为。这是由于Julia基中定义的默认值。现在，如果我们将一个向量与MyIdentity{T}矩阵相乘，我们应该得到相同的向量。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"a[5] # Linear Indexing\na*[1, 2, 3]","category":"page"},{"location":"ch07array/#稀疏数组","page":"数组","title":"稀疏数组","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"稀疏数组是我们前面讨论的AbstractArray概念的扩展。稀疏数组的本质是减少数组所需的总体存储空间。在许多数值应用中，行列组合中的大多数值都是0，非0值只出现在某些位置。例如，对角线矩阵只有对角线元素上的数据。稀疏数组更进一步，允许将值存储在一个向量中，并通过一个或多个索引向量存储值的位置。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"note: Note\n稀疏数组是Julia标准库中模块SparseArrays的一部分。在使用与稀疏数组相关的任何类型或方法之前，请确保通过using SparseArrays命令导入符号。我们将在后面的章节中详细讨论模块。","category":"page"},{"location":"ch07array/#稀疏向量存储","page":"数组","title":"稀疏向量存储","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"using SparseArrays\nstruct SparseVector{Tv, Ti <: Integer} <: AbstractSparseVector{Tv, Ti}\n    n::Int              # Length of the sparse vector\n    nzind::Vector{Ti}   # Indices of stored values\n    nzval::Vector{Tv}   # Stored values, typically nonzeros\nend","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"nzval是所有非零值的存储向量，nzind是这些值的索引位置，其中n是稀疏向量的长度。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"using SparseArrays\nI = [1, 4, 3, 5]; V = [1, 2, -5, 3];\nR = sparsevec(I, V)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"当I向量中索引的最大值为5时，将创建一个5元素向量。向量R的成员可以像常规向量一样被访问。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"R[2]","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"findnz方法返回存储非零值的所有索引位置。本质上，给定一个稀疏向量或矩阵，它给出了nzind和nzval向量。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"findnz(R)","category":"page"},{"location":"ch07array/#稀疏矩阵存储","page":"数组","title":"稀疏矩阵存储","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"将稀疏向量的概念更进一步，我们可以采用为第2个维度增加一个向量来存储一个矩阵。但是，为了更好地进行存储管理，通常使用以下方法。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"列索引以递增顺序存储在向量中。\n行存储在第二个向量中，当列索引发生冲突时，行按递增顺序存储。\n值存储在按相同方式定义的单独向量中。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"这个概念被称为压缩稀疏列(CSC)。虽然这种格式具有很高的存储效率，但它对插入或修改并不友好，因为任何插入都可能需要将向量中的所有值向右移动。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"struct SparseMatrixCSC{Tv, Ti <: Integer} <: AbstractSparseMatrix{Tv, Ti}\n    m::Int              # Number of rows\n    n::Int              # Number of columns\n    colptr::Vector{Ti}  # Column j is in colptr[j]:(colptr[j+1]-1)\n    rowval::Vector{Ti}  # Row indices of stored values\n    nzval::Vector{Tv}   # Stored values, typically nonzeros\nend","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];\nS = sparse(I, J, V)\nS[1, 2]\nsize(S)","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"与稀疏向量示例一样，SparseMatrixCSC也有类似的函数来创建、访问和操作矩阵。我们将把使用这些数据结构的细节留给读者。","category":"page"},{"location":"ch07array/#效率","page":"数组","title":"效率","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"虽然稀疏数据结构很适合存储，但它们可能不是索引和迭代的最佳选择。在使用这些结构时，要非常小心数据访问的复杂性。即使是简单的索引访问也可能需要扫描索引和数据向量的很大一部分。虽然在迭代过程中增量访问非零值可能是高效的，但对特定索引的随机访问就没有那么高效了。","category":"page"},{"location":"ch07array/#线性代数","page":"数组","title":"线性代数","text":"","category":"section"},{"location":"ch07array/","page":"数组","title":"数组","text":"前面介绍的大多数概念都是数组、向量和矩阵的表示方面，本节是关于它们在处理数学和科学计算中的应用。Julia线性代数功能被聚合到标准库下的一个名为LinearAlgebra的模块中。因此，在使用方法和数据结构之前，你需要使用以下语句。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"using LinearAlgebra","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"Julia线性代数模块可以看成是三个不同的部分。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"Julia原生的基本矩阵和向量运算。\nLAPACK函数。\nBLAS函数。","category":"page"},{"location":"ch07array/","page":"数组","title":"数组","text":"基本模块包含诸如转置(tr)、求逆(inv)、点积(dot)等矩阵运算。还有其他方法，如奇异值分解(svd)、上下三角分解等。特征模块提供各种矩阵类型的特征值计算。我们不会在这里深入研究这些概念，在后面的章节中会有选择地介绍一些方法。","category":"page"},{"location":"#安装与配置","page":"安装与配置","title":"安装与配置","text":"","category":"section"},{"location":"","page":"安装与配置","title":"安装与配置","text":"Julia是一个跨平台应用，安装起来非常容易，不管是使用Windows、Linux还是macOS系统，都可到 Julia官方网站下载安装。在Windows下，安装过程中选择Add Julia to Path复选框，安装成功后就可以在命令行的任何位置启动Julia。","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"Julia有自己的图形窗口REPL（读取-求解-打印-循环），可对程序进行读取和执行。你可以通过桌面快捷图标、程序菜单或命令行来启动这个程序，当程序启动后，你将看到如下界面：","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"(Image: Julia启动界面)","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"最后一行 julia> 为命令提示符，它的出现表明Julia程序正常启动并进入到REPL，等待你输入代码。成功安装Julia软件后，我们需要对开发环境做一个简单的配置，以使你在Julia中的输入和输出看起来与书中的结果相一致（可能会有细微的差别）。在 julia> 提示符后输入如下命令：","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"using Pkg\nPkg.add(\"OhMyREPL\")\nusing OhMyREPL","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"大家可以先不用关心每条语句的具体含义，后面会逐步学到。配置完成后，如果你输入一行代码并按回车，REPL将显示结果：","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"1 + 1","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"另外一点需要说明的是，每次重新启动Julia程序后都要首先输入using OhMyREPL语句，这显然很麻烦。一个解决方案是可以将这条语句放入Julia启动文件startup.jl中。这样，Julia在启动时就会自动调用这条语句。startup.jl文件位于~/.julia/config/中，如果该目录下没有startup.jl文件或.julia目录中没有config目录，则可以自己创建一个。","category":"page"},{"location":"","page":"安装与配置","title":"安装与配置","text":"在下载程序包时，如遇下载速度很慢的情况，可以将Julia程序包服务器镜像切换为国内镜像源，方法是在startup.jl文件中添加一条语句：ENV[\"JULIA_PKG_SERVER\"]=\"https://mirrors.bfsu.edu.cn/julia/static\"。","category":"page"}]
}
