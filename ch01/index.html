<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>第一章 程序设计与Julia · PointLib</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PointLib</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">API Reference</a></li><li class="is-active"><a class="tocitem" href>第一章 程序设计与Julia</a><ul class="internal"><li><a class="tocitem" href="#Julia概述"><span>Julia概述</span></a></li><li><a class="tocitem" href="#什么是程序？"><span>什么是程序？</span></a></li><li><a class="tocitem" href="#运行Julia"><span>运行Julia</span></a></li><li><a class="tocitem" href="#第一个程序"><span>第一个程序</span></a></li><li><a class="tocitem" href="#算术运算符"><span>算术运算符</span></a></li><li><a class="tocitem" href="#值和类型"><span>值和类型</span></a></li><li><a class="tocitem" href="#形式语言和自然语言"><span>形式语言和自然语言</span></a></li><li><a class="tocitem" href="#计算机中数字的存储与运算"><span>计算机中数字的存储与运算</span></a></li><li><a class="tocitem" href="#调试"><span>调试</span></a></li><li><a class="tocitem" href="#术语"><span>术语</span></a></li><li><a class="tocitem" href="#习题"><span>习题</span></a></li></ul></li><li><a class="tocitem" href="../ch02/">第二章 变量、表达式和语句</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>第一章 程序设计与Julia</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>第一章 程序设计与Julia</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/ch01.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="程序设计与Julia"><a class="docs-heading-anchor" href="#程序设计与Julia">程序设计与Julia</a><a id="程序设计与Julia-1"></a><a class="docs-heading-anchor-permalink" href="#程序设计与Julia" title="Permalink"></a></h1><p>本书的目标是使你能够像计算机学家一样思考问题。这一思考方式集成了数学、工程以及自然科学的一些最优秀的特点。计算机学家要像数学家一样使用形式语言来表达思想（具体来说是计算）；像工程师一样设计产品，将零件组成系统，在各种选择之间寻求平衡；像科学家一样观察复杂系统的行为，形成假设并且对预测进行检验。</p><p>对于计算机学家，最重要的技能是问题求解能力。问题求解意味着对问题进行形式化，寻求创新性的解决方案，并且清晰、准确地表达解决方案的能力。事实证明，学习编程的过程是锻炼问题求解能力的一个绝佳机会。</p><p>一方面，你将学习如何编程，这本身就是一个有用的技能。另一方面，你将把编程作为实现自己目的的手段。随着学习的深入，你会更清楚自己的目标。</p><hr/><h2 id="Julia概述"><a class="docs-heading-anchor" href="#Julia概述">Julia概述</a><a id="Julia概述-1"></a><a class="docs-heading-anchor-permalink" href="#Julia概述" title="Permalink"></a></h2><p>Julia是2012年诞生于麻省理工学院的一种开源通用编程语言。它具有如下特点：</p><ul><li>Julia是一种高性能计算编程语言。</li><li>Julia使用多分派技术来提高编程体验和程序运行效率。</li><li>Julia是一种可交互的动态编程语言。</li><li>Julia的语法规则简单易学。</li><li>Julia可以通过提供类型限定来提高程序的清晰性和稳健性。</li><li>Julia有一个不断扩大的标准库和大量的第三方程序包。</li></ul><hr/><h2 id="什么是程序？"><a class="docs-heading-anchor" href="#什么是程序？">什么是程序？</a><a id="什么是程序？-1"></a><a class="docs-heading-anchor-permalink" href="#什么是程序？" title="Permalink"></a></h2><p>程序是详细说明如何执行计算的一系列指令的集成。这里的计算可以是数学中解方程组或者寻找多项式的根；也可以是在一个文档中寻找和替换某些文字；亦或处理一张图片、播放一段视频。</p><p>不同编程语言的细节虽有所不同，但每种语言都共同包含一些基本的指令：</p><p>输入 :   从键盘、文件、网络或其他设备上获取数据。</p><p>输出 :   在屏幕上显示数据，将数据存入文件或通过互联网传输，等等。</p><p>数学 :   执行基本的数学运算，如加、减、乘、除等。</p><p>分支 :   进行条件判断，选择相应的代码执行。</p><p>循环 :   重复执行某些活动，通常在每次执行过程中会做微小的变化。</p><p>不管你相信与否，计算机编程的全部内容就是这些。我们所使用的每种程序语言，不管有多复杂，都是由上面那些指令组成的。因此，你可以把编程理解为将一个庞大复杂的任务分解为越来越小的子任务，这个过程不断重复，直到分解的子任务简单到可以用上面介绍的基本指令中的一个实现为止。</p><hr/><h2 id="运行Julia"><a class="docs-heading-anchor" href="#运行Julia">运行Julia</a><a id="运行Julia-1"></a><a class="docs-heading-anchor-permalink" href="#运行Julia" title="Permalink"></a></h2><p>Julia是一个跨平台应用，安装起来非常容易，不管你是使用Windows、Linux还是macOS系统，都可到 <a href="https://www.julialang.org">Julia官方网站</a>下载安装。</p><p>Julia有自己的图形窗口<em>REPL</em>（读取-求解-打印-循环），可对程序进行读取和执行。你可以通过桌面快捷图标、程序菜单或命令行来启动这个程序，当程序启动后，你将看到如下界面：</p><p><img src="./pictures/juliaREPL.png &quot;Julia REPL&quot;" alt="Julia启动界面"/></p><p>最后一行 <code>julia&gt;</code> 为命令提示符，它的出现表明Julia程序正常启动并进入到REPL，等待你输入代码。成功安装Julia软件后，我们需要对开发环境做一个简单的配置，以使你在Julia中的输入和输出看起来与书中的结果相一致（可能会有细微的差别）。在 <code>julia&gt;</code> 提示符后输入如下命令：</p><pre><code class="language-julia hljs">julia&gt; using Pkg
julia&gt; Pkg.add(&quot;OhMyREPL&quot;)
  Updating registry at `~/.julia/registries/General`
  Updating git-repo `https://github.com/JuliaRegistries/General.git`
julia&gt; using OhMyREPL</code></pre><p>大家可以先不用关心每条语句的具体含义，后面会逐步学到。配置完成后，如果你输入一行代码并按回车，REPL将显示结果：</p><pre><code class="language-julia hljs">julia&gt; 1 + 1
2</code></pre><p>现在你已经知道如何启动Julia程序了。</p><p>另外一点需要说明的是，每次重新启动Julia程序后都要首先输入<code>using OhMyREPL</code>语句，这显然很麻烦。一个解决方案是可以将这条语句放入Julia启动文件<code>startup.jl</code>中。这样，Julia在启动时就会自动调用这条语句。以Windows系统为例，<code>startup.jl</code>文件位于<code>%USERPROFILE%/.julia/config/</code>中，如果该目录下没有<code>startup.jl</code>文件或<code>.julia</code>目录中没有<code>config</code>目录，则可以自己创建一个。在下载程序包时，遇下载速度很慢的情况，可以将Julia 镜像切换为国内镜像源，方法是在<code>startup.jl</code>文件中添加一条命令：<code>ENV[&quot;JULIA_PKG_SERVER&quot;]=&quot;https://mirrors.bfsu.edu.cn/julia/static&quot;</code>。</p><hr/><h2 id="第一个程序"><a class="docs-heading-anchor" href="#第一个程序">第一个程序</a><a id="第一个程序-1"></a><a class="docs-heading-anchor-permalink" href="#第一个程序" title="Permalink"></a></h2><p>一般来说，当你学习一门新语言时写的第一个程序通常为&quot;Hello, World!&quot;，它唯一的作用是在屏幕上输出一串文字&quot;Hello, World!&quot;。在Julia中，它看起来像这样：</p><pre><code class="language-julia hljs">julia&gt; println(&quot;Hello, world!&quot;)
Hello, World!</code></pre><p>尽管它只是在屏幕上显示了结果而没有在纸上打印任何东西，但这确实是<em>打印</em>语句的一个实例。程序中双引号不出现在结果中，它表示所要显示文字内容的开始和结束。括号表明<code>println</code>是一个函数。现在不理解函数的具体用法也没有关系，我们将在第三章中学习函数。</p><hr/><h2 id="算术运算符"><a class="docs-heading-anchor" href="#算术运算符">算术运算符</a><a id="算术运算符-1"></a><a class="docs-heading-anchor-permalink" href="#算术运算符" title="Permalink"></a></h2><p>紧接着&quot;Hello, World!&quot;要学习的是算术运算。Julia提供的<em>运算符</em>是一种能够代表诸如加、减、乘、除一类计算的符号。运算符<code>+</code>，<code>-</code>和<code>*</code>分别执行加，减和乘，如下例所示：</p><pre><code class="language-julia hljs">julia&gt; 40 + 2
42
julia&gt; 43 - 1
42
julia&gt; 6 * 7
42</code></pre><p>运算符<code>/</code>执行除法：</p><pre><code class="language-julia hljs">julia&gt; 84 / 2
42.0</code></pre><p>你也许会发现，结果是<code>42.0</code>，而不是<code>42</code>。我将在下节解释其原因。</p><p>运算符<code>^</code>执行幂计算，即乘方运算：</p><pre><code class="language-julia hljs">julia&gt; 6^2
36</code></pre><hr/><h2 id="值和类型"><a class="docs-heading-anchor" href="#值和类型">值和类型</a><a id="值和类型-1"></a><a class="docs-heading-anchor-permalink" href="#值和类型" title="Permalink"></a></h2><p><em>值</em>，例如一个字母或一个数字，是程序要处理的基本元素之一。目前我们所见到的值有<code>2</code>，<code>42.0</code>和<code>&quot;Hello, World!&quot;</code> 等。</p><p>这些值属于不同的<em>类型</em>：<code>2</code>为<em>整数</em>，<code>42.0</code>为<em>浮点数</em>，<code>&quot;Hello, World!&quot;</code>为<em>字符串</em>，字符串得名于其有序排列的字母好像被绳子穿成了一串。</p><p>如果你不能确定值的类型，可在REPL中输入如下命令：</p><pre><code class="language-julia hljs">julia&gt; typeof(2)
Int64
julia&gt; typeof(42.0)
Float64
julia&gt; typeof(&quot;Hello, World!&quot;)
String</code></pre><p>整数属于<code>Int64</code>类型，浮点数属于<code>Float64</code>类型，字符串属于<code>String</code>类型。</p><p>值<code>&quot;2&quot;</code>和<code>&quot;42.0&quot;</code>属于什么类型？虽然它们看起来像数字，但由于它们被置于双引号中，因此是字符串，见下例：</p><pre><code class="language-julia hljs">julia&gt; typeof(&quot;2&quot;)
String
julia&gt; typeof(&quot;42.0&quot;)
String</code></pre><p>当你输入一个比较大的整数时，你可能习惯于使用逗号将数字分组，如<code>1,000,000</code>。在Julia中，采用这种方法表示整数是非法的，但就其表示本身而言确是合法的：</p><pre><code class="language-julia hljs">julia&gt; 1,000,000
(1, 0, 0)</code></pre><p>这不是我们想要的结果。Julia将<code>1,000,000</code>解析为用逗号分隔的整数序列。我们将在第十二章学习这种类型的序列。我们可以使用<code>1_000_000</code>来得到我们想要的结果：</p><pre><code class="language-julia hljs">julia&gt; 1_000_000
1000000</code></pre><hr/><h2 id="形式语言和自然语言"><a class="docs-heading-anchor" href="#形式语言和自然语言">形式语言和自然语言</a><a id="形式语言和自然语言-1"></a><a class="docs-heading-anchor-permalink" href="#形式语言和自然语言" title="Permalink"></a></h2><p><em>自然语言</em>是人们日常交流使用的语言，如英语，西班牙语，法语，汉语等。它们不是人为设计（尽管有人试图这样做，但并不成功，可参考<a href="https://lernu.net/zh-cn/esperanto">世界语</a>）的，而是自然进化的结果。</p><p><em>形式语言</em>是人们为了实现某些特殊应用而设计的语言。例如数学家用数学符号表示数量和符号中的相互关系。化学家使用化学符号来表示分子结构。这些语言都是各自领域内的形式语言。同样，编程语言是一种设计用来表达计算的形式语言。</p><p>形式语言一般具有严格的<em>语法</em>规则来限制语句结构。例如，<span>$3+3=6$</span>是语法正确的数学表达式，而<span>$3+=3\$</span>6<span>$则不是。$</span>\rm{H<em>2O}<span>$是语法正确的化学式，而$</span>\rm{</em>2Zz}则不是。</p><p>语法规则包含两方面内容：<em>标识</em>和<em>结构</em>。标识是语言的基本组成单位，如文字、数字、化学元素等。<span>$3+=3\$</span>6<span>$在语法是错误的原因之一在于：在数学语言中$</span><span>$</span>是非法标识（至少一般情况下是这样的）。同样，在化学语言中，没有以缩写<span>$\rm{Zz}$</span>表示的元素。</p><p>语法规则的第二条内容是有关标识的组合方式。方程<span>$3+=3$</span>在语法上是错误的，尽管<code>+</code>，<code>=</code>都是合法的标识，但却不允许这两个标识连接到一起使用。类似地，在化学公式中，下标只能出现在元素名的后面，而不是前面。</p><blockquote><p>该句子结构:+1:，但标识:-1:。 正确该句子标识，但错误结构。</p></blockquote><p>当你用汉语阅读一个句子或用形式语言阅读一条命令时，你必须要识别出它们各自的结构（尽管在自然语言中，我们是下意识地做了这件事）。这个过程称为<em>解析</em>。</p><p>尽管形式语言和自然语言有许多共同的特点——标识，结构和语法——但它们有如下不同：</p><p>歧义 :   自然语言充满了歧义，人们通过上下文线索和其他信息来对真正的语义进行判断。形式语言被设计成几乎或完全没有歧义，这意味着任何语句都有一个非常明确的含义，而这个含义与上下文无关。</p><p>冗余 :   自然语言为了消除歧义，减少误解，使用了大量冗余的表达方法，常表现为句子很长。形式语言很少有冗余，因此很简洁。</p><p>字面性 :   自然语言充满了成语和比喻。如果我说“靴子落地了”。通常情况下，这里并不存在一双靴子，也没有什么东西落到了地上（这个习语表现了人们对于某一急切、观望的事件，终于有了结果）。而对形式语言来说，它要表达的就是一双（只）靴子落到了地面上。</p><p>由于我们从小就说自然语言，因此有时很难适应形式语言。自然语言与形式语言的区别就像诗歌与散文的区别，但又更加明显：</p><p>诗歌 :   文字既要考虑含义又要考虑韵律，整首诗通过义韵相互配合创造了一种意境或反映了一种情感。歧义不仅常见，而且往往是刻意营造的。</p><p>散文 :   词义、句式更加重要。相较于诗歌，散文更容易分析，但往往也存在歧义。</p><p>程序 :   计算机程序所表达的含义是字面上的、无歧义的，可以完全通过对标识和结构的分析来明确。</p><p>形式语言的语义密度比自然语言高，因此需要花更多的时间理解。另外，其结构也很重要，有时从上往下，从左往右地阅读程序不是一个很好的选择。相反，你要学会在头脑中解析程序，识别出各种标识和语法结构。最后，细节很重要，在自然语言中，一些拼写和标点错误并无大碍，但在形式语言中可能会引起巨大的差异。</p><hr/><h2 id="计算机中数字的存储与运算"><a class="docs-heading-anchor" href="#计算机中数字的存储与运算">计算机中数字的存储与运算</a><a id="计算机中数字的存储与运算-1"></a><a class="docs-heading-anchor-permalink" href="#计算机中数字的存储与运算" title="Permalink"></a></h2><p>在 Julia 中，如果你输入<span>$(\sqrt3)^2$</span>，结果将是 2.9....96，其中 9 重复了 15 次。相比与传统的数学运算，计算机的运算方式有两个明显且本质的区别:</p><ol><li><p>计算机只能表示有限数量的数字;</p></li><li><p>计算机中表示的一个数字只能有有限多个有效数字。</p></li></ol><p>因此，能够在计算机中精确表示的数字只是有理数的一个子集。每当计算机执行一个运算，当结果不是一个可以在计算机中精确表示的数字时，就会用一个近似值来代替这个精确的数字。这被称为<em>舍入误差</em>：用计算机进行实数计算时产生的错误。</p><h3 id="实数的浮点表示方法"><a class="docs-heading-anchor" href="#实数的浮点表示方法">实数的浮点表示方法</a><a id="实数的浮点表示方法-1"></a><a class="docs-heading-anchor-permalink" href="#实数的浮点表示方法" title="Permalink"></a></h3><p>下面是在计算机中表示实数的一般模型：</p><p class="math-container">\[x=s(.a_1a_2...a_{t})_{\beta}\times\beta^{e} \tag{1}\]</p><p>其中</p><p class="math-container">\[\begin{align*}
s &amp; → x=±1 的符号 \\[2ex] 
e &amp; → 指数，范围为L≤e≤U \\[2ex] 
(.a_1... a_{t})_{\beta} &amp; = \dfrac{a_1}{\beta}+\dfrac{a_2}{\beta^2}+\cdots+\dfrac{a_t}{\beta^t}；尾数 \\[2ex]
β &amp; → 基数 \\[2ex]
t &amp; → 有效数字个数；精度 
\end{align*}\]</p><p>在浮点表示法(1)中，如果我们以这样一种方式指定<span>$e$</span>，即<span>$a_1≠ 0$</span>，那么表示将是唯一的。这称为<strong>规格化</strong>的浮点表示法。例如，如果<span>$β = 10$</span>，在规格化的浮点数中，我们将把<span>$0.012$</span>写成<span>$0.12 × 10^{−1}$</span>，而不是<span>$0.012 × 10^0$</span>或<span>$0.0012 × 10^1$</span>。</p><p>在当今大多数计算机中，基数是<span>$β = 2$</span>。过去老式的IBM大型机中曾使用过基数8和16。一些手持计算器使用基数10。莫斯科国立大学开发的Setun计算机，使用的基数是3，但并没有得到广泛推广。</p><p>对于<span>$s$</span>，<span>$β$</span>，<span>$t$</span>，<span>$e$</span>的值，在一般浮点模型(1)中有多种选择。IEEE 64位浮点表示是当今大多数计算机中使用的特定模型：</p><p class="math-container">\[x=(-1)^s(1.a_2a_3... a_{53})_2 2^{e-1023} \tag{2}\]</p><ul><li><p>注意在方程(1)和(2)中<span>$s$</span>的不同表现形式。在(2)中，<span>$s$</span>为0或1。<span>$s = 0$</span>，<span>$x$</span>是正的；<span>$s = 1$</span>, <span>$x$</span>是负的。</p></li><li><p>由于<span>$β = 2$</span>，在<span>$x$</span>的规格化的浮点表示中，小数点后的第一个(非零)位必然是1。因此我们不需要存储这个数字。这就是为什么在(2)中我们把<span>$x$</span>写成从1开始的小数。即使精度是<span>$t = 52$</span>，我们也能够访问到第53位有效数字<span>$a_{53}$</span>。</p></li><li><p>指数的范围是:<span>$0≤e≤2047$</span>。稍后会讨论2047的来源。但首先，我们讨论一下为什么在(2)表示法中我们用<span>$e - 1023$</span>作为指数，而不是简单地用<span>$e$</span>(在(1)表示法中)作为指数。如果最小的可能指数是<span>$e = 0$</span>，那么计算机能生成的最小正数将是<span>$(1.00…0)_2 = 1$</span>：当然，我们需要计算机来表示小于1的数字！这就是为什么我们在表示(2)中使用称为<strong>有偏指数</strong>的移位表达式<span>$e - 1023$</span>。注意，有偏指数的范围是<span>$- 1023≤e - 1023≤1024$</span>。</p></li></ul><p>下图说明了计算机的物理位如何与上面的表示相对应。下表中编号为1到64的每个单元对应于计算机内存中的物理位。</p><p><img src="/pictures/physicalbits.png" alt="Physical bits"/></p><ul><li><p>第一位是符号位：它存储<span>$s$</span>的值，0或1。</p></li><li><p>蓝色的2到12位存储指数<span>$e$</span>(不是<span>$e−1023$</span>)。使用11位，可以生成从<span>$0$</span>到<span>$2^{11}−1 = 2047$</span>的整数。下面是如何得到<span>$e$</span>的最小值和最大值：</p></li></ul>$<p>e=(00...0)<em>2=0 \[1ex]  e=(11...1)</em>2 =2^0+2^1+...+2^{10}=\dfrac{2^{11}-1}{2-1}=2047 $</p><ul><li>红色的52位，存储有效数字<span>$a_2$</span>到<span>$a_{53}$</span>。</li></ul><p><strong>例1</strong>：求10.375的浮点表示形式。</p><p><strong>解</strong>： 通过计算 <span>$10=0\times2^0+\textcolor{blue}{1}× 2^1 + \textcolor{green}{0}\times2^2+\textcolor{red}{1}\times2^3$</span> 和 <span>$0.375=0\times2^{-1}+\textcolor{blue}{1}\times2^{-2}+\textcolor{green}{1}\times2^{-3}$</span> 可以得到 <span>$10=(\textcolor{red}{1}\textcolor{green}{0}\textcolor{blue}{1}0)_2$</span> 和 <span>$0.375=(.0\textcolor{blue}{1}\textcolor{green}{1})_2$</span>。最终得到：</p><p class="math-container">\[10.375=(1010.011)_2=(1.010011)_2\times2^3\]</p><p>式中<span>$(1.010011)_2 × 2^3$</span>为该数字的规格化的浮点表示。现在我们将其改写为式(2)的表示形式：</p><p class="math-container">\[10.375=(-1)^0(1.010011)_2\times2^{1026-1023}\]</p><p>由于<span>$1026 =(10000000010)_2$</span>，按位表示的最终结果为：</p><p><img src="pictures/base10number.png" alt="基于10的数"/></p><p>注意因为数字是正数，第一个符号位是0。接下来的11位(蓝色)代表指数<span>$e = 1026$</span>，下一组红色的位是尾数，尾数的最末一位有效数字以后用0填充。在Julia中，我们可以通过输入<code>bitstring(10.375)</code>来逐位表示：</p><pre><code class="language-julia hljs">julia&gt; bitstring(10.375)
&quot;0100000000100100110000000000000000000000000000000000000000000000&quot;</code></pre><p><strong>特殊情况：0，无穷，非数</strong></p><p>在浮点算术中有两个零：<span>$+0.0$</span>和<span>$−0.0$</span>，它们有特殊的表示。在表示0时，所有的指数位和尾数位都设置为0。符号位是0的代表<span>$+0.0$</span>，1的代表<span>$−0.0$</span>：</p><p><img src="pictures/zeros.png" alt="zeros"/></p><p>当指数位设置为0时，我们有<span>$e = 0$</span>，因此<span>$e−1023 =−1023$</span>。这种将所有指数位设置为零的情况，是为<span>$±0.0$</span>和<strong>非规格化</strong>数字保留的。非规格化数用来表示靠近0的数或0。</p><p>下面是计算机中正负无穷数的表示方法：</p><p><img src="pictures/inf.png" alt="正负无穷数"/></p><p>当指数位全设置为1时，我们有<span>$e = 2047$</span>，因此<span>$e−1023 = 1024$</span>。这种安排是专门为<span>$±∞$</span>以及其他特殊值，如NaN(非数)保留的；当尾数等于0时表示无穷大，尾数不等于0时表示非数。</p><p>综上所述，尽管(2)中的<span>$−1023≤e−1023≤1024$</span>，但在表示非零实数时，我们只能访问<span>$−1022≤e−1023≤1023$</span>的指数范围。</p><p>因此，计算机可以表示的最小正实数（非规格化）为：</p><p class="math-container">\[x=(-1)^0(0.00...1)_2\times2^{-1022}=2^{-52}\times2^{-1022}=5.0\times10^{-324}\]</p><p>最大正实数（规格化）为：</p><p class="math-container">\[x=(-1)^0(1.11...1)_2\times2^{1023}=\left(1+\dfrac{1}{2}+\dfrac{1}{2^2}+...+\dfrac{1}{2^{52}} \right)\times2^{1023}=(2-2^{-52})\times2^{1023}≈0.18\times10^{309}\]</p><p>在计算过程中，如果得到一个小于最小浮点数的数字，则会产生<strong>下溢错误</strong>。大于最大值的数字会产生<strong>上溢错误</strong>。</p><p>Julia中上溢和下溢错误分别是正负无穷：</p><pre><code class="language-julia hljs">julia&gt; nextfloat((2.0-2^(-52))*2.0^1023)
Inf

julia&gt; prevfloat(-(2.0-2^(-52))*2.0^1023)
-Inf</code></pre><p>其运算方式与水银式温度计类似。</p><h3 id="整数的表示方法"><a class="docs-heading-anchor" href="#整数的表示方法">整数的表示方法</a><a id="整数的表示方法-1"></a><a class="docs-heading-anchor-permalink" href="#整数的表示方法" title="Permalink"></a></h3><p>在前一节中，我们讨论了计算机中实数的表示方法。这里我们将简要讨论整数的表示方法。计算机如何表示整数<span>$n$</span>？与实数类似，我们以2为基数开始写<span>$n$</span>。我们有64位来表示它的有效数字和符号。与浮点数一样，我们为符号分配一位，将其余的63位用于有效数字。当对整数进行加法运算时，这种方法有一些缺点。另一种方法被称为<strong>二进制补码</strong>，它更常用，包括在Julia中。</p><p>举个例子，假设我们的计算机是8位的。要用二进制补码表示12(或任何正整数)，只需将它写成以2为基数展开的形式：<span>$(00001100)_2$</span>。为了表示−12，我们做如下操作：翻转所有数位，用0替换1，用1替换0，然后在结果上加1。翻转数字12，我们得到<span>$(11110011)_2$</span>，加上1（二进制）得到<span>$(11110100)_2$</span>。因此，−12在二进制补码法中被表示为<span>$(11110100)_2$</span>。为了表示-12，费了那么大的功夫，感觉有点奇怪，但当把12和-12二进制表示相加时，这种表示方法的优势立刻显现：</p><p class="math-container">\[(00001100)_2+(11110100)_2=(\textcolor{red}{1}00000000)_2\]</p><p>这个和的前8位(从右到左)，也就是计算机能表示的(忽略红色数字1)，是<span>$(00000000)_2$</span>。所以就像以10为基数的<span>$12 +(- 12)= 0$</span>一样，这些数的表示形式的和也是0。</p><p>我们可以用Julia实现64位的计算。函数<code>bitstring</code>输出一个整数的数位，对于负数使用二进制补码：</p><pre><code class="language-julia hljs">julia&gt; bitstring(12)
&quot;0000000000000000000000000000000000000000000000000000000000001100&quot;

julia&gt; bitstring(-12)
&quot;1111111111111111111111111111111111111111111111111111111111110100&quot;</code></pre><p>你可以验证当截断到64位时，这些表示的和为0。</p><p>下面是另一个说明二进制补码优点的例子。考虑−3和5的表现，</p><p class="math-container">\[-3=(11111101)_2 和 5 =(00000101)_2\]</p><p>−3和5的和是2；那么它们表示形式的二进制和呢？我们有：</p><p class="math-container">\[(11111101)_2+(00000101)_2=(\textcolor{red}{1}00000010)_2\]</p><p>如果我们忽略红色的第9位，结果是<span>$(10)_2$</span>，结果也确实是2。注意，如果我们遵循浮点表示中使用的相同方法，并将最左边的位分配给整数的符号，就不会有这个属性。</p><p>在二进制补码中，使用64位，可以表示<span>$−2^{63} =−9223372036854775808$</span>和<span>$2^{63}−1 =9223372036854775807$</span>之间的整数。小于或大于这个范围的任何整数都会产生<strong>下溢</strong>或<strong>上溢</strong>错误。</p><p>整数的溢出与浮点数有所不同，如下所示：</p><pre><code class="language-julia hljs">julia&gt; typemax(Int64)
9223372036854775807

julia&gt; typemin(Int64)
-9223372036854775808

julia&gt; typemax(Int64) + 1
-9223372036854775808

julia&gt; typemin(Int64) - 1
9223372036854775807</code></pre><p>当获得一个超过最大（或最小）可能值的整数时，Julia绕到最小（或最大）的整数，并继续计算。其运算方法与指针式钟表完全一样。</p><hr/><h2 id="调试"><a class="docs-heading-anchor" href="#调试">调试</a><a id="调试-1"></a><a class="docs-heading-anchor-permalink" href="#调试" title="Permalink"></a></h2><p>编程尤其是调试，有时是一件很挠头的事情。如果一个程序很难调试成功，你也许会感到愤怒，沮丧或是惭愧。通常，人们会把计算机当做人来看待，当他们工作出色时，我们会把他们当做队友，当他们难于控制或表现不佳（粗俗）时，我们对待他们的态度就像面对粗俗不羁的人一样。</p><p>对这些情况思想上有所准备是一个好的处理方法。你可以将计算机想象为一个雇员，他精准高效，但缺乏感情，不具大局观。你的工作是成为一名好的管理者：找到使他发挥长处，避免弱点的方法。学习程序调试的过程往往是令人沮丧的，但它所带来的好处远不止编程！</p><hr/><h2 id="术语"><a class="docs-heading-anchor" href="#术语">术语</a><a id="术语-1"></a><a class="docs-heading-anchor-permalink" href="#术语" title="Permalink"></a></h2><p>解决问题 :  对一个问题进行建模、求解和描述的过程。</p><p>程序 : 实现一种计算的一系列指令。</p><p>REPL : 一个程序，不断重复输入读取，计算执行和结果输出。</p><p>提示符 : 一种字符，表明REPL正在等待用户输入。</p><p>打印命令 : Julia REPL用来在屏幕上显示值的一条指令。</p><p>运算符 : 代表加、减、乘、除或字符串连接等简单计算的一种符号。</p><p>值 : 程序处理数据的基本单位之一，如数字或字符串。</p><p>类型 : 值的类别。目前我们见过的类型有整形（<code>Int64</code>），浮点型（<code>Float64</code>）和字符串型（<code>String</code>）。</p><p>整型 : 代表所有整数的类型。</p><p>浮点型 : 代表有小数点的所有数的类型。</p><p>字符串型 : 代表字符序列的类型。</p><p>自然语言 : 人们使用的自然进化的任意一种语言。</p><p>形式语言 : 人们为了特殊目的设计的任意一种语言，如数学语言，编程语言。所有程序语言都是形式语言。</p><p>语法 : 规定程序结构的规则。</p><p>标识 : 程序语法结构中基本元素之一，与自然语言中文字类似。</p><p>结构 : 标识组合的方式。</p><p>解析 : 对程序进行检验并分析语法结构。</p><p>调试 : 寻找和改正程序中错误的过程。</p><hr/><h2 id="习题"><a class="docs-heading-anchor" href="#习题">习题</a><a id="习题-1"></a><a class="docs-heading-anchor-permalink" href="#习题" title="Permalink"></a></h2><h3 id="习题1-1"><a class="docs-heading-anchor" href="#习题1-1">习题1-1</a><a id="习题1-1-1"></a><a class="docs-heading-anchor-permalink" href="#习题1-1" title="Permalink"></a></h3><p>当你尝试一个新特性时，尽量多制造错误。例如，在&quot;Hello, World!&quot;程序中，如果你去掉其中一个引号会怎么样？如果两个都去掉呢？如果将 <code>println</code> 拼错会怎么样？</p><p>这些试验会帮助你记住你从书上学到的知识，当然对编程也很有益处，因为你会掌握错误信息的含义。现在故意制造一些错误远胜于以后意外发生错误。</p><ol><li>在打印命令中，去掉一个括号会怎么样，两个都去掉呢？</li><li>如果你想打印一个字符串，去掉一个引号会怎么样，两个都去掉呢？</li><li>你可以使用减号来表示一个负数，如 <code>-2</code>。如果你在一个数字前面加上加号会怎么样？<code>2++2</code> 的结果是什么？</li><li>在数学表达中，可以保留数字前面的0，如 <code>02</code>。在Julia中尝试这种输入，看看会发生什么？</li><li>如果两个数字之间没有运算符会怎么样？</li></ol><h3 id="习题1-2"><a class="docs-heading-anchor" href="#习题1-2">习题1-2</a><a id="习题1-2-1"></a><a class="docs-heading-anchor-permalink" href="#习题1-2" title="Permalink"></a></h3><p>启动Julia REPL，将它作为计算器使用。</p><ol><li>42分42秒是多少秒？</li><li>10公里是多少英里？ </li></ol><blockquote><p>1.61公里等于1英里。</p></blockquote><ol><li>如果你用37分48秒跑了10公里，你的平均速度是多少（英里每分，英里每秒，英里每小时）？</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« API Reference</a><a class="docs-footer-nextpage" href="../ch02/">第二章 变量、表达式和语句 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Wednesday 10 November 2021 21:03">Wednesday 10 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
